#![allow(intra_doc_link_resolution_failure)]
#![deny(missing_docs)]
#![deny(rust_2018_compatibility)]
#![deny(rust_2018_idioms)]
#![deny(warnings)]
#![doc = "nrf52840 register API"]
#![no_std]
use core::marker::PhantomData;
#[doc = r" An instance of a peripheral"]
pub trait Peripheral {
    #[doc = r" The base address of the peripheral instance"]
    fn base_address() -> usize;
}
#[allow(dead_code)]
struct NotSendOrSync {
    inner: PhantomData<*mut ()>,
}
#[allow(dead_code)]
impl NotSendOrSync {
    fn new() -> Self {
        Self { inner: PhantomData }
    }
}
#[allow(non_camel_case_types)]
#[cfg(feature = "FICR")]
#[doc = "Factory information configuration registers"]
pub type FICR = ficr::Registers;
#[cfg(feature = "FICR")]
#[doc = "Factory information configuration registers"]
pub mod ficr {
    #[allow(non_camel_case_types)]
    #[doc = "Code memory page size"]
    pub type CODEPAGESIZE = codepagesize::Register;
    #[doc = "Code memory page size"]
    pub mod codepagesize {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *const u32 {
                (super::BASE_ADDRESS + 0x10) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bits 0..=32) Code memory page size"]
            pub fn CODEPAGESIZE(self) -> u32 {
                const OFFSET: u8 = 0;
                const MASK: u32 = 0xffff_ffff;
                ((self.inner >> OFFSET) as u32) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u32 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "CODEPAGESIZE {{ CODEPAGESIZE: {0:32} }}@14500125961457063167"]
                #[link_section = ".binfmt.CODEPAGESIZE {{ CODEPAGESIZE: {0:32} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Code memory size"]
    pub type CODESIZE = codesize::Register;
    #[doc = "Code memory size"]
    pub mod codesize {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *const u32 {
                (super::BASE_ADDRESS + 0x14) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bits 0..=32) Code memory size in number of pages"]
            pub fn CODESIZE(self) -> u32 {
                const OFFSET: u8 = 0;
                const MASK: u32 = 0xffff_ffff;
                ((self.inner >> OFFSET) as u32) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u32 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "CODESIZE {{ CODESIZE: {0:32} }}@16531105512228876619"]
                #[link_section = ".binfmt.CODESIZE {{ CODESIZE: {0:32} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Description collection: Device identifier"]
    pub type DEVICEID0 = deviceid0::Register;
    #[doc = "Description collection: Device identifier"]
    pub mod deviceid0 {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *const u32 {
                (super::BASE_ADDRESS + 0x60) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bits 0..=32) 64 bit unique device identifier"]
            pub fn DEVICEID(self) -> u32 {
                const OFFSET: u8 = 0;
                const MASK: u32 = 0xffff_ffff;
                ((self.inner >> OFFSET) as u32) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u32 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "DEVICEID0 {{ DEVICEID: {0:32} }}@15818077951305272862"]
                #[link_section = ".binfmt.DEVICEID0 {{ DEVICEID: {0:32} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Description collection: Device identifier"]
    pub type DEVICEID1 = deviceid1::Register;
    #[doc = "Description collection: Device identifier"]
    pub mod deviceid1 {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *const u32 {
                (super::BASE_ADDRESS + 0x64) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bits 0..=32) 64 bit unique device identifier"]
            pub fn DEVICEID(self) -> u32 {
                const OFFSET: u8 = 0;
                const MASK: u32 = 0xffff_ffff;
                ((self.inner >> OFFSET) as u32) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u32 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "DEVICEID1 {{ DEVICEID: {0:32} }}@17289648416425198852"]
                #[link_section = ".binfmt.DEVICEID1 {{ DEVICEID: {0:32} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Description collection: Encryption root, word n"]
    pub type ER0 = er0::Register;
    #[doc = "Description collection: Encryption root, word n"]
    pub mod er0 {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *const u32 {
                (super::BASE_ADDRESS + 0x80) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bits 0..=32) Encryption root, word n"]
            pub fn ER(self) -> u32 {
                const OFFSET: u8 = 0;
                const MASK: u32 = 0xffff_ffff;
                ((self.inner >> OFFSET) as u32) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u32 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "ER0 {{ ER: {0:32} }}@3671808540056618495"]
                #[link_section = ".binfmt.ER0 {{ ER: {0:32} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Description collection: Encryption root, word n"]
    pub type ER1 = er1::Register;
    #[doc = "Description collection: Encryption root, word n"]
    pub mod er1 {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *const u32 {
                (super::BASE_ADDRESS + 0x84) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bits 0..=32) Encryption root, word n"]
            pub fn ER(self) -> u32 {
                const OFFSET: u8 = 0;
                const MASK: u32 = 0xffff_ffff;
                ((self.inner >> OFFSET) as u32) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u32 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "ER1 {{ ER: {0:32} }}@6232783706717012566"]
                #[link_section = ".binfmt.ER1 {{ ER: {0:32} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Description collection: Encryption root, word n"]
    pub type ER2 = er2::Register;
    #[doc = "Description collection: Encryption root, word n"]
    pub mod er2 {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *const u32 {
                (super::BASE_ADDRESS + 0x88) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bits 0..=32) Encryption root, word n"]
            pub fn ER(self) -> u32 {
                const OFFSET: u8 = 0;
                const MASK: u32 = 0xffff_ffff;
                ((self.inner >> OFFSET) as u32) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u32 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "ER2 {{ ER: {0:32} }}@10529851498728505615"]
                #[link_section = ".binfmt.ER2 {{ ER: {0:32} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Description collection: Encryption root, word n"]
    pub type ER3 = er3::Register;
    #[doc = "Description collection: Encryption root, word n"]
    pub mod er3 {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *const u32 {
                (super::BASE_ADDRESS + 0x8c) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bits 0..=32) Encryption root, word n"]
            pub fn ER(self) -> u32 {
                const OFFSET: u8 = 0;
                const MASK: u32 = 0xffff_ffff;
                ((self.inner >> OFFSET) as u32) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u32 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "ER3 {{ ER: {0:32} }}@11571207989496400710"]
                #[link_section = ".binfmt.ER3 {{ ER: {0:32} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Description collection: Identity Root, word n"]
    pub type IR0 = ir0::Register;
    #[doc = "Description collection: Identity Root, word n"]
    pub mod ir0 {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *const u32 {
                (super::BASE_ADDRESS + 0x90) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bits 0..=32) Identity Root, word n"]
            pub fn IR(self) -> u32 {
                const OFFSET: u8 = 0;
                const MASK: u32 = 0xffff_ffff;
                ((self.inner >> OFFSET) as u32) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u32 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "IR0 {{ IR: {0:32} }}@12072247656552318712"]
                #[link_section = ".binfmt.IR0 {{ IR: {0:32} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Description collection: Identity Root, word n"]
    pub type IR1 = ir1::Register;
    #[doc = "Description collection: Identity Root, word n"]
    pub mod ir1 {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *const u32 {
                (super::BASE_ADDRESS + 0x94) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bits 0..=32) Identity Root, word n"]
            pub fn IR(self) -> u32 {
                const OFFSET: u8 = 0;
                const MASK: u32 = 0xffff_ffff;
                ((self.inner >> OFFSET) as u32) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u32 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "IR1 {{ IR: {0:32} }}@6925368719107756164"]
                #[link_section = ".binfmt.IR1 {{ IR: {0:32} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Description collection: Identity Root, word n"]
    pub type IR2 = ir2::Register;
    #[doc = "Description collection: Identity Root, word n"]
    pub mod ir2 {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *const u32 {
                (super::BASE_ADDRESS + 0x98) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bits 0..=32) Identity Root, word n"]
            pub fn IR(self) -> u32 {
                const OFFSET: u8 = 0;
                const MASK: u32 = 0xffff_ffff;
                ((self.inner >> OFFSET) as u32) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u32 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "IR2 {{ IR: {0:32} }}@680520868815483093"]
                #[link_section = ".binfmt.IR2 {{ IR: {0:32} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Description collection: Identity Root, word n"]
    pub type IR3 = ir3::Register;
    #[doc = "Description collection: Identity Root, word n"]
    pub mod ir3 {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *const u32 {
                (super::BASE_ADDRESS + 0x9c) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bits 0..=32) Identity Root, word n"]
            pub fn IR(self) -> u32 {
                const OFFSET: u8 = 0;
                const MASK: u32 = 0xffff_ffff;
                ((self.inner >> OFFSET) as u32) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u32 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "IR3 {{ IR: {0:32} }}@17781718902253879941"]
                #[link_section = ".binfmt.IR3 {{ IR: {0:32} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Device address type"]
    pub type DEVICEADDRTYPE = deviceaddrtype::Register;
    #[doc = "Device address type"]
    pub mod deviceaddrtype {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *const u32 {
                (super::BASE_ADDRESS + 0xa0) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bit 0) Device address type"]
            pub fn DEVICEADDRTYPE(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u8 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "DEVICEADDRTYPE {{ DEVICEADDRTYPE: {0} }}@8131410716583077684"]
                #[link_section = ".binfmt.DEVICEADDRTYPE {{ DEVICEADDRTYPE: {0} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Description collection: Device address n"]
    pub type DEVICEADDR0 = deviceaddr0::Register;
    #[doc = "Description collection: Device address n"]
    pub mod deviceaddr0 {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *const u32 {
                (super::BASE_ADDRESS + 0xa4) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bits 0..=32) 48 bit device address"]
            pub fn DEVICEADDR(self) -> u32 {
                const OFFSET: u8 = 0;
                const MASK: u32 = 0xffff_ffff;
                ((self.inner >> OFFSET) as u32) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u32 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "DEVICEADDR0 {{ DEVICEADDR: {0:32} }}@7817486062514410306"]
                #[link_section = ".binfmt.DEVICEADDR0 {{ DEVICEADDR: {0:32} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Description collection: Device address n"]
    pub type DEVICEADDR1 = deviceaddr1::Register;
    #[doc = "Description collection: Device address n"]
    pub mod deviceaddr1 {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *const u32 {
                (super::BASE_ADDRESS + 0xa8) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bits 0..=32) 48 bit device address"]
            pub fn DEVICEADDR(self) -> u32 {
                const OFFSET: u8 = 0;
                const MASK: u32 = 0xffff_ffff;
                ((self.inner >> OFFSET) as u32) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u32 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "DEVICEADDR1 {{ DEVICEADDR: {0:32} }}@14204115676291154971"]
                #[link_section = ".binfmt.DEVICEADDR1 {{ DEVICEADDR: {0:32} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Part code"]
    pub type INFO_PART = info_part::Register;
    #[doc = "Part code"]
    pub mod info_part {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *const u32 {
                (super::BASE_ADDRESS + 0x0100) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bits 0..=32) Part code"]
            pub fn PART(self) -> u32 {
                const OFFSET: u8 = 0;
                const MASK: u32 = 0xffff_ffff;
                ((self.inner >> OFFSET) as u32) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u32 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "INFO_PART {{ PART: {0:32} }}@2002508541392329489"]
                #[link_section = ".binfmt.INFO_PART {{ PART: {0:32} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Build code (hardware version and production configuration)"]
    pub type INFO_VARIANT = info_variant::Register;
    #[doc = "Build code (hardware version and production configuration)"]
    pub mod info_variant {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *const u32 {
                (super::BASE_ADDRESS + 0x0104) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bits 0..=32) Build code (hardware version and production configuration). Encoded as ASCII."]
            pub fn VARIANT(self) -> u32 {
                const OFFSET: u8 = 0;
                const MASK: u32 = 0xffff_ffff;
                ((self.inner >> OFFSET) as u32) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u32 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "INFO_VARIANT {{ VARIANT: {0:32} }}@8377147555294547222"]
                #[link_section = ".binfmt.INFO_VARIANT {{ VARIANT: {0:32} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Package option"]
    pub type INFO_PACKAGE = info_package::Register;
    #[doc = "Package option"]
    pub mod info_package {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *const u32 {
                (super::BASE_ADDRESS + 0x0108) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bits 0..=32) Package option"]
            pub fn PACKAGE(self) -> u32 {
                const OFFSET: u8 = 0;
                const MASK: u32 = 0xffff_ffff;
                ((self.inner >> OFFSET) as u32) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u32 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "INFO_PACKAGE {{ PACKAGE: {0:32} }}@11551953538857090651"]
                #[link_section = ".binfmt.INFO_PACKAGE {{ PACKAGE: {0:32} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "RAM variant"]
    pub type INFO_RAM = info_ram::Register;
    #[doc = "RAM variant"]
    pub mod info_ram {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *const u32 {
                (super::BASE_ADDRESS + 0x010c) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bits 0..=32) RAM variant"]
            pub fn RAM(self) -> u32 {
                const OFFSET: u8 = 0;
                const MASK: u32 = 0xffff_ffff;
                ((self.inner >> OFFSET) as u32) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u32 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "INFO_RAM {{ RAM: {0:32} }}@8657849715863671848"]
                #[link_section = ".binfmt.INFO_RAM {{ RAM: {0:32} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Flash variant"]
    pub type INFO_FLASH = info_flash::Register;
    #[doc = "Flash variant"]
    pub mod info_flash {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *const u32 {
                (super::BASE_ADDRESS + 0x0110) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bits 0..=32) Flash variant"]
            pub fn FLASH(self) -> u32 {
                const OFFSET: u8 = 0;
                const MASK: u32 = 0xffff_ffff;
                ((self.inner >> OFFSET) as u32) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u32 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "INFO_FLASH {{ FLASH: {0:32} }}@10542541682589311819"]
                #[link_section = ".binfmt.INFO_FLASH {{ FLASH: {0:32} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Description collection: Production test signature n"]
    pub type PRODTEST0 = prodtest0::Register;
    #[doc = "Description collection: Production test signature n"]
    pub mod prodtest0 {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *const u32 {
                (super::BASE_ADDRESS + 0x0350) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bits 0..=32) Production test signature n"]
            pub fn PRODTEST(self) -> u32 {
                const OFFSET: u8 = 0;
                const MASK: u32 = 0xffff_ffff;
                ((self.inner >> OFFSET) as u32) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u32 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "PRODTEST0 {{ PRODTEST: {0:32} }}@17765395988287112120"]
                #[link_section = ".binfmt.PRODTEST0 {{ PRODTEST: {0:32} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Description collection: Production test signature n"]
    pub type PRODTEST1 = prodtest1::Register;
    #[doc = "Description collection: Production test signature n"]
    pub mod prodtest1 {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *const u32 {
                (super::BASE_ADDRESS + 0x0354) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bits 0..=32) Production test signature n"]
            pub fn PRODTEST(self) -> u32 {
                const OFFSET: u8 = 0;
                const MASK: u32 = 0xffff_ffff;
                ((self.inner >> OFFSET) as u32) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u32 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "PRODTEST1 {{ PRODTEST: {0:32} }}@4908856612270661223"]
                #[link_section = ".binfmt.PRODTEST1 {{ PRODTEST: {0:32} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Description collection: Production test signature n"]
    pub type PRODTEST2 = prodtest2::Register;
    #[doc = "Description collection: Production test signature n"]
    pub mod prodtest2 {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *const u32 {
                (super::BASE_ADDRESS + 0x0358) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bits 0..=32) Production test signature n"]
            pub fn PRODTEST(self) -> u32 {
                const OFFSET: u8 = 0;
                const MASK: u32 = 0xffff_ffff;
                ((self.inner >> OFFSET) as u32) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u32 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "PRODTEST2 {{ PRODTEST: {0:32} }}@6230660338404873516"]
                #[link_section = ".binfmt.PRODTEST2 {{ PRODTEST: {0:32} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Slope definition A0"]
    pub type TEMP_A0 = temp_a0::Register;
    #[doc = "Slope definition A0"]
    pub mod temp_a0 {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *const u32 {
                (super::BASE_ADDRESS + 0x0404) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bits 0..=12) A (slope definition) register."]
            pub fn A(self) -> u16 {
                const OFFSET: u8 = 0;
                const MASK: u16 = 0x0fff;
                ((self.inner >> OFFSET) as u16) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u16 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "TEMP_A0 {{ A: {0:12} }}@10223318227625043807"]
                #[link_section = ".binfmt.TEMP_A0 {{ A: {0:12} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Slope definition A1"]
    pub type TEMP_A1 = temp_a1::Register;
    #[doc = "Slope definition A1"]
    pub mod temp_a1 {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *const u32 {
                (super::BASE_ADDRESS + 0x0408) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bits 0..=12) A (slope definition) register."]
            pub fn A(self) -> u16 {
                const OFFSET: u8 = 0;
                const MASK: u16 = 0x0fff;
                ((self.inner >> OFFSET) as u16) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u16 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "TEMP_A1 {{ A: {0:12} }}@8751080165371098342"]
                #[link_section = ".binfmt.TEMP_A1 {{ A: {0:12} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Slope definition A2"]
    pub type TEMP_A2 = temp_a2::Register;
    #[doc = "Slope definition A2"]
    pub mod temp_a2 {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *const u32 {
                (super::BASE_ADDRESS + 0x040c) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bits 0..=12) A (slope definition) register."]
            pub fn A(self) -> u16 {
                const OFFSET: u8 = 0;
                const MASK: u16 = 0x0fff;
                ((self.inner >> OFFSET) as u16) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u16 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "TEMP_A2 {{ A: {0:12} }}@2921188001537942117"]
                #[link_section = ".binfmt.TEMP_A2 {{ A: {0:12} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Slope definition A3"]
    pub type TEMP_A3 = temp_a3::Register;
    #[doc = "Slope definition A3"]
    pub mod temp_a3 {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *const u32 {
                (super::BASE_ADDRESS + 0x0410) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bits 0..=12) A (slope definition) register."]
            pub fn A(self) -> u16 {
                const OFFSET: u8 = 0;
                const MASK: u16 = 0x0fff;
                ((self.inner >> OFFSET) as u16) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u16 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "TEMP_A3 {{ A: {0:12} }}@1814919541115611889"]
                #[link_section = ".binfmt.TEMP_A3 {{ A: {0:12} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Slope definition A4"]
    pub type TEMP_A4 = temp_a4::Register;
    #[doc = "Slope definition A4"]
    pub mod temp_a4 {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *const u32 {
                (super::BASE_ADDRESS + 0x0414) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bits 0..=12) A (slope definition) register."]
            pub fn A(self) -> u16 {
                const OFFSET: u8 = 0;
                const MASK: u16 = 0x0fff;
                ((self.inner >> OFFSET) as u16) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u16 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "TEMP_A4 {{ A: {0:12} }}@12313116185372357822"]
                #[link_section = ".binfmt.TEMP_A4 {{ A: {0:12} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Slope definition A5"]
    pub type TEMP_A5 = temp_a5::Register;
    #[doc = "Slope definition A5"]
    pub mod temp_a5 {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *const u32 {
                (super::BASE_ADDRESS + 0x0418) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bits 0..=12) A (slope definition) register."]
            pub fn A(self) -> u16 {
                const OFFSET: u8 = 0;
                const MASK: u16 = 0x0fff;
                ((self.inner >> OFFSET) as u16) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u16 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "TEMP_A5 {{ A: {0:12} }}@16135310467596305825"]
                #[link_section = ".binfmt.TEMP_A5 {{ A: {0:12} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Y-intercept B0"]
    pub type TEMP_B0 = temp_b0::Register;
    #[doc = "Y-intercept B0"]
    pub mod temp_b0 {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *const u32 {
                (super::BASE_ADDRESS + 0x041c) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bits 0..=14) B (y-intercept)"]
            pub fn B(self) -> u16 {
                const OFFSET: u8 = 0;
                const MASK: u16 = 0x3fff;
                ((self.inner >> OFFSET) as u16) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u16 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "TEMP_B0 {{ B: {0:14} }}@8861006190872240806"]
                #[link_section = ".binfmt.TEMP_B0 {{ B: {0:14} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Y-intercept B1"]
    pub type TEMP_B1 = temp_b1::Register;
    #[doc = "Y-intercept B1"]
    pub mod temp_b1 {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *const u32 {
                (super::BASE_ADDRESS + 0x0420) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bits 0..=14) B (y-intercept)"]
            pub fn B(self) -> u16 {
                const OFFSET: u8 = 0;
                const MASK: u16 = 0x3fff;
                ((self.inner >> OFFSET) as u16) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u16 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "TEMP_B1 {{ B: {0:14} }}@13789905463549512093"]
                #[link_section = ".binfmt.TEMP_B1 {{ B: {0:14} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Y-intercept B2"]
    pub type TEMP_B2 = temp_b2::Register;
    #[doc = "Y-intercept B2"]
    pub mod temp_b2 {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *const u32 {
                (super::BASE_ADDRESS + 0x0424) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bits 0..=14) B (y-intercept)"]
            pub fn B(self) -> u16 {
                const OFFSET: u8 = 0;
                const MASK: u16 = 0x3fff;
                ((self.inner >> OFFSET) as u16) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u16 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "TEMP_B2 {{ B: {0:14} }}@540730252460490666"]
                #[link_section = ".binfmt.TEMP_B2 {{ B: {0:14} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Y-intercept B3"]
    pub type TEMP_B3 = temp_b3::Register;
    #[doc = "Y-intercept B3"]
    pub mod temp_b3 {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *const u32 {
                (super::BASE_ADDRESS + 0x0428) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bits 0..=14) B (y-intercept)"]
            pub fn B(self) -> u16 {
                const OFFSET: u8 = 0;
                const MASK: u16 = 0x3fff;
                ((self.inner >> OFFSET) as u16) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u16 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "TEMP_B3 {{ B: {0:14} }}@17859921273449673856"]
                #[link_section = ".binfmt.TEMP_B3 {{ B: {0:14} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Y-intercept B4"]
    pub type TEMP_B4 = temp_b4::Register;
    #[doc = "Y-intercept B4"]
    pub mod temp_b4 {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *const u32 {
                (super::BASE_ADDRESS + 0x042c) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bits 0..=14) B (y-intercept)"]
            pub fn B(self) -> u16 {
                const OFFSET: u8 = 0;
                const MASK: u16 = 0x3fff;
                ((self.inner >> OFFSET) as u16) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u16 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "TEMP_B4 {{ B: {0:14} }}@17792277627044517179"]
                #[link_section = ".binfmt.TEMP_B4 {{ B: {0:14} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Y-intercept B5"]
    pub type TEMP_B5 = temp_b5::Register;
    #[doc = "Y-intercept B5"]
    pub mod temp_b5 {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *const u32 {
                (super::BASE_ADDRESS + 0x0430) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bits 0..=14) B (y-intercept)"]
            pub fn B(self) -> u16 {
                const OFFSET: u8 = 0;
                const MASK: u16 = 0x3fff;
                ((self.inner >> OFFSET) as u16) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u16 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "TEMP_B5 {{ B: {0:14} }}@3125035152608458898"]
                #[link_section = ".binfmt.TEMP_B5 {{ B: {0:14} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Segment end T0"]
    pub type TEMP_T0 = temp_t0::Register;
    #[doc = "Segment end T0"]
    pub mod temp_t0 {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *const u32 {
                (super::BASE_ADDRESS + 0x0434) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bits 0..=8) T (segment end) register"]
            pub fn T(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0xff;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u8 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "TEMP_T0 {{ T: {0:8} }}@9248559744264856887"]
                #[link_section = ".binfmt.TEMP_T0 {{ T: {0:8} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Segment end T1"]
    pub type TEMP_T1 = temp_t1::Register;
    #[doc = "Segment end T1"]
    pub mod temp_t1 {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *const u32 {
                (super::BASE_ADDRESS + 0x0438) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bits 0..=8) T (segment end) register"]
            pub fn T(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0xff;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u8 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "TEMP_T1 {{ T: {0:8} }}@17560259916841752039"]
                #[link_section = ".binfmt.TEMP_T1 {{ T: {0:8} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Segment end T2"]
    pub type TEMP_T2 = temp_t2::Register;
    #[doc = "Segment end T2"]
    pub mod temp_t2 {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *const u32 {
                (super::BASE_ADDRESS + 0x043c) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bits 0..=8) T (segment end) register"]
            pub fn T(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0xff;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u8 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "TEMP_T2 {{ T: {0:8} }}@10068067535972637639"]
                #[link_section = ".binfmt.TEMP_T2 {{ T: {0:8} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Segment end T3"]
    pub type TEMP_T3 = temp_t3::Register;
    #[doc = "Segment end T3"]
    pub mod temp_t3 {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *const u32 {
                (super::BASE_ADDRESS + 0x0440) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bits 0..=8) T (segment end) register"]
            pub fn T(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0xff;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u8 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "TEMP_T3 {{ T: {0:8} }}@15456620555688445865"]
                #[link_section = ".binfmt.TEMP_T3 {{ T: {0:8} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Segment end T4"]
    pub type TEMP_T4 = temp_t4::Register;
    #[doc = "Segment end T4"]
    pub mod temp_t4 {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *const u32 {
                (super::BASE_ADDRESS + 0x0444) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bits 0..=8) T (segment end) register"]
            pub fn T(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0xff;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u8 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "TEMP_T4 {{ T: {0:8} }}@1064126209383784244"]
                #[link_section = ".binfmt.TEMP_T4 {{ T: {0:8} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Default header for NFC tag. Software can read these values to populate NFCID1_3RD_LAST, NFCID1_2ND_LAST, and NFCID1_LAST."]
    pub type NFC_TAGHEADER0 = nfc_tagheader0::Register;
    #[doc = "Default header for NFC tag. Software can read these values to populate NFCID1_3RD_LAST, NFCID1_2ND_LAST, and NFCID1_LAST."]
    pub mod nfc_tagheader0 {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *const u32 {
                (super::BASE_ADDRESS + 0x0450) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bits 0..=8) Default Manufacturer ID: Nordic Semiconductor ASA has ICM 0x5F"]
            pub fn MFGID(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0xff;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bits 8..=16) Unique identifier byte 1"]
            pub fn UD1(self) -> u8 {
                const OFFSET: u8 = 8;
                const MASK: u8 = 0xff;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bits 16..=24) Unique identifier byte 2"]
            pub fn UD2(self) -> u8 {
                const OFFSET: u8 = 16;
                const MASK: u8 = 0xff;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bits 24..=32) Unique identifier byte 3"]
            pub fn UD3(self) -> u8 {
                const OFFSET: u8 = 24;
                const MASK: u8 = 0xff;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u32 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "NFC_TAGHEADER0 {{ UD3: {24:32}, UD2: {16:24}, UD1: {8:16}, MFGID: {0:8} }}@1314571247849026968"]
                #[link_section = ".binfmt.NFC_TAGHEADER0 {{ UD3: {24:32}, UD2: {16:24}, UD1: {8:16}, MFGID: {0:8} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Default header for NFC tag. Software can read these values to populate NFCID1_3RD_LAST, NFCID1_2ND_LAST, and NFCID1_LAST."]
    pub type NFC_TAGHEADER1 = nfc_tagheader1::Register;
    #[doc = "Default header for NFC tag. Software can read these values to populate NFCID1_3RD_LAST, NFCID1_2ND_LAST, and NFCID1_LAST."]
    pub mod nfc_tagheader1 {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *const u32 {
                (super::BASE_ADDRESS + 0x0454) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bits 0..=8) Unique identifier byte 4"]
            pub fn UD4(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0xff;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bits 8..=16) Unique identifier byte 5"]
            pub fn UD5(self) -> u8 {
                const OFFSET: u8 = 8;
                const MASK: u8 = 0xff;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bits 16..=24) Unique identifier byte 6"]
            pub fn UD6(self) -> u8 {
                const OFFSET: u8 = 16;
                const MASK: u8 = 0xff;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bits 24..=32) Unique identifier byte 7"]
            pub fn UD7(self) -> u8 {
                const OFFSET: u8 = 24;
                const MASK: u8 = 0xff;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u32 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "NFC_TAGHEADER1 {{ UD7: {24:32}, UD6: {16:24}, UD5: {8:16}, UD4: {0:8} }}@8981428653544132505"]
                #[link_section = ".binfmt.NFC_TAGHEADER1 {{ UD7: {24:32}, UD6: {16:24}, UD5: {8:16}, UD4: {0:8} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Default header for NFC tag. Software can read these values to populate NFCID1_3RD_LAST, NFCID1_2ND_LAST, and NFCID1_LAST."]
    pub type NFC_TAGHEADER2 = nfc_tagheader2::Register;
    #[doc = "Default header for NFC tag. Software can read these values to populate NFCID1_3RD_LAST, NFCID1_2ND_LAST, and NFCID1_LAST."]
    pub mod nfc_tagheader2 {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *const u32 {
                (super::BASE_ADDRESS + 0x0458) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bits 0..=8) Unique identifier byte 8"]
            pub fn UD8(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0xff;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bits 8..=16) Unique identifier byte 9"]
            pub fn UD9(self) -> u8 {
                const OFFSET: u8 = 8;
                const MASK: u8 = 0xff;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bits 16..=24) Unique identifier byte 10"]
            pub fn UD10(self) -> u8 {
                const OFFSET: u8 = 16;
                const MASK: u8 = 0xff;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bits 24..=32) Unique identifier byte 11"]
            pub fn UD11(self) -> u8 {
                const OFFSET: u8 = 24;
                const MASK: u8 = 0xff;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u32 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "NFC_TAGHEADER2 {{ UD11: {24:32}, UD10: {16:24}, UD9: {8:16}, UD8: {0:8} }}@9398961382590602431"]
                #[link_section = ".binfmt.NFC_TAGHEADER2 {{ UD11: {24:32}, UD10: {16:24}, UD9: {8:16}, UD8: {0:8} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Default header for NFC tag. Software can read these values to populate NFCID1_3RD_LAST, NFCID1_2ND_LAST, and NFCID1_LAST."]
    pub type NFC_TAGHEADER3 = nfc_tagheader3::Register;
    #[doc = "Default header for NFC tag. Software can read these values to populate NFCID1_3RD_LAST, NFCID1_2ND_LAST, and NFCID1_LAST."]
    pub mod nfc_tagheader3 {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *const u32 {
                (super::BASE_ADDRESS + 0x045c) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bits 0..=8) Unique identifier byte 12"]
            pub fn UD12(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0xff;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bits 8..=16) Unique identifier byte 13"]
            pub fn UD13(self) -> u8 {
                const OFFSET: u8 = 8;
                const MASK: u8 = 0xff;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bits 16..=24) Unique identifier byte 14"]
            pub fn UD14(self) -> u8 {
                const OFFSET: u8 = 16;
                const MASK: u8 = 0xff;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bits 24..=32) Unique identifier byte 15"]
            pub fn UD15(self) -> u8 {
                const OFFSET: u8 = 24;
                const MASK: u8 = 0xff;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u32 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "NFC_TAGHEADER3 {{ UD15: {24:32}, UD14: {16:24}, UD13: {8:16}, UD12: {0:8} }}@10459974673379375559"]
                #[link_section = ".binfmt.NFC_TAGHEADER3 {{ UD15: {24:32}, UD14: {16:24}, UD13: {8:16}, UD12: {0:8} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Amount of bytes for the required entropy bits"]
    pub type TRNG90B_BYTES = trng90b_bytes::Register;
    #[doc = "Amount of bytes for the required entropy bits"]
    pub mod trng90b_bytes {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *const u32 {
                (super::BASE_ADDRESS + 0x0c00) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bits 0..=32) Amount of bytes for the required entropy bits"]
            pub fn BYTES(self) -> u32 {
                const OFFSET: u8 = 0;
                const MASK: u32 = 0xffff_ffff;
                ((self.inner >> OFFSET) as u32) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u32 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "TRNG90B_BYTES {{ BYTES: {0:32} }}@7293144695002756533"]
                #[link_section = ".binfmt.TRNG90B_BYTES {{ BYTES: {0:32} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Repetition counter cutoff"]
    pub type TRNG90B_RCCUTOFF = trng90b_rccutoff::Register;
    #[doc = "Repetition counter cutoff"]
    pub mod trng90b_rccutoff {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *const u32 {
                (super::BASE_ADDRESS + 0x0c04) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bits 0..=32) Repetition counter cutoff"]
            pub fn RCCUTOFF(self) -> u32 {
                const OFFSET: u8 = 0;
                const MASK: u32 = 0xffff_ffff;
                ((self.inner >> OFFSET) as u32) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u32 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "TRNG90B_RCCUTOFF {{ RCCUTOFF: {0:32} }}@10458911791316200213"]
                #[link_section = ".binfmt.TRNG90B_RCCUTOFF {{ RCCUTOFF: {0:32} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Adaptive proportion cutoff"]
    pub type TRNG90B_APCUTOFF = trng90b_apcutoff::Register;
    #[doc = "Adaptive proportion cutoff"]
    pub mod trng90b_apcutoff {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *const u32 {
                (super::BASE_ADDRESS + 0x0c08) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bits 0..=32) Adaptive proportion cutoff"]
            pub fn APCUTOFF(self) -> u32 {
                const OFFSET: u8 = 0;
                const MASK: u32 = 0xffff_ffff;
                ((self.inner >> OFFSET) as u32) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u32 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "TRNG90B_APCUTOFF {{ APCUTOFF: {0:32} }}@10463003602312449808"]
                #[link_section = ".binfmt.TRNG90B_APCUTOFF {{ APCUTOFF: {0:32} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Amount of bytes for the startup tests"]
    pub type TRNG90B_STARTUP = trng90b_startup::Register;
    #[doc = "Amount of bytes for the startup tests"]
    pub mod trng90b_startup {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *const u32 {
                (super::BASE_ADDRESS + 0x0c0c) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bits 0..=32) Amount of bytes for the startup tests"]
            pub fn STARTUP(self) -> u32 {
                const OFFSET: u8 = 0;
                const MASK: u32 = 0xffff_ffff;
                ((self.inner >> OFFSET) as u32) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u32 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "TRNG90B_STARTUP {{ STARTUP: {0:32} }}@4128950942335929383"]
                #[link_section = ".binfmt.TRNG90B_STARTUP {{ STARTUP: {0:32} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Sample count for ring oscillator 1"]
    pub type TRNG90B_ROSC1 = trng90b_rosc1::Register;
    #[doc = "Sample count for ring oscillator 1"]
    pub mod trng90b_rosc1 {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *const u32 {
                (super::BASE_ADDRESS + 0x0c10) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bits 0..=32) Sample count for ring oscillator 1"]
            pub fn ROSC1(self) -> u32 {
                const OFFSET: u8 = 0;
                const MASK: u32 = 0xffff_ffff;
                ((self.inner >> OFFSET) as u32) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u32 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "TRNG90B_ROSC1 {{ ROSC1: {0:32} }}@17710920663427857655"]
                #[link_section = ".binfmt.TRNG90B_ROSC1 {{ ROSC1: {0:32} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Sample count for ring oscillator 2"]
    pub type TRNG90B_ROSC2 = trng90b_rosc2::Register;
    #[doc = "Sample count for ring oscillator 2"]
    pub mod trng90b_rosc2 {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *const u32 {
                (super::BASE_ADDRESS + 0x0c14) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bits 0..=32) Sample count for ring oscillator 2"]
            pub fn ROSC2(self) -> u32 {
                const OFFSET: u8 = 0;
                const MASK: u32 = 0xffff_ffff;
                ((self.inner >> OFFSET) as u32) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u32 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "TRNG90B_ROSC2 {{ ROSC2: {0:32} }}@13510964843494698411"]
                #[link_section = ".binfmt.TRNG90B_ROSC2 {{ ROSC2: {0:32} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Sample count for ring oscillator 3"]
    pub type TRNG90B_ROSC3 = trng90b_rosc3::Register;
    #[doc = "Sample count for ring oscillator 3"]
    pub mod trng90b_rosc3 {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *const u32 {
                (super::BASE_ADDRESS + 0x0c18) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bits 0..=32) Sample count for ring oscillator 3"]
            pub fn ROSC3(self) -> u32 {
                const OFFSET: u8 = 0;
                const MASK: u32 = 0xffff_ffff;
                ((self.inner >> OFFSET) as u32) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u32 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "TRNG90B_ROSC3 {{ ROSC3: {0:32} }}@3835655605908692211"]
                #[link_section = ".binfmt.TRNG90B_ROSC3 {{ ROSC3: {0:32} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Sample count for ring oscillator 4"]
    pub type TRNG90B_ROSC4 = trng90b_rosc4::Register;
    #[doc = "Sample count for ring oscillator 4"]
    pub mod trng90b_rosc4 {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *const u32 {
                (super::BASE_ADDRESS + 0x0c1c) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bits 0..=32) Sample count for ring oscillator 4"]
            pub fn ROSC4(self) -> u32 {
                const OFFSET: u8 = 0;
                const MASK: u32 = 0xffff_ffff;
                ((self.inner >> OFFSET) as u32) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u32 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "TRNG90B_ROSC4 {{ ROSC4: {0:32} }}@4046301581034875082"]
                #[link_section = ".binfmt.TRNG90B_ROSC4 {{ ROSC4: {0:32} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
    }
    use core::sync::atomic::{AtomicBool, Ordering};
    const BASE_ADDRESS: usize = 0x1000_0000;
    #[allow(non_snake_case)]
    #[doc = "Singleton handle to the FICR registers"]
    pub struct Registers {
        #[doc = "Code memory page size"]
        pub CODEPAGESIZE: CODEPAGESIZE,
        #[doc = "Code memory size"]
        pub CODESIZE: CODESIZE,
        #[doc = "Description collection: Device identifier"]
        pub DEVICEID0: DEVICEID0,
        #[doc = "Description collection: Device identifier"]
        pub DEVICEID1: DEVICEID1,
        #[doc = "Description collection: Encryption root, word n"]
        pub ER0: ER0,
        #[doc = "Description collection: Encryption root, word n"]
        pub ER1: ER1,
        #[doc = "Description collection: Encryption root, word n"]
        pub ER2: ER2,
        #[doc = "Description collection: Encryption root, word n"]
        pub ER3: ER3,
        #[doc = "Description collection: Identity Root, word n"]
        pub IR0: IR0,
        #[doc = "Description collection: Identity Root, word n"]
        pub IR1: IR1,
        #[doc = "Description collection: Identity Root, word n"]
        pub IR2: IR2,
        #[doc = "Description collection: Identity Root, word n"]
        pub IR3: IR3,
        #[doc = "Device address type"]
        pub DEVICEADDRTYPE: DEVICEADDRTYPE,
        #[doc = "Description collection: Device address n"]
        pub DEVICEADDR0: DEVICEADDR0,
        #[doc = "Description collection: Device address n"]
        pub DEVICEADDR1: DEVICEADDR1,
        #[doc = "Part code"]
        pub INFO_PART: INFO_PART,
        #[doc = "Build code (hardware version and production configuration)"]
        pub INFO_VARIANT: INFO_VARIANT,
        #[doc = "Package option"]
        pub INFO_PACKAGE: INFO_PACKAGE,
        #[doc = "RAM variant"]
        pub INFO_RAM: INFO_RAM,
        #[doc = "Flash variant"]
        pub INFO_FLASH: INFO_FLASH,
        #[doc = "Description collection: Production test signature n"]
        pub PRODTEST0: PRODTEST0,
        #[doc = "Description collection: Production test signature n"]
        pub PRODTEST1: PRODTEST1,
        #[doc = "Description collection: Production test signature n"]
        pub PRODTEST2: PRODTEST2,
        #[doc = "Slope definition A0"]
        pub TEMP_A0: TEMP_A0,
        #[doc = "Slope definition A1"]
        pub TEMP_A1: TEMP_A1,
        #[doc = "Slope definition A2"]
        pub TEMP_A2: TEMP_A2,
        #[doc = "Slope definition A3"]
        pub TEMP_A3: TEMP_A3,
        #[doc = "Slope definition A4"]
        pub TEMP_A4: TEMP_A4,
        #[doc = "Slope definition A5"]
        pub TEMP_A5: TEMP_A5,
        #[doc = "Y-intercept B0"]
        pub TEMP_B0: TEMP_B0,
        #[doc = "Y-intercept B1"]
        pub TEMP_B1: TEMP_B1,
        #[doc = "Y-intercept B2"]
        pub TEMP_B2: TEMP_B2,
        #[doc = "Y-intercept B3"]
        pub TEMP_B3: TEMP_B3,
        #[doc = "Y-intercept B4"]
        pub TEMP_B4: TEMP_B4,
        #[doc = "Y-intercept B5"]
        pub TEMP_B5: TEMP_B5,
        #[doc = "Segment end T0"]
        pub TEMP_T0: TEMP_T0,
        #[doc = "Segment end T1"]
        pub TEMP_T1: TEMP_T1,
        #[doc = "Segment end T2"]
        pub TEMP_T2: TEMP_T2,
        #[doc = "Segment end T3"]
        pub TEMP_T3: TEMP_T3,
        #[doc = "Segment end T4"]
        pub TEMP_T4: TEMP_T4,
        #[doc = "Default header for NFC tag. Software can read these values to populate NFCID1_3RD_LAST, NFCID1_2ND_LAST, and NFCID1_LAST."]
        pub NFC_TAGHEADER0: NFC_TAGHEADER0,
        #[doc = "Default header for NFC tag. Software can read these values to populate NFCID1_3RD_LAST, NFCID1_2ND_LAST, and NFCID1_LAST."]
        pub NFC_TAGHEADER1: NFC_TAGHEADER1,
        #[doc = "Default header for NFC tag. Software can read these values to populate NFCID1_3RD_LAST, NFCID1_2ND_LAST, and NFCID1_LAST."]
        pub NFC_TAGHEADER2: NFC_TAGHEADER2,
        #[doc = "Default header for NFC tag. Software can read these values to populate NFCID1_3RD_LAST, NFCID1_2ND_LAST, and NFCID1_LAST."]
        pub NFC_TAGHEADER3: NFC_TAGHEADER3,
        #[doc = "Amount of bytes for the required entropy bits"]
        pub TRNG90B_BYTES: TRNG90B_BYTES,
        #[doc = "Repetition counter cutoff"]
        pub TRNG90B_RCCUTOFF: TRNG90B_RCCUTOFF,
        #[doc = "Adaptive proportion cutoff"]
        pub TRNG90B_APCUTOFF: TRNG90B_APCUTOFF,
        #[doc = "Amount of bytes for the startup tests"]
        pub TRNG90B_STARTUP: TRNG90B_STARTUP,
        #[doc = "Sample count for ring oscillator 1"]
        pub TRNG90B_ROSC1: TRNG90B_ROSC1,
        #[doc = "Sample count for ring oscillator 2"]
        pub TRNG90B_ROSC2: TRNG90B_ROSC2,
        #[doc = "Sample count for ring oscillator 3"]
        pub TRNG90B_ROSC3: TRNG90B_ROSC3,
        #[doc = "Sample count for ring oscillator 4"]
        pub TRNG90B_ROSC4: TRNG90B_ROSC4,
    }
    unsafe impl Send for Registers {}
    impl Registers {
        #[doc = r" # Safety"]
        #[doc = r" Singleton"]
        unsafe fn new() -> Self {
            Self {
                CODEPAGESIZE: CODEPAGESIZE::new(),
                CODESIZE: CODESIZE::new(),
                DEVICEID0: DEVICEID0::new(),
                DEVICEID1: DEVICEID1::new(),
                ER0: ER0::new(),
                ER1: ER1::new(),
                ER2: ER2::new(),
                ER3: ER3::new(),
                IR0: IR0::new(),
                IR1: IR1::new(),
                IR2: IR2::new(),
                IR3: IR3::new(),
                DEVICEADDRTYPE: DEVICEADDRTYPE::new(),
                DEVICEADDR0: DEVICEADDR0::new(),
                DEVICEADDR1: DEVICEADDR1::new(),
                INFO_PART: INFO_PART::new(),
                INFO_VARIANT: INFO_VARIANT::new(),
                INFO_PACKAGE: INFO_PACKAGE::new(),
                INFO_RAM: INFO_RAM::new(),
                INFO_FLASH: INFO_FLASH::new(),
                PRODTEST0: PRODTEST0::new(),
                PRODTEST1: PRODTEST1::new(),
                PRODTEST2: PRODTEST2::new(),
                TEMP_A0: TEMP_A0::new(),
                TEMP_A1: TEMP_A1::new(),
                TEMP_A2: TEMP_A2::new(),
                TEMP_A3: TEMP_A3::new(),
                TEMP_A4: TEMP_A4::new(),
                TEMP_A5: TEMP_A5::new(),
                TEMP_B0: TEMP_B0::new(),
                TEMP_B1: TEMP_B1::new(),
                TEMP_B2: TEMP_B2::new(),
                TEMP_B3: TEMP_B3::new(),
                TEMP_B4: TEMP_B4::new(),
                TEMP_B5: TEMP_B5::new(),
                TEMP_T0: TEMP_T0::new(),
                TEMP_T1: TEMP_T1::new(),
                TEMP_T2: TEMP_T2::new(),
                TEMP_T3: TEMP_T3::new(),
                TEMP_T4: TEMP_T4::new(),
                NFC_TAGHEADER0: NFC_TAGHEADER0::new(),
                NFC_TAGHEADER1: NFC_TAGHEADER1::new(),
                NFC_TAGHEADER2: NFC_TAGHEADER2::new(),
                NFC_TAGHEADER3: NFC_TAGHEADER3::new(),
                TRNG90B_BYTES: TRNG90B_BYTES::new(),
                TRNG90B_RCCUTOFF: TRNG90B_RCCUTOFF::new(),
                TRNG90B_APCUTOFF: TRNG90B_APCUTOFF::new(),
                TRNG90B_STARTUP: TRNG90B_STARTUP::new(),
                TRNG90B_ROSC1: TRNG90B_ROSC1::new(),
                TRNG90B_ROSC2: TRNG90B_ROSC2::new(),
                TRNG90B_ROSC3: TRNG90B_ROSC3::new(),
                TRNG90B_ROSC4: TRNG90B_ROSC4::new(),
            }
        }
        fn taken() -> &'static AtomicBool {
            static TAKEN: AtomicBool = AtomicBool::new(false);
            &TAKEN
        }
        #[doc = r" Grants temporary access to the peripheral, without checking if it has already been"]
        #[doc = r" taken"]
        #[inline(always)]
        pub fn borrow_unchecked<T>(f: impl FnOnce(&Self) -> T) -> T {
            f(unsafe { &Self::new() })
        }
        #[doc = r" Seals the peripheral making it impossible to `take` it"]
        pub fn seal() {
            Self::taken().store(true, Ordering::Relaxed)
        }
        #[doc = r" Takes ownership of the peripheral"]
        #[doc = r""]
        #[doc = r" This constructor returns the `Some` variant only once"]
        pub fn take() -> Option<Self> {
            let taken = Self::taken();
            if taken
                .compare_exchange(false, true, Ordering::Relaxed, Ordering::Relaxed)
                .is_ok()
            {
                Some(unsafe { Self::new() })
            } else {
                None
            }
        }
    }
}
#[allow(non_camel_case_types)]
#[cfg(feature = "CLOCK")]
#[doc = "Clock control"]
pub type CLOCK = clock::Registers;
#[cfg(feature = "CLOCK")]
#[doc = "Clock control"]
pub mod clock {
    #[allow(non_camel_case_types)]
    #[doc = "Start HFXO crystal oscillator"]
    pub type TASKS_HFCLKSTART = tasks_hfclkstart::Register;
    #[doc = "Start HFXO crystal oscillator"]
    pub mod tasks_hfclkstart {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                super::BASE_ADDRESS as *mut _
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 0) Start HFXO crystal oscillator"]
            #[allow(non_snake_case)]
            pub fn TASKS_HFCLKSTART(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Stop HFXO crystal oscillator"]
    pub type TASKS_HFCLKSTOP = tasks_hfclkstop::Register;
    #[doc = "Stop HFXO crystal oscillator"]
    pub mod tasks_hfclkstop {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x04) as *mut _
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 0) Stop HFXO crystal oscillator"]
            #[allow(non_snake_case)]
            pub fn TASKS_HFCLKSTOP(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Start LFCLK"]
    pub type TASKS_LFCLKSTART = tasks_lfclkstart::Register;
    #[doc = "Start LFCLK"]
    pub mod tasks_lfclkstart {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x08) as *mut _
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 0) Start LFCLK"]
            #[allow(non_snake_case)]
            pub fn TASKS_LFCLKSTART(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Stop LFCLK"]
    pub type TASKS_LFCLKSTOP = tasks_lfclkstop::Register;
    #[doc = "Stop LFCLK"]
    pub mod tasks_lfclkstop {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0c) as *mut _
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 0) Stop LFCLK"]
            #[allow(non_snake_case)]
            pub fn TASKS_LFCLKSTOP(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Start calibration of LFRC"]
    pub type TASKS_CAL = tasks_cal::Register;
    #[doc = "Start calibration of LFRC"]
    pub mod tasks_cal {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x10) as *mut _
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 0) Start calibration of LFRC"]
            #[allow(non_snake_case)]
            pub fn TASKS_CAL(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Start calibration timer"]
    pub type TASKS_CTSTART = tasks_ctstart::Register;
    #[doc = "Start calibration timer"]
    pub mod tasks_ctstart {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x14) as *mut _
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 0) Start calibration timer"]
            #[allow(non_snake_case)]
            pub fn TASKS_CTSTART(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Stop calibration timer"]
    pub type TASKS_CTSTOP = tasks_ctstop::Register;
    #[doc = "Stop calibration timer"]
    pub mod tasks_ctstop {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x18) as *mut _
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 0) Stop calibration timer"]
            #[allow(non_snake_case)]
            pub fn TASKS_CTSTOP(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "HFXO crystal oscillator started"]
    pub type EVENTS_HFCLKSTARTED = events_hfclkstarted::Register;
    #[doc = "HFXO crystal oscillator started"]
    pub mod events_hfclkstarted {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0100) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bit 0) HFXO crystal oscillator started"]
            pub fn EVENTS_HFCLKSTARTED(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u8 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "EVENTS_HFCLKSTARTED {{ EVENTS_HFCLKSTARTED: {0} }}@3961820108191470058"]
                #[link_section = ".binfmt.EVENTS_HFCLKSTARTED {{ EVENTS_HFCLKSTARTED: {0} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 0) HFXO crystal oscillator started"]
            #[allow(non_snake_case)]
            pub fn EVENTS_HFCLKSTARTED(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "LFCLK started"]
    pub type EVENTS_LFCLKSTARTED = events_lfclkstarted::Register;
    #[doc = "LFCLK started"]
    pub mod events_lfclkstarted {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0104) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bit 0) LFCLK started"]
            pub fn EVENTS_LFCLKSTARTED(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u8 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "EVENTS_LFCLKSTARTED {{ EVENTS_LFCLKSTARTED: {0} }}@14413067322794107208"]
                #[link_section = ".binfmt.EVENTS_LFCLKSTARTED {{ EVENTS_LFCLKSTARTED: {0} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 0) LFCLK started"]
            #[allow(non_snake_case)]
            pub fn EVENTS_LFCLKSTARTED(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Calibration of LFRC completed"]
    pub type EVENTS_DONE = events_done::Register;
    #[doc = "Calibration of LFRC completed"]
    pub mod events_done {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x010c) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bit 0) Calibration of LFRC completed"]
            pub fn EVENTS_DONE(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u8 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "EVENTS_DONE {{ EVENTS_DONE: {0} }}@17815468397976754038"]
                #[link_section = ".binfmt.EVENTS_DONE {{ EVENTS_DONE: {0} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 0) Calibration of LFRC completed"]
            #[allow(non_snake_case)]
            pub fn EVENTS_DONE(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Calibration timer timeout"]
    pub type EVENTS_CTTO = events_ctto::Register;
    #[doc = "Calibration timer timeout"]
    pub mod events_ctto {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0110) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bit 0) Calibration timer timeout"]
            pub fn EVENTS_CTTO(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u8 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "EVENTS_CTTO {{ EVENTS_CTTO: {0} }}@12576160574651767056"]
                #[link_section = ".binfmt.EVENTS_CTTO {{ EVENTS_CTTO: {0} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 0) Calibration timer timeout"]
            #[allow(non_snake_case)]
            pub fn EVENTS_CTTO(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Calibration timer has been started and is ready to process new tasks"]
    pub type EVENTS_CTSTARTED = events_ctstarted::Register;
    #[doc = "Calibration timer has been started and is ready to process new tasks"]
    pub mod events_ctstarted {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0128) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bit 0) Calibration timer has been started and is ready to process new tasks"]
            pub fn EVENTS_CTSTARTED(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u8 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "EVENTS_CTSTARTED {{ EVENTS_CTSTARTED: {0} }}@8889682392825916520"]
                #[link_section = ".binfmt.EVENTS_CTSTARTED {{ EVENTS_CTSTARTED: {0} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 0) Calibration timer has been started and is ready to process new tasks"]
            #[allow(non_snake_case)]
            pub fn EVENTS_CTSTARTED(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Calibration timer has been stopped and is ready to process new tasks"]
    pub type EVENTS_CTSTOPPED = events_ctstopped::Register;
    #[doc = "Calibration timer has been stopped and is ready to process new tasks"]
    pub mod events_ctstopped {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x012c) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bit 0) Calibration timer has been stopped and is ready to process new tasks"]
            pub fn EVENTS_CTSTOPPED(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u8 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "EVENTS_CTSTOPPED {{ EVENTS_CTSTOPPED: {0} }}@9543422855335134699"]
                #[link_section = ".binfmt.EVENTS_CTSTOPPED {{ EVENTS_CTSTOPPED: {0} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 0) Calibration timer has been stopped and is ready to process new tasks"]
            #[allow(non_snake_case)]
            pub fn EVENTS_CTSTOPPED(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Enable interrupt"]
    pub type INTENSET = intenset::Register;
    #[doc = "Enable interrupt"]
    pub mod intenset {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0304) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub unsafe fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub unsafe fn zero(&self) {
                {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub unsafe fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bit 0) Write '1' to enable interrupt for event HFCLKSTARTED"]
            pub fn HFCLKSTARTED(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 1) Write '1' to enable interrupt for event LFCLKSTARTED"]
            pub fn LFCLKSTARTED(self) -> u8 {
                const OFFSET: u8 = 1;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 3) Write '1' to enable interrupt for event DONE"]
            pub fn DONE(self) -> u8 {
                const OFFSET: u8 = 3;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 4) Write '1' to enable interrupt for event CTTO"]
            pub fn CTTO(self) -> u8 {
                const OFFSET: u8 = 4;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 10) Write '1' to enable interrupt for event CTSTARTED"]
            pub fn CTSTARTED(self) -> u8 {
                const OFFSET: u8 = 10;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 11) Write '1' to enable interrupt for event CTSTOPPED"]
            pub fn CTSTOPPED(self) -> u8 {
                const OFFSET: u8 = 11;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u16 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "INTENSET {{ CTSTOPPED: {11}, CTSTARTED: {10}, CTTO: {4}, DONE: {3}, LFCLKSTARTED: {1}, HFCLKSTARTED: {0} }}@2108597630789336524"]
                #[link_section = ".binfmt.INTENSET {{ CTSTOPPED: {11}, CTSTARTED: {10}, CTTO: {4}, DONE: {3}, LFCLKSTARTED: {1}, HFCLKSTARTED: {0} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 0) Write '1' to enable interrupt for event HFCLKSTARTED"]
            #[allow(non_snake_case)]
            pub fn HFCLKSTARTED(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 1) Write '1' to enable interrupt for event LFCLKSTARTED"]
            #[allow(non_snake_case)]
            pub fn LFCLKSTARTED(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 1;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 3) Write '1' to enable interrupt for event DONE"]
            #[allow(non_snake_case)]
            pub fn DONE(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 3;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 4) Write '1' to enable interrupt for event CTTO"]
            #[allow(non_snake_case)]
            pub fn CTTO(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 4;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 10) Write '1' to enable interrupt for event CTSTARTED"]
            #[allow(non_snake_case)]
            pub fn CTSTARTED(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 10;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 11) Write '1' to enable interrupt for event CTSTOPPED"]
            #[allow(non_snake_case)]
            pub fn CTSTOPPED(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 11;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Disable interrupt"]
    pub type INTENCLR = intenclr::Register;
    #[doc = "Disable interrupt"]
    pub mod intenclr {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0308) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bit 0) Write '1' to disable interrupt for event HFCLKSTARTED"]
            pub fn HFCLKSTARTED(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 1) Write '1' to disable interrupt for event LFCLKSTARTED"]
            pub fn LFCLKSTARTED(self) -> u8 {
                const OFFSET: u8 = 1;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 3) Write '1' to disable interrupt for event DONE"]
            pub fn DONE(self) -> u8 {
                const OFFSET: u8 = 3;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 4) Write '1' to disable interrupt for event CTTO"]
            pub fn CTTO(self) -> u8 {
                const OFFSET: u8 = 4;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 10) Write '1' to disable interrupt for event CTSTARTED"]
            pub fn CTSTARTED(self) -> u8 {
                const OFFSET: u8 = 10;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 11) Write '1' to disable interrupt for event CTSTOPPED"]
            pub fn CTSTOPPED(self) -> u8 {
                const OFFSET: u8 = 11;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u16 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "INTENCLR {{ CTSTOPPED: {11}, CTSTARTED: {10}, CTTO: {4}, DONE: {3}, LFCLKSTARTED: {1}, HFCLKSTARTED: {0} }}@13996808859275466497"]
                #[link_section = ".binfmt.INTENCLR {{ CTSTOPPED: {11}, CTSTARTED: {10}, CTTO: {4}, DONE: {3}, LFCLKSTARTED: {1}, HFCLKSTARTED: {0} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 0) Write '1' to disable interrupt for event HFCLKSTARTED"]
            #[allow(non_snake_case)]
            pub fn HFCLKSTARTED(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 1) Write '1' to disable interrupt for event LFCLKSTARTED"]
            #[allow(non_snake_case)]
            pub fn LFCLKSTARTED(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 1;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 3) Write '1' to disable interrupt for event DONE"]
            #[allow(non_snake_case)]
            pub fn DONE(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 3;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 4) Write '1' to disable interrupt for event CTTO"]
            #[allow(non_snake_case)]
            pub fn CTTO(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 4;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 10) Write '1' to disable interrupt for event CTSTARTED"]
            #[allow(non_snake_case)]
            pub fn CTSTARTED(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 10;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 11) Write '1' to disable interrupt for event CTSTOPPED"]
            #[allow(non_snake_case)]
            pub fn CTSTOPPED(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 11;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Status indicating that HFCLKSTART task has been triggered"]
    pub type HFCLKRUN = hfclkrun::Register;
    #[doc = "Status indicating that HFCLKSTART task has been triggered"]
    pub mod hfclkrun {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *const u32 {
                (super::BASE_ADDRESS + 0x0408) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bit 0) HFCLKSTART task triggered or not"]
            pub fn STATUS(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u8 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "HFCLKRUN {{ STATUS: {0} }}@4535285320077664553"]
                #[link_section = ".binfmt.HFCLKRUN {{ STATUS: {0} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "HFCLK status"]
    pub type HFCLKSTAT = hfclkstat::Register;
    #[doc = "HFCLK status"]
    pub mod hfclkstat {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *const u32 {
                (super::BASE_ADDRESS + 0x040c) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bit 0) Source of HFCLK"]
            pub fn SRC(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 16) HFCLK state"]
            pub fn STATE(self) -> u8 {
                const OFFSET: u8 = 16;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u32 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "HFCLKSTAT {{ STATE: {16}, SRC: {0} }}@18135948471098513080"]
                #[link_section = ".binfmt.HFCLKSTAT {{ STATE: {16}, SRC: {0} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Status indicating that LFCLKSTART task has been triggered"]
    pub type LFCLKRUN = lfclkrun::Register;
    #[doc = "Status indicating that LFCLKSTART task has been triggered"]
    pub mod lfclkrun {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *const u32 {
                (super::BASE_ADDRESS + 0x0414) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bit 0) LFCLKSTART task triggered or not"]
            pub fn STATUS(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u8 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "LFCLKRUN {{ STATUS: {0} }}@6067224501743398910"]
                #[link_section = ".binfmt.LFCLKRUN {{ STATUS: {0} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "LFCLK status"]
    pub type LFCLKSTAT = lfclkstat::Register;
    #[doc = "LFCLK status"]
    pub mod lfclkstat {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *const u32 {
                (super::BASE_ADDRESS + 0x0418) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bits 0..=2) Source of LFCLK"]
            pub fn SRC(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x03;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 16) LFCLK state"]
            pub fn STATE(self) -> u8 {
                const OFFSET: u8 = 16;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u32 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "LFCLKSTAT {{ STATE: {16}, SRC: {0:2} }}@17418213482598983905"]
                #[link_section = ".binfmt.LFCLKSTAT {{ STATE: {16}, SRC: {0:2} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Copy of LFCLKSRC register, set when LFCLKSTART task was triggered"]
    pub type LFCLKSRCCOPY = lfclksrccopy::Register;
    #[doc = "Copy of LFCLKSRC register, set when LFCLKSTART task was triggered"]
    pub mod lfclksrccopy {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *const u32 {
                (super::BASE_ADDRESS + 0x041c) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bits 0..=2) Clock source"]
            pub fn SRC(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x03;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u8 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "LFCLKSRCCOPY {{ SRC: {0:2} }}@7094351279365793014"]
                #[link_section = ".binfmt.LFCLKSRCCOPY {{ SRC: {0:2} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Clock source for the LFCLK"]
    pub type LFCLKSRC = lfclksrc::Register;
    #[doc = "Clock source for the LFCLK"]
    pub mod lfclksrc {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0518) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bits 0..=2) Clock source"]
            pub fn SRC(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x03;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 16) Enable or disable bypass of LFCLK crystal oscillator with external clock source"]
            pub fn BYPASS(self) -> u8 {
                const OFFSET: u8 = 16;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 17) Enable or disable external source for LFCLK"]
            pub fn EXTERNAL(self) -> u8 {
                const OFFSET: u8 = 17;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u32 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "LFCLKSRC {{ EXTERNAL: {17}, BYPASS: {16}, SRC: {0:2} }}@17529990596388135465"]
                #[link_section = ".binfmt.LFCLKSRC {{ EXTERNAL: {17}, BYPASS: {16}, SRC: {0:2} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bits 0..=2) Clock source"]
            #[allow(non_snake_case)]
            pub fn SRC(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x03;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 16) Enable or disable bypass of LFCLK crystal oscillator with external clock source"]
            #[allow(non_snake_case)]
            pub fn BYPASS(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 16;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 17) Enable or disable external source for LFCLK"]
            #[allow(non_snake_case)]
            pub fn EXTERNAL(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 17;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "HFXO debounce time. The HFXO is started by triggering the TASKS_HFCLKSTART task."]
    pub type HFXODEBOUNCE = hfxodebounce::Register;
    #[doc = "HFXO debounce time. The HFXO is started by triggering the TASKS_HFCLKSTART task."]
    pub mod hfxodebounce {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0528) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bits 0..=8) HFXO debounce time. Debounce time = HFXODEBOUNCE * 16 us."]
            pub fn HFXODEBOUNCE(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0xff;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u8 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "HFXODEBOUNCE {{ HFXODEBOUNCE: {0:8} }}@16428197835567811355"]
                #[link_section = ".binfmt.HFXODEBOUNCE {{ HFXODEBOUNCE: {0:8} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bits 0..=8) HFXO debounce time. Debounce time = HFXODEBOUNCE * 16 us."]
            #[allow(non_snake_case)]
            pub fn HFXODEBOUNCE(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0xff;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Calibration timer interval"]
    pub type CTIV = ctiv::Register;
    #[doc = "Calibration timer interval"]
    pub mod ctiv {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0538) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bits 0..=7) Calibration timer interval in multiple of 0.25 seconds. Range: 0.25 seconds to 31.75 seconds."]
            pub fn CTIV(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x7f;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u8 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "CTIV {{ CTIV: {0:7} }}@15888389694065372888"]
                #[link_section = ".binfmt.CTIV {{ CTIV: {0:7} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bits 0..=7) Calibration timer interval in multiple of 0.25 seconds. Range: 0.25 seconds to 31.75 seconds."]
            #[allow(non_snake_case)]
            pub fn CTIV(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x7f;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Clocking options for the trace port debug interface"]
    pub type TRACECONFIG = traceconfig::Register;
    #[doc = "Clocking options for the trace port debug interface"]
    pub mod traceconfig {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x055c) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bits 0..=2) Speed of trace port clock. Note that the TRACECLK pin will output this clock divided by two."]
            pub fn TRACEPORTSPEED(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x03;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bits 16..=18) Pin multiplexing of trace signals. See pin assignment chapter for more details."]
            pub fn TRACEMUX(self) -> u8 {
                const OFFSET: u8 = 16;
                const MASK: u8 = 0x03;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u32 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "TRACECONFIG {{ TRACEMUX: {16:18}, TRACEPORTSPEED: {0:2} }}@1780589352896227896"]
                #[link_section = ".binfmt.TRACECONFIG {{ TRACEMUX: {16:18}, TRACEPORTSPEED: {0:2} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bits 0..=2) Speed of trace port clock. Note that the TRACECLK pin will output this clock divided by two."]
            #[allow(non_snake_case)]
            pub fn TRACEPORTSPEED(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x03;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bits 16..=18) Pin multiplexing of trace signals. See pin assignment chapter for more details."]
            #[allow(non_snake_case)]
            pub fn TRACEMUX(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 16;
                const MASK: u8 = 0x03;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "LFRC mode configuration"]
    pub type LFRCMODE = lfrcmode::Register;
    #[doc = "LFRC mode configuration"]
    pub mod lfrcmode {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x05b4) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bit 0) Set LFRC mode"]
            pub fn MODE(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 16) Active LFRC mode. This field is read only."]
            pub fn STATUS(self) -> u8 {
                const OFFSET: u8 = 16;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u32 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "LFRCMODE {{ STATUS: {16}, MODE: {0} }}@15563814999256828405"]
                #[link_section = ".binfmt.LFRCMODE {{ STATUS: {16}, MODE: {0} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 0) Set LFRC mode"]
            #[allow(non_snake_case)]
            pub fn MODE(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 16) Active LFRC mode. This field is read only."]
            #[allow(non_snake_case)]
            pub fn STATUS(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 16;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    use core::sync::atomic::{AtomicBool, Ordering};
    const BASE_ADDRESS: usize = 0x4000_0000;
    #[allow(non_snake_case)]
    #[doc = "Singleton handle to the CLOCK registers"]
    pub struct Registers {
        #[doc = "Start HFXO crystal oscillator"]
        pub TASKS_HFCLKSTART: TASKS_HFCLKSTART,
        #[doc = "Stop HFXO crystal oscillator"]
        pub TASKS_HFCLKSTOP: TASKS_HFCLKSTOP,
        #[doc = "Start LFCLK"]
        pub TASKS_LFCLKSTART: TASKS_LFCLKSTART,
        #[doc = "Stop LFCLK"]
        pub TASKS_LFCLKSTOP: TASKS_LFCLKSTOP,
        #[doc = "Start calibration of LFRC"]
        pub TASKS_CAL: TASKS_CAL,
        #[doc = "Start calibration timer"]
        pub TASKS_CTSTART: TASKS_CTSTART,
        #[doc = "Stop calibration timer"]
        pub TASKS_CTSTOP: TASKS_CTSTOP,
        #[doc = "HFXO crystal oscillator started"]
        pub EVENTS_HFCLKSTARTED: EVENTS_HFCLKSTARTED,
        #[doc = "LFCLK started"]
        pub EVENTS_LFCLKSTARTED: EVENTS_LFCLKSTARTED,
        #[doc = "Calibration of LFRC completed"]
        pub EVENTS_DONE: EVENTS_DONE,
        #[doc = "Calibration timer timeout"]
        pub EVENTS_CTTO: EVENTS_CTTO,
        #[doc = "Calibration timer has been started and is ready to process new tasks"]
        pub EVENTS_CTSTARTED: EVENTS_CTSTARTED,
        #[doc = "Calibration timer has been stopped and is ready to process new tasks"]
        pub EVENTS_CTSTOPPED: EVENTS_CTSTOPPED,
        #[doc = "Enable interrupt"]
        pub INTENSET: INTENSET,
        #[doc = "Disable interrupt"]
        pub INTENCLR: INTENCLR,
        #[doc = "Status indicating that HFCLKSTART task has been triggered"]
        pub HFCLKRUN: HFCLKRUN,
        #[doc = "HFCLK status"]
        pub HFCLKSTAT: HFCLKSTAT,
        #[doc = "Status indicating that LFCLKSTART task has been triggered"]
        pub LFCLKRUN: LFCLKRUN,
        #[doc = "LFCLK status"]
        pub LFCLKSTAT: LFCLKSTAT,
        #[doc = "Copy of LFCLKSRC register, set when LFCLKSTART task was triggered"]
        pub LFCLKSRCCOPY: LFCLKSRCCOPY,
        #[doc = "Clock source for the LFCLK"]
        pub LFCLKSRC: LFCLKSRC,
        #[doc = "HFXO debounce time. The HFXO is started by triggering the TASKS_HFCLKSTART task."]
        pub HFXODEBOUNCE: HFXODEBOUNCE,
        #[doc = "Calibration timer interval"]
        pub CTIV: CTIV,
        #[doc = "Clocking options for the trace port debug interface"]
        pub TRACECONFIG: TRACECONFIG,
        #[doc = "LFRC mode configuration"]
        pub LFRCMODE: LFRCMODE,
    }
    unsafe impl Send for Registers {}
    impl Registers {
        #[doc = r" # Safety"]
        #[doc = r" Singleton"]
        unsafe fn new() -> Self {
            Self {
                TASKS_HFCLKSTART: TASKS_HFCLKSTART::new(),
                TASKS_HFCLKSTOP: TASKS_HFCLKSTOP::new(),
                TASKS_LFCLKSTART: TASKS_LFCLKSTART::new(),
                TASKS_LFCLKSTOP: TASKS_LFCLKSTOP::new(),
                TASKS_CAL: TASKS_CAL::new(),
                TASKS_CTSTART: TASKS_CTSTART::new(),
                TASKS_CTSTOP: TASKS_CTSTOP::new(),
                EVENTS_HFCLKSTARTED: EVENTS_HFCLKSTARTED::new(),
                EVENTS_LFCLKSTARTED: EVENTS_LFCLKSTARTED::new(),
                EVENTS_DONE: EVENTS_DONE::new(),
                EVENTS_CTTO: EVENTS_CTTO::new(),
                EVENTS_CTSTARTED: EVENTS_CTSTARTED::new(),
                EVENTS_CTSTOPPED: EVENTS_CTSTOPPED::new(),
                INTENSET: INTENSET::new(),
                INTENCLR: INTENCLR::new(),
                HFCLKRUN: HFCLKRUN::new(),
                HFCLKSTAT: HFCLKSTAT::new(),
                LFCLKRUN: LFCLKRUN::new(),
                LFCLKSTAT: LFCLKSTAT::new(),
                LFCLKSRCCOPY: LFCLKSRCCOPY::new(),
                LFCLKSRC: LFCLKSRC::new(),
                HFXODEBOUNCE: HFXODEBOUNCE::new(),
                CTIV: CTIV::new(),
                TRACECONFIG: TRACECONFIG::new(),
                LFRCMODE: LFRCMODE::new(),
            }
        }
        fn taken() -> &'static AtomicBool {
            static TAKEN: AtomicBool = AtomicBool::new(false);
            &TAKEN
        }
        #[doc = r" Grants temporary access to the peripheral, without checking if it has already been"]
        #[doc = r" taken"]
        #[inline(always)]
        pub fn borrow_unchecked<T>(f: impl FnOnce(&Self) -> T) -> T {
            f(unsafe { &Self::new() })
        }
        #[doc = r" Seals the peripheral making it impossible to `take` it"]
        pub fn seal() {
            Self::taken().store(true, Ordering::Relaxed)
        }
        #[doc = r" Takes ownership of the peripheral"]
        #[doc = r""]
        #[doc = r" This constructor returns the `Some` variant only once"]
        pub fn take() -> Option<Self> {
            let taken = Self::taken();
            if taken
                .compare_exchange(false, true, Ordering::Relaxed, Ordering::Relaxed)
                .is_ok()
            {
                Some(unsafe { Self::new() })
            } else {
                None
            }
        }
    }
}
#[allow(non_camel_case_types)]
#[cfg(feature = "POWER")]
#[doc = "Power control"]
pub type POWER = power::Registers;
#[cfg(feature = "POWER")]
#[doc = "Power control"]
pub mod power {
    #[allow(non_camel_case_types)]
    #[doc = "Enable Constant Latency mode"]
    pub type TASKS_CONSTLAT = tasks_constlat::Register;
    #[doc = "Enable Constant Latency mode"]
    pub mod tasks_constlat {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x78) as *mut _
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 0) Enable Constant Latency mode"]
            #[allow(non_snake_case)]
            pub fn TASKS_CONSTLAT(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Enable Low-power mode (variable latency)"]
    pub type TASKS_LOWPWR = tasks_lowpwr::Register;
    #[doc = "Enable Low-power mode (variable latency)"]
    pub mod tasks_lowpwr {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x7c) as *mut _
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 0) Enable Low-power mode (variable latency)"]
            #[allow(non_snake_case)]
            pub fn TASKS_LOWPWR(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Power failure warning"]
    pub type EVENTS_POFWARN = events_pofwarn::Register;
    #[doc = "Power failure warning"]
    pub mod events_pofwarn {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0108) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bit 0) Power failure warning"]
            pub fn EVENTS_POFWARN(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u8 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "EVENTS_POFWARN {{ EVENTS_POFWARN: {0} }}@13342770080875650730"]
                #[link_section = ".binfmt.EVENTS_POFWARN {{ EVENTS_POFWARN: {0} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 0) Power failure warning"]
            #[allow(non_snake_case)]
            pub fn EVENTS_POFWARN(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "CPU entered WFI/WFE sleep"]
    pub type EVENTS_SLEEPENTER = events_sleepenter::Register;
    #[doc = "CPU entered WFI/WFE sleep"]
    pub mod events_sleepenter {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0114) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bit 0) CPU entered WFI/WFE sleep"]
            pub fn EVENTS_SLEEPENTER(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u8 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "EVENTS_SLEEPENTER {{ EVENTS_SLEEPENTER: {0} }}@12696707014790605379"]
                #[link_section = ".binfmt.EVENTS_SLEEPENTER {{ EVENTS_SLEEPENTER: {0} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 0) CPU entered WFI/WFE sleep"]
            #[allow(non_snake_case)]
            pub fn EVENTS_SLEEPENTER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "CPU exited WFI/WFE sleep"]
    pub type EVENTS_SLEEPEXIT = events_sleepexit::Register;
    #[doc = "CPU exited WFI/WFE sleep"]
    pub mod events_sleepexit {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0118) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bit 0) CPU exited WFI/WFE sleep"]
            pub fn EVENTS_SLEEPEXIT(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u8 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "EVENTS_SLEEPEXIT {{ EVENTS_SLEEPEXIT: {0} }}@3708254516134126496"]
                #[link_section = ".binfmt.EVENTS_SLEEPEXIT {{ EVENTS_SLEEPEXIT: {0} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 0) CPU exited WFI/WFE sleep"]
            #[allow(non_snake_case)]
            pub fn EVENTS_SLEEPEXIT(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Voltage supply detected on VBUS"]
    pub type EVENTS_USBDETECTED = events_usbdetected::Register;
    #[doc = "Voltage supply detected on VBUS"]
    pub mod events_usbdetected {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x011c) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bit 0) Voltage supply detected on VBUS"]
            pub fn EVENTS_USBDETECTED(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u8 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "EVENTS_USBDETECTED {{ EVENTS_USBDETECTED: {0} }}@18090065503120733706"]
                #[link_section = ".binfmt.EVENTS_USBDETECTED {{ EVENTS_USBDETECTED: {0} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 0) Voltage supply detected on VBUS"]
            #[allow(non_snake_case)]
            pub fn EVENTS_USBDETECTED(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Voltage supply removed from VBUS"]
    pub type EVENTS_USBREMOVED = events_usbremoved::Register;
    #[doc = "Voltage supply removed from VBUS"]
    pub mod events_usbremoved {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0120) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bit 0) Voltage supply removed from VBUS"]
            pub fn EVENTS_USBREMOVED(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u8 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "EVENTS_USBREMOVED {{ EVENTS_USBREMOVED: {0} }}@16536931359070329560"]
                #[link_section = ".binfmt.EVENTS_USBREMOVED {{ EVENTS_USBREMOVED: {0} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 0) Voltage supply removed from VBUS"]
            #[allow(non_snake_case)]
            pub fn EVENTS_USBREMOVED(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "USB 3.3 V supply ready"]
    pub type EVENTS_USBPWRRDY = events_usbpwrrdy::Register;
    #[doc = "USB 3.3 V supply ready"]
    pub mod events_usbpwrrdy {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0124) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bit 0) USB 3.3 V supply ready"]
            pub fn EVENTS_USBPWRRDY(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u8 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "EVENTS_USBPWRRDY {{ EVENTS_USBPWRRDY: {0} }}@15305954071856103095"]
                #[link_section = ".binfmt.EVENTS_USBPWRRDY {{ EVENTS_USBPWRRDY: {0} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 0) USB 3.3 V supply ready"]
            #[allow(non_snake_case)]
            pub fn EVENTS_USBPWRRDY(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Enable interrupt"]
    pub type INTENSET = intenset::Register;
    #[doc = "Enable interrupt"]
    pub mod intenset {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0304) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub unsafe fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub unsafe fn zero(&self) {
                {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub unsafe fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bit 2) Write '1' to enable interrupt for event POFWARN"]
            pub fn POFWARN(self) -> u8 {
                const OFFSET: u8 = 2;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 5) Write '1' to enable interrupt for event SLEEPENTER"]
            pub fn SLEEPENTER(self) -> u8 {
                const OFFSET: u8 = 5;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 6) Write '1' to enable interrupt for event SLEEPEXIT"]
            pub fn SLEEPEXIT(self) -> u8 {
                const OFFSET: u8 = 6;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 7) Write '1' to enable interrupt for event USBDETECTED"]
            pub fn USBDETECTED(self) -> u8 {
                const OFFSET: u8 = 7;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 8) Write '1' to enable interrupt for event USBREMOVED"]
            pub fn USBREMOVED(self) -> u8 {
                const OFFSET: u8 = 8;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 9) Write '1' to enable interrupt for event USBPWRRDY"]
            pub fn USBPWRRDY(self) -> u8 {
                const OFFSET: u8 = 9;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u16 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "INTENSET {{ USBPWRRDY: {9}, USBREMOVED: {8}, USBDETECTED: {7}, SLEEPEXIT: {6}, SLEEPENTER: {5}, POFWARN: {2} }}@11400777324203892013"]
                #[link_section = ".binfmt.INTENSET {{ USBPWRRDY: {9}, USBREMOVED: {8}, USBDETECTED: {7}, SLEEPEXIT: {6}, SLEEPENTER: {5}, POFWARN: {2} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 2) Write '1' to enable interrupt for event POFWARN"]
            #[allow(non_snake_case)]
            pub fn POFWARN(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 2;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 5) Write '1' to enable interrupt for event SLEEPENTER"]
            #[allow(non_snake_case)]
            pub fn SLEEPENTER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 5;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 6) Write '1' to enable interrupt for event SLEEPEXIT"]
            #[allow(non_snake_case)]
            pub fn SLEEPEXIT(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 6;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 7) Write '1' to enable interrupt for event USBDETECTED"]
            #[allow(non_snake_case)]
            pub fn USBDETECTED(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 7;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 8) Write '1' to enable interrupt for event USBREMOVED"]
            #[allow(non_snake_case)]
            pub fn USBREMOVED(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 8;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 9) Write '1' to enable interrupt for event USBPWRRDY"]
            #[allow(non_snake_case)]
            pub fn USBPWRRDY(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 9;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Disable interrupt"]
    pub type INTENCLR = intenclr::Register;
    #[doc = "Disable interrupt"]
    pub mod intenclr {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0308) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bit 2) Write '1' to disable interrupt for event POFWARN"]
            pub fn POFWARN(self) -> u8 {
                const OFFSET: u8 = 2;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 5) Write '1' to disable interrupt for event SLEEPENTER"]
            pub fn SLEEPENTER(self) -> u8 {
                const OFFSET: u8 = 5;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 6) Write '1' to disable interrupt for event SLEEPEXIT"]
            pub fn SLEEPEXIT(self) -> u8 {
                const OFFSET: u8 = 6;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 7) Write '1' to disable interrupt for event USBDETECTED"]
            pub fn USBDETECTED(self) -> u8 {
                const OFFSET: u8 = 7;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 8) Write '1' to disable interrupt for event USBREMOVED"]
            pub fn USBREMOVED(self) -> u8 {
                const OFFSET: u8 = 8;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 9) Write '1' to disable interrupt for event USBPWRRDY"]
            pub fn USBPWRRDY(self) -> u8 {
                const OFFSET: u8 = 9;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u16 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "INTENCLR {{ USBPWRRDY: {9}, USBREMOVED: {8}, USBDETECTED: {7}, SLEEPEXIT: {6}, SLEEPENTER: {5}, POFWARN: {2} }}@2818721386691805029"]
                #[link_section = ".binfmt.INTENCLR {{ USBPWRRDY: {9}, USBREMOVED: {8}, USBDETECTED: {7}, SLEEPEXIT: {6}, SLEEPENTER: {5}, POFWARN: {2} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 2) Write '1' to disable interrupt for event POFWARN"]
            #[allow(non_snake_case)]
            pub fn POFWARN(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 2;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 5) Write '1' to disable interrupt for event SLEEPENTER"]
            #[allow(non_snake_case)]
            pub fn SLEEPENTER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 5;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 6) Write '1' to disable interrupt for event SLEEPEXIT"]
            #[allow(non_snake_case)]
            pub fn SLEEPEXIT(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 6;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 7) Write '1' to disable interrupt for event USBDETECTED"]
            #[allow(non_snake_case)]
            pub fn USBDETECTED(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 7;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 8) Write '1' to disable interrupt for event USBREMOVED"]
            #[allow(non_snake_case)]
            pub fn USBREMOVED(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 8;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 9) Write '1' to disable interrupt for event USBPWRRDY"]
            #[allow(non_snake_case)]
            pub fn USBPWRRDY(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 9;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Reset reason"]
    pub type RESETREAS = resetreas::Register;
    #[doc = "Reset reason"]
    pub mod resetreas {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0400) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bit 0) Reset from pin-reset detected"]
            pub fn RESETPIN(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 1) Reset from watchdog detected"]
            pub fn DOG(self) -> u8 {
                const OFFSET: u8 = 1;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 2) Reset from soft reset detected"]
            pub fn SREQ(self) -> u8 {
                const OFFSET: u8 = 2;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 3) Reset from CPU lock-up detected"]
            pub fn LOCKUP(self) -> u8 {
                const OFFSET: u8 = 3;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 16) Reset due to wake up from System OFF mode when wakeup is triggered from DETECT signal from GPIO"]
            pub fn OFF(self) -> u8 {
                const OFFSET: u8 = 16;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 17) Reset due to wake up from System OFF mode when wakeup is triggered from ANADETECT signal from LPCOMP"]
            pub fn LPCOMP(self) -> u8 {
                const OFFSET: u8 = 17;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 18) Reset due to wake up from System OFF mode when wakeup is triggered from entering into debug interface mode"]
            pub fn DIF(self) -> u8 {
                const OFFSET: u8 = 18;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 19) Reset due to wake up from System OFF mode by NFC field detect"]
            pub fn NFC(self) -> u8 {
                const OFFSET: u8 = 19;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 20) Reset due to wake up from System OFF mode by VBUS rising into valid range"]
            pub fn VBUS(self) -> u8 {
                const OFFSET: u8 = 20;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u32 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "RESETREAS {{ VBUS: {20}, NFC: {19}, DIF: {18}, LPCOMP: {17}, OFF: {16}, LOCKUP: {3}, SREQ: {2}, DOG: {1}, RESETPIN: {0} }}@9978235554413233361"]
                #[link_section = ".binfmt.RESETREAS {{ VBUS: {20}, NFC: {19}, DIF: {18}, LPCOMP: {17}, OFF: {16}, LOCKUP: {3}, SREQ: {2}, DOG: {1}, RESETPIN: {0} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 0) Reset from pin-reset detected"]
            #[allow(non_snake_case)]
            pub fn RESETPIN(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 1) Reset from watchdog detected"]
            #[allow(non_snake_case)]
            pub fn DOG(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 1;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 2) Reset from soft reset detected"]
            #[allow(non_snake_case)]
            pub fn SREQ(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 2;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 3) Reset from CPU lock-up detected"]
            #[allow(non_snake_case)]
            pub fn LOCKUP(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 3;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 16) Reset due to wake up from System OFF mode when wakeup is triggered from DETECT signal from GPIO"]
            #[allow(non_snake_case)]
            pub fn OFF(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 16;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 17) Reset due to wake up from System OFF mode when wakeup is triggered from ANADETECT signal from LPCOMP"]
            #[allow(non_snake_case)]
            pub fn LPCOMP(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 17;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 18) Reset due to wake up from System OFF mode when wakeup is triggered from entering into debug interface mode"]
            #[allow(non_snake_case)]
            pub fn DIF(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 18;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 19) Reset due to wake up from System OFF mode by NFC field detect"]
            #[allow(non_snake_case)]
            pub fn NFC(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 19;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 20) Reset due to wake up from System OFF mode by VBUS rising into valid range"]
            #[allow(non_snake_case)]
            pub fn VBUS(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 20;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Deprecated register - RAM status register"]
    pub type RAMSTATUS = ramstatus::Register;
    #[doc = "Deprecated register - RAM status register"]
    pub mod ramstatus {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *const u32 {
                (super::BASE_ADDRESS + 0x0428) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bit 0) RAM block 0 is on or off/powering up"]
            pub fn RAMBLOCK0(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 1) RAM block 1 is on or off/powering up"]
            pub fn RAMBLOCK1(self) -> u8 {
                const OFFSET: u8 = 1;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 2) RAM block 2 is on or off/powering up"]
            pub fn RAMBLOCK2(self) -> u8 {
                const OFFSET: u8 = 2;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 3) RAM block 3 is on or off/powering up"]
            pub fn RAMBLOCK3(self) -> u8 {
                const OFFSET: u8 = 3;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u8 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "RAMSTATUS {{ RAMBLOCK3: {3}, RAMBLOCK2: {2}, RAMBLOCK1: {1}, RAMBLOCK0: {0} }}@11450007037095584483"]
                #[link_section = ".binfmt.RAMSTATUS {{ RAMBLOCK3: {3}, RAMBLOCK2: {2}, RAMBLOCK1: {1}, RAMBLOCK0: {0} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "USB supply status"]
    pub type USBREGSTATUS = usbregstatus::Register;
    #[doc = "USB supply status"]
    pub mod usbregstatus {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *const u32 {
                (super::BASE_ADDRESS + 0x0438) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bit 0) VBUS input detection status (USBDETECTED and USBREMOVED events are derived from this information)"]
            pub fn VBUSDETECT(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 1) USB supply output settling time elapsed"]
            pub fn OUTPUTRDY(self) -> u8 {
                const OFFSET: u8 = 1;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u8 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "USBREGSTATUS {{ OUTPUTRDY: {1}, VBUSDETECT: {0} }}@13395214547558242429"]
                #[link_section = ".binfmt.USBREGSTATUS {{ OUTPUTRDY: {1}, VBUSDETECT: {0} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "System OFF register"]
    pub type SYSTEMOFF = systemoff::Register;
    #[doc = "System OFF register"]
    pub mod systemoff {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0500) as *mut _
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 0) Enable System OFF mode"]
            #[allow(non_snake_case)]
            pub fn SYSTEMOFF(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Power-fail comparator configuration"]
    pub type POFCON = pofcon::Register;
    #[doc = "Power-fail comparator configuration"]
    pub mod pofcon {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0510) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bit 0) Enable or disable power failure warning"]
            pub fn POF(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bits 1..=5) Power-fail comparator threshold setting. This setting applies both for normal voltage mode (supply connected to both VDD and VDDH) and high voltage mode (supply connected to VDDH only). Values 0-3 set threshold below 1.7 V and should not be used as brown out detection will be activated before power failure warning on such low voltages."]
            pub fn THRESHOLD(self) -> u8 {
                const OFFSET: u8 = 1;
                const MASK: u8 = 0x0f;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bits 8..=12) Power-fail comparator threshold setting for high voltage mode (supply connected to VDDH only). This setting does not apply for normal voltage mode (supply connected to both VDD and VDDH)."]
            pub fn THRESHOLDVDDH(self) -> u8 {
                const OFFSET: u8 = 8;
                const MASK: u8 = 0x0f;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u16 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "POFCON {{ THRESHOLDVDDH: {8:12}, THRESHOLD: {1:5}, POF: {0} }}@3138414832500648013"]
                #[link_section = ".binfmt.POFCON {{ THRESHOLDVDDH: {8:12}, THRESHOLD: {1:5}, POF: {0} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 0) Enable or disable power failure warning"]
            #[allow(non_snake_case)]
            pub fn POF(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bits 1..=5) Power-fail comparator threshold setting. This setting applies both for normal voltage mode (supply connected to both VDD and VDDH) and high voltage mode (supply connected to VDDH only). Values 0-3 set threshold below 1.7 V and should not be used as brown out detection will be activated before power failure warning on such low voltages."]
            #[allow(non_snake_case)]
            pub fn THRESHOLD(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 1;
                const MASK: u8 = 0x0f;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bits 8..=12) Power-fail comparator threshold setting for high voltage mode (supply connected to VDDH only). This setting does not apply for normal voltage mode (supply connected to both VDD and VDDH)."]
            #[allow(non_snake_case)]
            pub fn THRESHOLDVDDH(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 8;
                const MASK: u8 = 0x0f;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "General purpose retention register"]
    pub type GPREGRET = gpregret::Register;
    #[doc = "General purpose retention register"]
    pub mod gpregret {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x051c) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bits 0..=8) General purpose retention register"]
            pub fn GPREGRET(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0xff;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u8 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "GPREGRET {{ GPREGRET: {0:8} }}@10497348835414446037"]
                #[link_section = ".binfmt.GPREGRET {{ GPREGRET: {0:8} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bits 0..=8) General purpose retention register"]
            #[allow(non_snake_case)]
            pub fn GPREGRET(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0xff;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "General purpose retention register"]
    pub type GPREGRET2 = gpregret2::Register;
    #[doc = "General purpose retention register"]
    pub mod gpregret2 {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0520) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bits 0..=8) General purpose retention register"]
            pub fn GPREGRET(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0xff;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u8 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "GPREGRET2 {{ GPREGRET: {0:8} }}@8185497060436117406"]
                #[link_section = ".binfmt.GPREGRET2 {{ GPREGRET: {0:8} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bits 0..=8) General purpose retention register"]
            #[allow(non_snake_case)]
            pub fn GPREGRET(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0xff;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Enable DC/DC converter for REG1 stage"]
    pub type DCDCEN = dcdcen::Register;
    #[doc = "Enable DC/DC converter for REG1 stage"]
    pub mod dcdcen {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0578) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bit 0) Enable DC/DC converter for REG1 stage."]
            pub fn DCDCEN(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u8 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "DCDCEN {{ DCDCEN: {0} }}@8856142951146934388"]
                #[link_section = ".binfmt.DCDCEN {{ DCDCEN: {0} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 0) Enable DC/DC converter for REG1 stage."]
            #[allow(non_snake_case)]
            pub fn DCDCEN(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Enable DC/DC converter for REG0 stage"]
    pub type DCDCEN0 = dcdcen0::Register;
    #[doc = "Enable DC/DC converter for REG0 stage"]
    pub mod dcdcen0 {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0580) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bit 0) Enable DC/DC converter for REG0 stage."]
            pub fn DCDCEN(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u8 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "DCDCEN0 {{ DCDCEN: {0} }}@11473766662529245090"]
                #[link_section = ".binfmt.DCDCEN0 {{ DCDCEN: {0} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 0) Enable DC/DC converter for REG0 stage."]
            #[allow(non_snake_case)]
            pub fn DCDCEN(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Main supply status"]
    pub type MAINREGSTATUS = mainregstatus::Register;
    #[doc = "Main supply status"]
    pub mod mainregstatus {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *const u32 {
                (super::BASE_ADDRESS + 0x0640) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bit 0) Main supply status"]
            pub fn MAINREGSTATUS(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u8 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "MAINREGSTATUS {{ MAINREGSTATUS: {0} }}@14882129255752814750"]
                #[link_section = ".binfmt.MAINREGSTATUS {{ MAINREGSTATUS: {0} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Description cluster: RAMn power control register"]
    pub type RAM0_POWER = ram0_power::Register;
    #[doc = "Description cluster: RAMn power control register"]
    pub mod ram0_power {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0900) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bit 0) Keep RAM section S0 on or off in System ON mode."]
            pub fn S0POWER(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 1) Keep RAM section S1 on or off in System ON mode."]
            pub fn S1POWER(self) -> u8 {
                const OFFSET: u8 = 1;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 2) Keep RAM section S2 on or off in System ON mode."]
            pub fn S2POWER(self) -> u8 {
                const OFFSET: u8 = 2;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 3) Keep RAM section S3 on or off in System ON mode."]
            pub fn S3POWER(self) -> u8 {
                const OFFSET: u8 = 3;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 4) Keep RAM section S4 on or off in System ON mode."]
            pub fn S4POWER(self) -> u8 {
                const OFFSET: u8 = 4;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 5) Keep RAM section S5 on or off in System ON mode."]
            pub fn S5POWER(self) -> u8 {
                const OFFSET: u8 = 5;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 6) Keep RAM section S6 on or off in System ON mode."]
            pub fn S6POWER(self) -> u8 {
                const OFFSET: u8 = 6;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 7) Keep RAM section S7 on or off in System ON mode."]
            pub fn S7POWER(self) -> u8 {
                const OFFSET: u8 = 7;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 8) Keep RAM section S8 on or off in System ON mode."]
            pub fn S8POWER(self) -> u8 {
                const OFFSET: u8 = 8;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 9) Keep RAM section S9 on or off in System ON mode."]
            pub fn S9POWER(self) -> u8 {
                const OFFSET: u8 = 9;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 10) Keep RAM section S10 on or off in System ON mode."]
            pub fn S10POWER(self) -> u8 {
                const OFFSET: u8 = 10;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 11) Keep RAM section S11 on or off in System ON mode."]
            pub fn S11POWER(self) -> u8 {
                const OFFSET: u8 = 11;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 12) Keep RAM section S12 on or off in System ON mode."]
            pub fn S12POWER(self) -> u8 {
                const OFFSET: u8 = 12;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 13) Keep RAM section S13 on or off in System ON mode."]
            pub fn S13POWER(self) -> u8 {
                const OFFSET: u8 = 13;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 14) Keep RAM section S14 on or off in System ON mode."]
            pub fn S14POWER(self) -> u8 {
                const OFFSET: u8 = 14;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 15) Keep RAM section S15 on or off in System ON mode."]
            pub fn S15POWER(self) -> u8 {
                const OFFSET: u8 = 15;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 16) Keep retention on RAM section S0 when RAM section is off"]
            pub fn S0RETENTION(self) -> u8 {
                const OFFSET: u8 = 16;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 17) Keep retention on RAM section S1 when RAM section is off"]
            pub fn S1RETENTION(self) -> u8 {
                const OFFSET: u8 = 17;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 18) Keep retention on RAM section S2 when RAM section is off"]
            pub fn S2RETENTION(self) -> u8 {
                const OFFSET: u8 = 18;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 19) Keep retention on RAM section S3 when RAM section is off"]
            pub fn S3RETENTION(self) -> u8 {
                const OFFSET: u8 = 19;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 20) Keep retention on RAM section S4 when RAM section is off"]
            pub fn S4RETENTION(self) -> u8 {
                const OFFSET: u8 = 20;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 21) Keep retention on RAM section S5 when RAM section is off"]
            pub fn S5RETENTION(self) -> u8 {
                const OFFSET: u8 = 21;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 22) Keep retention on RAM section S6 when RAM section is off"]
            pub fn S6RETENTION(self) -> u8 {
                const OFFSET: u8 = 22;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 23) Keep retention on RAM section S7 when RAM section is off"]
            pub fn S7RETENTION(self) -> u8 {
                const OFFSET: u8 = 23;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 24) Keep retention on RAM section S8 when RAM section is off"]
            pub fn S8RETENTION(self) -> u8 {
                const OFFSET: u8 = 24;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 25) Keep retention on RAM section S9 when RAM section is off"]
            pub fn S9RETENTION(self) -> u8 {
                const OFFSET: u8 = 25;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 26) Keep retention on RAM section S10 when RAM section is off"]
            pub fn S10RETENTION(self) -> u8 {
                const OFFSET: u8 = 26;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 27) Keep retention on RAM section S11 when RAM section is off"]
            pub fn S11RETENTION(self) -> u8 {
                const OFFSET: u8 = 27;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 28) Keep retention on RAM section S12 when RAM section is off"]
            pub fn S12RETENTION(self) -> u8 {
                const OFFSET: u8 = 28;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 29) Keep retention on RAM section S13 when RAM section is off"]
            pub fn S13RETENTION(self) -> u8 {
                const OFFSET: u8 = 29;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 30) Keep retention on RAM section S14 when RAM section is off"]
            pub fn S14RETENTION(self) -> u8 {
                const OFFSET: u8 = 30;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 31) Keep retention on RAM section S15 when RAM section is off"]
            pub fn S15RETENTION(self) -> u8 {
                const OFFSET: u8 = 31;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u32 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "RAM0_POWER {{ S15RETENTION: {31}, S14RETENTION: {30}, S13RETENTION: {29}, S12RETENTION: {28}, S11RETENTION: {27}, S10RETENTION: {26}, S9RETENTION: {25}, S8RETENTION: {24}, S7RETENTION: {23}, S6RETENTION: {22}, S5RETENTION: {21}, S4RETENTION: {20}, S3RETENTION: {19}, S2RETENTION: {18}, S1RETENTION: {17}, S0RETENTION: {16}, S15POWER: {15}, S14POWER: {14}, S13POWER: {13}, S12POWER: {12}, S11POWER: {11}, S10POWER: {10}, S9POWER: {9}, S8POWER: {8}, S7POWER: {7}, S6POWER: {6}, S5POWER: {5}, S4POWER: {4}, S3POWER: {3}, S2POWER: {2}, S1POWER: {1}, S0POWER: {0} }}@10436629692330384520"]
                #[link_section = ".binfmt.RAM0_POWER {{ S15RETENTION: {31}, S14RETENTION: {30}, S13RETENTION: {29}, S12RETENTION: {28}, S11RETENTION: {27}, S10RETENTION: {26}, S9RETENTION: {25}, S8RETENTION: {24}, S7RETENTION: {23}, S6RETENTION: {22}, S5RETENTION: {21}, S4RETENTION: {20}, S3RETENTION: {19}, S2RETENTION: {18}, S1RETENTION: {17}, S0RETENTION: {16}, S15POWER: {15}, S14POWER: {14}, S13POWER: {13}, S12POWER: {12}, S11POWER: {11}, S10POWER: {10}, S9POWER: {9}, S8POWER: {8}, S7POWER: {7}, S6POWER: {6}, S5POWER: {5}, S4POWER: {4}, S3POWER: {3}, S2POWER: {2}, S1POWER: {1}, S0POWER: {0} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 0) Keep RAM section S0 on or off in System ON mode."]
            #[allow(non_snake_case)]
            pub fn S0POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 1) Keep RAM section S1 on or off in System ON mode."]
            #[allow(non_snake_case)]
            pub fn S1POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 1;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 2) Keep RAM section S2 on or off in System ON mode."]
            #[allow(non_snake_case)]
            pub fn S2POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 2;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 3) Keep RAM section S3 on or off in System ON mode."]
            #[allow(non_snake_case)]
            pub fn S3POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 3;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 4) Keep RAM section S4 on or off in System ON mode."]
            #[allow(non_snake_case)]
            pub fn S4POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 4;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 5) Keep RAM section S5 on or off in System ON mode."]
            #[allow(non_snake_case)]
            pub fn S5POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 5;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 6) Keep RAM section S6 on or off in System ON mode."]
            #[allow(non_snake_case)]
            pub fn S6POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 6;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 7) Keep RAM section S7 on or off in System ON mode."]
            #[allow(non_snake_case)]
            pub fn S7POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 7;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 8) Keep RAM section S8 on or off in System ON mode."]
            #[allow(non_snake_case)]
            pub fn S8POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 8;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 9) Keep RAM section S9 on or off in System ON mode."]
            #[allow(non_snake_case)]
            pub fn S9POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 9;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 10) Keep RAM section S10 on or off in System ON mode."]
            #[allow(non_snake_case)]
            pub fn S10POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 10;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 11) Keep RAM section S11 on or off in System ON mode."]
            #[allow(non_snake_case)]
            pub fn S11POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 11;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 12) Keep RAM section S12 on or off in System ON mode."]
            #[allow(non_snake_case)]
            pub fn S12POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 12;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 13) Keep RAM section S13 on or off in System ON mode."]
            #[allow(non_snake_case)]
            pub fn S13POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 13;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 14) Keep RAM section S14 on or off in System ON mode."]
            #[allow(non_snake_case)]
            pub fn S14POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 14;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 15) Keep RAM section S15 on or off in System ON mode."]
            #[allow(non_snake_case)]
            pub fn S15POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 15;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 16) Keep retention on RAM section S0 when RAM section is off"]
            #[allow(non_snake_case)]
            pub fn S0RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 16;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 17) Keep retention on RAM section S1 when RAM section is off"]
            #[allow(non_snake_case)]
            pub fn S1RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 17;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 18) Keep retention on RAM section S2 when RAM section is off"]
            #[allow(non_snake_case)]
            pub fn S2RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 18;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 19) Keep retention on RAM section S3 when RAM section is off"]
            #[allow(non_snake_case)]
            pub fn S3RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 19;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 20) Keep retention on RAM section S4 when RAM section is off"]
            #[allow(non_snake_case)]
            pub fn S4RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 20;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 21) Keep retention on RAM section S5 when RAM section is off"]
            #[allow(non_snake_case)]
            pub fn S5RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 21;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 22) Keep retention on RAM section S6 when RAM section is off"]
            #[allow(non_snake_case)]
            pub fn S6RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 22;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 23) Keep retention on RAM section S7 when RAM section is off"]
            #[allow(non_snake_case)]
            pub fn S7RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 23;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 24) Keep retention on RAM section S8 when RAM section is off"]
            #[allow(non_snake_case)]
            pub fn S8RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 24;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 25) Keep retention on RAM section S9 when RAM section is off"]
            #[allow(non_snake_case)]
            pub fn S9RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 25;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 26) Keep retention on RAM section S10 when RAM section is off"]
            #[allow(non_snake_case)]
            pub fn S10RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 26;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 27) Keep retention on RAM section S11 when RAM section is off"]
            #[allow(non_snake_case)]
            pub fn S11RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 27;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 28) Keep retention on RAM section S12 when RAM section is off"]
            #[allow(non_snake_case)]
            pub fn S12RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 28;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 29) Keep retention on RAM section S13 when RAM section is off"]
            #[allow(non_snake_case)]
            pub fn S13RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 29;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 30) Keep retention on RAM section S14 when RAM section is off"]
            #[allow(non_snake_case)]
            pub fn S14RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 30;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 31) Keep retention on RAM section S15 when RAM section is off"]
            #[allow(non_snake_case)]
            pub fn S15RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 31;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Description cluster: RAMn power control set register"]
    pub type RAM0_POWERSET = ram0_powerset::Register;
    #[doc = "Description cluster: RAMn power control set register"]
    pub mod ram0_powerset {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0904) as *mut _
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 0) Keep RAM section S0 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S0POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 1) Keep RAM section S1 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S1POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 1;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 2) Keep RAM section S2 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S2POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 2;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 3) Keep RAM section S3 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S3POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 3;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 4) Keep RAM section S4 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S4POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 4;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 5) Keep RAM section S5 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S5POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 5;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 6) Keep RAM section S6 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S6POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 6;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 7) Keep RAM section S7 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S7POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 7;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 8) Keep RAM section S8 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S8POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 8;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 9) Keep RAM section S9 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S9POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 9;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 10) Keep RAM section S10 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S10POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 10;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 11) Keep RAM section S11 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S11POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 11;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 12) Keep RAM section S12 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S12POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 12;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 13) Keep RAM section S13 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S13POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 13;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 14) Keep RAM section S14 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S14POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 14;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 15) Keep RAM section S15 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S15POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 15;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 16) Keep retention on RAM section S0 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S0RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 16;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 17) Keep retention on RAM section S1 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S1RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 17;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 18) Keep retention on RAM section S2 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S2RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 18;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 19) Keep retention on RAM section S3 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S3RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 19;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 20) Keep retention on RAM section S4 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S4RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 20;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 21) Keep retention on RAM section S5 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S5RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 21;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 22) Keep retention on RAM section S6 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S6RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 22;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 23) Keep retention on RAM section S7 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S7RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 23;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 24) Keep retention on RAM section S8 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S8RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 24;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 25) Keep retention on RAM section S9 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S9RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 25;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 26) Keep retention on RAM section S10 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S10RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 26;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 27) Keep retention on RAM section S11 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S11RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 27;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 28) Keep retention on RAM section S12 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S12RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 28;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 29) Keep retention on RAM section S13 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S13RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 29;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 30) Keep retention on RAM section S14 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S14RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 30;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 31) Keep retention on RAM section S15 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S15RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 31;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Description cluster: RAMn power control clear register"]
    pub type RAM0_POWERCLR = ram0_powerclr::Register;
    #[doc = "Description cluster: RAMn power control clear register"]
    pub mod ram0_powerclr {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0908) as *mut _
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 0) Keep RAM section S0 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S0POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 1) Keep RAM section S1 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S1POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 1;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 2) Keep RAM section S2 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S2POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 2;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 3) Keep RAM section S3 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S3POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 3;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 4) Keep RAM section S4 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S4POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 4;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 5) Keep RAM section S5 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S5POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 5;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 6) Keep RAM section S6 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S6POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 6;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 7) Keep RAM section S7 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S7POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 7;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 8) Keep RAM section S8 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S8POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 8;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 9) Keep RAM section S9 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S9POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 9;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 10) Keep RAM section S10 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S10POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 10;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 11) Keep RAM section S11 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S11POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 11;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 12) Keep RAM section S12 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S12POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 12;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 13) Keep RAM section S13 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S13POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 13;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 14) Keep RAM section S14 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S14POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 14;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 15) Keep RAM section S15 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S15POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 15;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 16) Keep retention on RAM section S0 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S0RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 16;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 17) Keep retention on RAM section S1 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S1RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 17;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 18) Keep retention on RAM section S2 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S2RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 18;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 19) Keep retention on RAM section S3 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S3RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 19;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 20) Keep retention on RAM section S4 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S4RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 20;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 21) Keep retention on RAM section S5 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S5RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 21;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 22) Keep retention on RAM section S6 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S6RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 22;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 23) Keep retention on RAM section S7 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S7RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 23;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 24) Keep retention on RAM section S8 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S8RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 24;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 25) Keep retention on RAM section S9 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S9RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 25;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 26) Keep retention on RAM section S10 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S10RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 26;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 27) Keep retention on RAM section S11 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S11RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 27;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 28) Keep retention on RAM section S12 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S12RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 28;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 29) Keep retention on RAM section S13 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S13RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 29;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 30) Keep retention on RAM section S14 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S14RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 30;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 31) Keep retention on RAM section S15 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S15RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 31;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Description cluster: RAMn power control register"]
    pub type RAM1_POWER = ram1_power::Register;
    #[doc = "Description cluster: RAMn power control register"]
    pub mod ram1_power {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0910) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bit 0) Keep RAM section S0 on or off in System ON mode."]
            pub fn S0POWER(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 1) Keep RAM section S1 on or off in System ON mode."]
            pub fn S1POWER(self) -> u8 {
                const OFFSET: u8 = 1;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 2) Keep RAM section S2 on or off in System ON mode."]
            pub fn S2POWER(self) -> u8 {
                const OFFSET: u8 = 2;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 3) Keep RAM section S3 on or off in System ON mode."]
            pub fn S3POWER(self) -> u8 {
                const OFFSET: u8 = 3;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 4) Keep RAM section S4 on or off in System ON mode."]
            pub fn S4POWER(self) -> u8 {
                const OFFSET: u8 = 4;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 5) Keep RAM section S5 on or off in System ON mode."]
            pub fn S5POWER(self) -> u8 {
                const OFFSET: u8 = 5;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 6) Keep RAM section S6 on or off in System ON mode."]
            pub fn S6POWER(self) -> u8 {
                const OFFSET: u8 = 6;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 7) Keep RAM section S7 on or off in System ON mode."]
            pub fn S7POWER(self) -> u8 {
                const OFFSET: u8 = 7;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 8) Keep RAM section S8 on or off in System ON mode."]
            pub fn S8POWER(self) -> u8 {
                const OFFSET: u8 = 8;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 9) Keep RAM section S9 on or off in System ON mode."]
            pub fn S9POWER(self) -> u8 {
                const OFFSET: u8 = 9;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 10) Keep RAM section S10 on or off in System ON mode."]
            pub fn S10POWER(self) -> u8 {
                const OFFSET: u8 = 10;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 11) Keep RAM section S11 on or off in System ON mode."]
            pub fn S11POWER(self) -> u8 {
                const OFFSET: u8 = 11;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 12) Keep RAM section S12 on or off in System ON mode."]
            pub fn S12POWER(self) -> u8 {
                const OFFSET: u8 = 12;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 13) Keep RAM section S13 on or off in System ON mode."]
            pub fn S13POWER(self) -> u8 {
                const OFFSET: u8 = 13;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 14) Keep RAM section S14 on or off in System ON mode."]
            pub fn S14POWER(self) -> u8 {
                const OFFSET: u8 = 14;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 15) Keep RAM section S15 on or off in System ON mode."]
            pub fn S15POWER(self) -> u8 {
                const OFFSET: u8 = 15;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 16) Keep retention on RAM section S0 when RAM section is off"]
            pub fn S0RETENTION(self) -> u8 {
                const OFFSET: u8 = 16;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 17) Keep retention on RAM section S1 when RAM section is off"]
            pub fn S1RETENTION(self) -> u8 {
                const OFFSET: u8 = 17;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 18) Keep retention on RAM section S2 when RAM section is off"]
            pub fn S2RETENTION(self) -> u8 {
                const OFFSET: u8 = 18;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 19) Keep retention on RAM section S3 when RAM section is off"]
            pub fn S3RETENTION(self) -> u8 {
                const OFFSET: u8 = 19;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 20) Keep retention on RAM section S4 when RAM section is off"]
            pub fn S4RETENTION(self) -> u8 {
                const OFFSET: u8 = 20;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 21) Keep retention on RAM section S5 when RAM section is off"]
            pub fn S5RETENTION(self) -> u8 {
                const OFFSET: u8 = 21;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 22) Keep retention on RAM section S6 when RAM section is off"]
            pub fn S6RETENTION(self) -> u8 {
                const OFFSET: u8 = 22;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 23) Keep retention on RAM section S7 when RAM section is off"]
            pub fn S7RETENTION(self) -> u8 {
                const OFFSET: u8 = 23;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 24) Keep retention on RAM section S8 when RAM section is off"]
            pub fn S8RETENTION(self) -> u8 {
                const OFFSET: u8 = 24;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 25) Keep retention on RAM section S9 when RAM section is off"]
            pub fn S9RETENTION(self) -> u8 {
                const OFFSET: u8 = 25;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 26) Keep retention on RAM section S10 when RAM section is off"]
            pub fn S10RETENTION(self) -> u8 {
                const OFFSET: u8 = 26;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 27) Keep retention on RAM section S11 when RAM section is off"]
            pub fn S11RETENTION(self) -> u8 {
                const OFFSET: u8 = 27;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 28) Keep retention on RAM section S12 when RAM section is off"]
            pub fn S12RETENTION(self) -> u8 {
                const OFFSET: u8 = 28;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 29) Keep retention on RAM section S13 when RAM section is off"]
            pub fn S13RETENTION(self) -> u8 {
                const OFFSET: u8 = 29;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 30) Keep retention on RAM section S14 when RAM section is off"]
            pub fn S14RETENTION(self) -> u8 {
                const OFFSET: u8 = 30;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 31) Keep retention on RAM section S15 when RAM section is off"]
            pub fn S15RETENTION(self) -> u8 {
                const OFFSET: u8 = 31;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u32 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "RAM1_POWER {{ S15RETENTION: {31}, S14RETENTION: {30}, S13RETENTION: {29}, S12RETENTION: {28}, S11RETENTION: {27}, S10RETENTION: {26}, S9RETENTION: {25}, S8RETENTION: {24}, S7RETENTION: {23}, S6RETENTION: {22}, S5RETENTION: {21}, S4RETENTION: {20}, S3RETENTION: {19}, S2RETENTION: {18}, S1RETENTION: {17}, S0RETENTION: {16}, S15POWER: {15}, S14POWER: {14}, S13POWER: {13}, S12POWER: {12}, S11POWER: {11}, S10POWER: {10}, S9POWER: {9}, S8POWER: {8}, S7POWER: {7}, S6POWER: {6}, S5POWER: {5}, S4POWER: {4}, S3POWER: {3}, S2POWER: {2}, S1POWER: {1}, S0POWER: {0} }}@3277984121351501132"]
                #[link_section = ".binfmt.RAM1_POWER {{ S15RETENTION: {31}, S14RETENTION: {30}, S13RETENTION: {29}, S12RETENTION: {28}, S11RETENTION: {27}, S10RETENTION: {26}, S9RETENTION: {25}, S8RETENTION: {24}, S7RETENTION: {23}, S6RETENTION: {22}, S5RETENTION: {21}, S4RETENTION: {20}, S3RETENTION: {19}, S2RETENTION: {18}, S1RETENTION: {17}, S0RETENTION: {16}, S15POWER: {15}, S14POWER: {14}, S13POWER: {13}, S12POWER: {12}, S11POWER: {11}, S10POWER: {10}, S9POWER: {9}, S8POWER: {8}, S7POWER: {7}, S6POWER: {6}, S5POWER: {5}, S4POWER: {4}, S3POWER: {3}, S2POWER: {2}, S1POWER: {1}, S0POWER: {0} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 0) Keep RAM section S0 on or off in System ON mode."]
            #[allow(non_snake_case)]
            pub fn S0POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 1) Keep RAM section S1 on or off in System ON mode."]
            #[allow(non_snake_case)]
            pub fn S1POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 1;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 2) Keep RAM section S2 on or off in System ON mode."]
            #[allow(non_snake_case)]
            pub fn S2POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 2;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 3) Keep RAM section S3 on or off in System ON mode."]
            #[allow(non_snake_case)]
            pub fn S3POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 3;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 4) Keep RAM section S4 on or off in System ON mode."]
            #[allow(non_snake_case)]
            pub fn S4POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 4;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 5) Keep RAM section S5 on or off in System ON mode."]
            #[allow(non_snake_case)]
            pub fn S5POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 5;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 6) Keep RAM section S6 on or off in System ON mode."]
            #[allow(non_snake_case)]
            pub fn S6POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 6;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 7) Keep RAM section S7 on or off in System ON mode."]
            #[allow(non_snake_case)]
            pub fn S7POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 7;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 8) Keep RAM section S8 on or off in System ON mode."]
            #[allow(non_snake_case)]
            pub fn S8POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 8;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 9) Keep RAM section S9 on or off in System ON mode."]
            #[allow(non_snake_case)]
            pub fn S9POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 9;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 10) Keep RAM section S10 on or off in System ON mode."]
            #[allow(non_snake_case)]
            pub fn S10POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 10;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 11) Keep RAM section S11 on or off in System ON mode."]
            #[allow(non_snake_case)]
            pub fn S11POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 11;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 12) Keep RAM section S12 on or off in System ON mode."]
            #[allow(non_snake_case)]
            pub fn S12POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 12;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 13) Keep RAM section S13 on or off in System ON mode."]
            #[allow(non_snake_case)]
            pub fn S13POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 13;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 14) Keep RAM section S14 on or off in System ON mode."]
            #[allow(non_snake_case)]
            pub fn S14POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 14;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 15) Keep RAM section S15 on or off in System ON mode."]
            #[allow(non_snake_case)]
            pub fn S15POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 15;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 16) Keep retention on RAM section S0 when RAM section is off"]
            #[allow(non_snake_case)]
            pub fn S0RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 16;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 17) Keep retention on RAM section S1 when RAM section is off"]
            #[allow(non_snake_case)]
            pub fn S1RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 17;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 18) Keep retention on RAM section S2 when RAM section is off"]
            #[allow(non_snake_case)]
            pub fn S2RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 18;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 19) Keep retention on RAM section S3 when RAM section is off"]
            #[allow(non_snake_case)]
            pub fn S3RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 19;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 20) Keep retention on RAM section S4 when RAM section is off"]
            #[allow(non_snake_case)]
            pub fn S4RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 20;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 21) Keep retention on RAM section S5 when RAM section is off"]
            #[allow(non_snake_case)]
            pub fn S5RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 21;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 22) Keep retention on RAM section S6 when RAM section is off"]
            #[allow(non_snake_case)]
            pub fn S6RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 22;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 23) Keep retention on RAM section S7 when RAM section is off"]
            #[allow(non_snake_case)]
            pub fn S7RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 23;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 24) Keep retention on RAM section S8 when RAM section is off"]
            #[allow(non_snake_case)]
            pub fn S8RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 24;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 25) Keep retention on RAM section S9 when RAM section is off"]
            #[allow(non_snake_case)]
            pub fn S9RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 25;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 26) Keep retention on RAM section S10 when RAM section is off"]
            #[allow(non_snake_case)]
            pub fn S10RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 26;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 27) Keep retention on RAM section S11 when RAM section is off"]
            #[allow(non_snake_case)]
            pub fn S11RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 27;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 28) Keep retention on RAM section S12 when RAM section is off"]
            #[allow(non_snake_case)]
            pub fn S12RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 28;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 29) Keep retention on RAM section S13 when RAM section is off"]
            #[allow(non_snake_case)]
            pub fn S13RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 29;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 30) Keep retention on RAM section S14 when RAM section is off"]
            #[allow(non_snake_case)]
            pub fn S14RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 30;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 31) Keep retention on RAM section S15 when RAM section is off"]
            #[allow(non_snake_case)]
            pub fn S15RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 31;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Description cluster: RAMn power control set register"]
    pub type RAM1_POWERSET = ram1_powerset::Register;
    #[doc = "Description cluster: RAMn power control set register"]
    pub mod ram1_powerset {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0914) as *mut _
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 0) Keep RAM section S0 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S0POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 1) Keep RAM section S1 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S1POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 1;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 2) Keep RAM section S2 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S2POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 2;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 3) Keep RAM section S3 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S3POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 3;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 4) Keep RAM section S4 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S4POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 4;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 5) Keep RAM section S5 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S5POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 5;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 6) Keep RAM section S6 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S6POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 6;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 7) Keep RAM section S7 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S7POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 7;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 8) Keep RAM section S8 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S8POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 8;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 9) Keep RAM section S9 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S9POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 9;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 10) Keep RAM section S10 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S10POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 10;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 11) Keep RAM section S11 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S11POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 11;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 12) Keep RAM section S12 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S12POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 12;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 13) Keep RAM section S13 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S13POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 13;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 14) Keep RAM section S14 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S14POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 14;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 15) Keep RAM section S15 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S15POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 15;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 16) Keep retention on RAM section S0 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S0RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 16;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 17) Keep retention on RAM section S1 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S1RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 17;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 18) Keep retention on RAM section S2 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S2RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 18;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 19) Keep retention on RAM section S3 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S3RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 19;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 20) Keep retention on RAM section S4 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S4RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 20;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 21) Keep retention on RAM section S5 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S5RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 21;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 22) Keep retention on RAM section S6 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S6RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 22;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 23) Keep retention on RAM section S7 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S7RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 23;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 24) Keep retention on RAM section S8 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S8RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 24;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 25) Keep retention on RAM section S9 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S9RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 25;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 26) Keep retention on RAM section S10 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S10RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 26;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 27) Keep retention on RAM section S11 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S11RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 27;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 28) Keep retention on RAM section S12 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S12RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 28;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 29) Keep retention on RAM section S13 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S13RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 29;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 30) Keep retention on RAM section S14 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S14RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 30;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 31) Keep retention on RAM section S15 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S15RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 31;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Description cluster: RAMn power control clear register"]
    pub type RAM1_POWERCLR = ram1_powerclr::Register;
    #[doc = "Description cluster: RAMn power control clear register"]
    pub mod ram1_powerclr {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0918) as *mut _
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 0) Keep RAM section S0 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S0POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 1) Keep RAM section S1 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S1POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 1;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 2) Keep RAM section S2 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S2POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 2;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 3) Keep RAM section S3 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S3POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 3;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 4) Keep RAM section S4 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S4POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 4;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 5) Keep RAM section S5 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S5POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 5;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 6) Keep RAM section S6 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S6POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 6;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 7) Keep RAM section S7 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S7POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 7;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 8) Keep RAM section S8 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S8POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 8;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 9) Keep RAM section S9 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S9POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 9;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 10) Keep RAM section S10 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S10POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 10;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 11) Keep RAM section S11 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S11POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 11;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 12) Keep RAM section S12 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S12POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 12;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 13) Keep RAM section S13 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S13POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 13;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 14) Keep RAM section S14 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S14POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 14;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 15) Keep RAM section S15 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S15POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 15;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 16) Keep retention on RAM section S0 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S0RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 16;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 17) Keep retention on RAM section S1 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S1RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 17;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 18) Keep retention on RAM section S2 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S2RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 18;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 19) Keep retention on RAM section S3 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S3RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 19;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 20) Keep retention on RAM section S4 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S4RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 20;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 21) Keep retention on RAM section S5 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S5RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 21;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 22) Keep retention on RAM section S6 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S6RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 22;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 23) Keep retention on RAM section S7 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S7RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 23;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 24) Keep retention on RAM section S8 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S8RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 24;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 25) Keep retention on RAM section S9 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S9RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 25;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 26) Keep retention on RAM section S10 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S10RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 26;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 27) Keep retention on RAM section S11 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S11RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 27;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 28) Keep retention on RAM section S12 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S12RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 28;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 29) Keep retention on RAM section S13 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S13RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 29;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 30) Keep retention on RAM section S14 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S14RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 30;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 31) Keep retention on RAM section S15 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S15RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 31;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Description cluster: RAMn power control register"]
    pub type RAM2_POWER = ram2_power::Register;
    #[doc = "Description cluster: RAMn power control register"]
    pub mod ram2_power {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0920) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bit 0) Keep RAM section S0 on or off in System ON mode."]
            pub fn S0POWER(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 1) Keep RAM section S1 on or off in System ON mode."]
            pub fn S1POWER(self) -> u8 {
                const OFFSET: u8 = 1;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 2) Keep RAM section S2 on or off in System ON mode."]
            pub fn S2POWER(self) -> u8 {
                const OFFSET: u8 = 2;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 3) Keep RAM section S3 on or off in System ON mode."]
            pub fn S3POWER(self) -> u8 {
                const OFFSET: u8 = 3;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 4) Keep RAM section S4 on or off in System ON mode."]
            pub fn S4POWER(self) -> u8 {
                const OFFSET: u8 = 4;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 5) Keep RAM section S5 on or off in System ON mode."]
            pub fn S5POWER(self) -> u8 {
                const OFFSET: u8 = 5;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 6) Keep RAM section S6 on or off in System ON mode."]
            pub fn S6POWER(self) -> u8 {
                const OFFSET: u8 = 6;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 7) Keep RAM section S7 on or off in System ON mode."]
            pub fn S7POWER(self) -> u8 {
                const OFFSET: u8 = 7;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 8) Keep RAM section S8 on or off in System ON mode."]
            pub fn S8POWER(self) -> u8 {
                const OFFSET: u8 = 8;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 9) Keep RAM section S9 on or off in System ON mode."]
            pub fn S9POWER(self) -> u8 {
                const OFFSET: u8 = 9;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 10) Keep RAM section S10 on or off in System ON mode."]
            pub fn S10POWER(self) -> u8 {
                const OFFSET: u8 = 10;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 11) Keep RAM section S11 on or off in System ON mode."]
            pub fn S11POWER(self) -> u8 {
                const OFFSET: u8 = 11;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 12) Keep RAM section S12 on or off in System ON mode."]
            pub fn S12POWER(self) -> u8 {
                const OFFSET: u8 = 12;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 13) Keep RAM section S13 on or off in System ON mode."]
            pub fn S13POWER(self) -> u8 {
                const OFFSET: u8 = 13;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 14) Keep RAM section S14 on or off in System ON mode."]
            pub fn S14POWER(self) -> u8 {
                const OFFSET: u8 = 14;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 15) Keep RAM section S15 on or off in System ON mode."]
            pub fn S15POWER(self) -> u8 {
                const OFFSET: u8 = 15;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 16) Keep retention on RAM section S0 when RAM section is off"]
            pub fn S0RETENTION(self) -> u8 {
                const OFFSET: u8 = 16;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 17) Keep retention on RAM section S1 when RAM section is off"]
            pub fn S1RETENTION(self) -> u8 {
                const OFFSET: u8 = 17;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 18) Keep retention on RAM section S2 when RAM section is off"]
            pub fn S2RETENTION(self) -> u8 {
                const OFFSET: u8 = 18;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 19) Keep retention on RAM section S3 when RAM section is off"]
            pub fn S3RETENTION(self) -> u8 {
                const OFFSET: u8 = 19;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 20) Keep retention on RAM section S4 when RAM section is off"]
            pub fn S4RETENTION(self) -> u8 {
                const OFFSET: u8 = 20;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 21) Keep retention on RAM section S5 when RAM section is off"]
            pub fn S5RETENTION(self) -> u8 {
                const OFFSET: u8 = 21;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 22) Keep retention on RAM section S6 when RAM section is off"]
            pub fn S6RETENTION(self) -> u8 {
                const OFFSET: u8 = 22;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 23) Keep retention on RAM section S7 when RAM section is off"]
            pub fn S7RETENTION(self) -> u8 {
                const OFFSET: u8 = 23;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 24) Keep retention on RAM section S8 when RAM section is off"]
            pub fn S8RETENTION(self) -> u8 {
                const OFFSET: u8 = 24;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 25) Keep retention on RAM section S9 when RAM section is off"]
            pub fn S9RETENTION(self) -> u8 {
                const OFFSET: u8 = 25;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 26) Keep retention on RAM section S10 when RAM section is off"]
            pub fn S10RETENTION(self) -> u8 {
                const OFFSET: u8 = 26;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 27) Keep retention on RAM section S11 when RAM section is off"]
            pub fn S11RETENTION(self) -> u8 {
                const OFFSET: u8 = 27;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 28) Keep retention on RAM section S12 when RAM section is off"]
            pub fn S12RETENTION(self) -> u8 {
                const OFFSET: u8 = 28;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 29) Keep retention on RAM section S13 when RAM section is off"]
            pub fn S13RETENTION(self) -> u8 {
                const OFFSET: u8 = 29;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 30) Keep retention on RAM section S14 when RAM section is off"]
            pub fn S14RETENTION(self) -> u8 {
                const OFFSET: u8 = 30;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 31) Keep retention on RAM section S15 when RAM section is off"]
            pub fn S15RETENTION(self) -> u8 {
                const OFFSET: u8 = 31;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u32 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "RAM2_POWER {{ S15RETENTION: {31}, S14RETENTION: {30}, S13RETENTION: {29}, S12RETENTION: {28}, S11RETENTION: {27}, S10RETENTION: {26}, S9RETENTION: {25}, S8RETENTION: {24}, S7RETENTION: {23}, S6RETENTION: {22}, S5RETENTION: {21}, S4RETENTION: {20}, S3RETENTION: {19}, S2RETENTION: {18}, S1RETENTION: {17}, S0RETENTION: {16}, S15POWER: {15}, S14POWER: {14}, S13POWER: {13}, S12POWER: {12}, S11POWER: {11}, S10POWER: {10}, S9POWER: {9}, S8POWER: {8}, S7POWER: {7}, S6POWER: {6}, S5POWER: {5}, S4POWER: {4}, S3POWER: {3}, S2POWER: {2}, S1POWER: {1}, S0POWER: {0} }}@17647400635748263371"]
                #[link_section = ".binfmt.RAM2_POWER {{ S15RETENTION: {31}, S14RETENTION: {30}, S13RETENTION: {29}, S12RETENTION: {28}, S11RETENTION: {27}, S10RETENTION: {26}, S9RETENTION: {25}, S8RETENTION: {24}, S7RETENTION: {23}, S6RETENTION: {22}, S5RETENTION: {21}, S4RETENTION: {20}, S3RETENTION: {19}, S2RETENTION: {18}, S1RETENTION: {17}, S0RETENTION: {16}, S15POWER: {15}, S14POWER: {14}, S13POWER: {13}, S12POWER: {12}, S11POWER: {11}, S10POWER: {10}, S9POWER: {9}, S8POWER: {8}, S7POWER: {7}, S6POWER: {6}, S5POWER: {5}, S4POWER: {4}, S3POWER: {3}, S2POWER: {2}, S1POWER: {1}, S0POWER: {0} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 0) Keep RAM section S0 on or off in System ON mode."]
            #[allow(non_snake_case)]
            pub fn S0POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 1) Keep RAM section S1 on or off in System ON mode."]
            #[allow(non_snake_case)]
            pub fn S1POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 1;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 2) Keep RAM section S2 on or off in System ON mode."]
            #[allow(non_snake_case)]
            pub fn S2POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 2;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 3) Keep RAM section S3 on or off in System ON mode."]
            #[allow(non_snake_case)]
            pub fn S3POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 3;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 4) Keep RAM section S4 on or off in System ON mode."]
            #[allow(non_snake_case)]
            pub fn S4POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 4;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 5) Keep RAM section S5 on or off in System ON mode."]
            #[allow(non_snake_case)]
            pub fn S5POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 5;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 6) Keep RAM section S6 on or off in System ON mode."]
            #[allow(non_snake_case)]
            pub fn S6POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 6;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 7) Keep RAM section S7 on or off in System ON mode."]
            #[allow(non_snake_case)]
            pub fn S7POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 7;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 8) Keep RAM section S8 on or off in System ON mode."]
            #[allow(non_snake_case)]
            pub fn S8POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 8;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 9) Keep RAM section S9 on or off in System ON mode."]
            #[allow(non_snake_case)]
            pub fn S9POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 9;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 10) Keep RAM section S10 on or off in System ON mode."]
            #[allow(non_snake_case)]
            pub fn S10POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 10;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 11) Keep RAM section S11 on or off in System ON mode."]
            #[allow(non_snake_case)]
            pub fn S11POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 11;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 12) Keep RAM section S12 on or off in System ON mode."]
            #[allow(non_snake_case)]
            pub fn S12POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 12;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 13) Keep RAM section S13 on or off in System ON mode."]
            #[allow(non_snake_case)]
            pub fn S13POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 13;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 14) Keep RAM section S14 on or off in System ON mode."]
            #[allow(non_snake_case)]
            pub fn S14POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 14;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 15) Keep RAM section S15 on or off in System ON mode."]
            #[allow(non_snake_case)]
            pub fn S15POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 15;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 16) Keep retention on RAM section S0 when RAM section is off"]
            #[allow(non_snake_case)]
            pub fn S0RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 16;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 17) Keep retention on RAM section S1 when RAM section is off"]
            #[allow(non_snake_case)]
            pub fn S1RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 17;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 18) Keep retention on RAM section S2 when RAM section is off"]
            #[allow(non_snake_case)]
            pub fn S2RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 18;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 19) Keep retention on RAM section S3 when RAM section is off"]
            #[allow(non_snake_case)]
            pub fn S3RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 19;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 20) Keep retention on RAM section S4 when RAM section is off"]
            #[allow(non_snake_case)]
            pub fn S4RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 20;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 21) Keep retention on RAM section S5 when RAM section is off"]
            #[allow(non_snake_case)]
            pub fn S5RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 21;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 22) Keep retention on RAM section S6 when RAM section is off"]
            #[allow(non_snake_case)]
            pub fn S6RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 22;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 23) Keep retention on RAM section S7 when RAM section is off"]
            #[allow(non_snake_case)]
            pub fn S7RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 23;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 24) Keep retention on RAM section S8 when RAM section is off"]
            #[allow(non_snake_case)]
            pub fn S8RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 24;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 25) Keep retention on RAM section S9 when RAM section is off"]
            #[allow(non_snake_case)]
            pub fn S9RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 25;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 26) Keep retention on RAM section S10 when RAM section is off"]
            #[allow(non_snake_case)]
            pub fn S10RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 26;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 27) Keep retention on RAM section S11 when RAM section is off"]
            #[allow(non_snake_case)]
            pub fn S11RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 27;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 28) Keep retention on RAM section S12 when RAM section is off"]
            #[allow(non_snake_case)]
            pub fn S12RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 28;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 29) Keep retention on RAM section S13 when RAM section is off"]
            #[allow(non_snake_case)]
            pub fn S13RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 29;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 30) Keep retention on RAM section S14 when RAM section is off"]
            #[allow(non_snake_case)]
            pub fn S14RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 30;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 31) Keep retention on RAM section S15 when RAM section is off"]
            #[allow(non_snake_case)]
            pub fn S15RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 31;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Description cluster: RAMn power control set register"]
    pub type RAM2_POWERSET = ram2_powerset::Register;
    #[doc = "Description cluster: RAMn power control set register"]
    pub mod ram2_powerset {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0924) as *mut _
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 0) Keep RAM section S0 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S0POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 1) Keep RAM section S1 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S1POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 1;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 2) Keep RAM section S2 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S2POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 2;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 3) Keep RAM section S3 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S3POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 3;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 4) Keep RAM section S4 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S4POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 4;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 5) Keep RAM section S5 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S5POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 5;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 6) Keep RAM section S6 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S6POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 6;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 7) Keep RAM section S7 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S7POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 7;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 8) Keep RAM section S8 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S8POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 8;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 9) Keep RAM section S9 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S9POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 9;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 10) Keep RAM section S10 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S10POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 10;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 11) Keep RAM section S11 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S11POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 11;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 12) Keep RAM section S12 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S12POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 12;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 13) Keep RAM section S13 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S13POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 13;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 14) Keep RAM section S14 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S14POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 14;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 15) Keep RAM section S15 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S15POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 15;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 16) Keep retention on RAM section S0 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S0RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 16;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 17) Keep retention on RAM section S1 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S1RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 17;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 18) Keep retention on RAM section S2 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S2RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 18;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 19) Keep retention on RAM section S3 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S3RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 19;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 20) Keep retention on RAM section S4 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S4RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 20;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 21) Keep retention on RAM section S5 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S5RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 21;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 22) Keep retention on RAM section S6 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S6RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 22;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 23) Keep retention on RAM section S7 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S7RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 23;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 24) Keep retention on RAM section S8 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S8RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 24;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 25) Keep retention on RAM section S9 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S9RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 25;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 26) Keep retention on RAM section S10 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S10RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 26;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 27) Keep retention on RAM section S11 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S11RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 27;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 28) Keep retention on RAM section S12 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S12RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 28;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 29) Keep retention on RAM section S13 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S13RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 29;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 30) Keep retention on RAM section S14 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S14RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 30;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 31) Keep retention on RAM section S15 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S15RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 31;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Description cluster: RAMn power control clear register"]
    pub type RAM2_POWERCLR = ram2_powerclr::Register;
    #[doc = "Description cluster: RAMn power control clear register"]
    pub mod ram2_powerclr {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0928) as *mut _
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 0) Keep RAM section S0 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S0POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 1) Keep RAM section S1 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S1POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 1;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 2) Keep RAM section S2 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S2POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 2;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 3) Keep RAM section S3 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S3POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 3;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 4) Keep RAM section S4 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S4POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 4;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 5) Keep RAM section S5 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S5POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 5;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 6) Keep RAM section S6 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S6POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 6;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 7) Keep RAM section S7 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S7POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 7;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 8) Keep RAM section S8 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S8POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 8;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 9) Keep RAM section S9 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S9POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 9;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 10) Keep RAM section S10 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S10POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 10;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 11) Keep RAM section S11 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S11POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 11;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 12) Keep RAM section S12 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S12POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 12;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 13) Keep RAM section S13 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S13POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 13;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 14) Keep RAM section S14 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S14POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 14;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 15) Keep RAM section S15 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S15POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 15;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 16) Keep retention on RAM section S0 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S0RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 16;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 17) Keep retention on RAM section S1 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S1RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 17;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 18) Keep retention on RAM section S2 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S2RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 18;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 19) Keep retention on RAM section S3 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S3RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 19;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 20) Keep retention on RAM section S4 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S4RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 20;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 21) Keep retention on RAM section S5 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S5RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 21;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 22) Keep retention on RAM section S6 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S6RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 22;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 23) Keep retention on RAM section S7 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S7RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 23;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 24) Keep retention on RAM section S8 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S8RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 24;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 25) Keep retention on RAM section S9 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S9RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 25;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 26) Keep retention on RAM section S10 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S10RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 26;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 27) Keep retention on RAM section S11 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S11RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 27;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 28) Keep retention on RAM section S12 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S12RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 28;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 29) Keep retention on RAM section S13 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S13RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 29;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 30) Keep retention on RAM section S14 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S14RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 30;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 31) Keep retention on RAM section S15 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S15RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 31;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Description cluster: RAMn power control register"]
    pub type RAM3_POWER = ram3_power::Register;
    #[doc = "Description cluster: RAMn power control register"]
    pub mod ram3_power {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0930) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bit 0) Keep RAM section S0 on or off in System ON mode."]
            pub fn S0POWER(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 1) Keep RAM section S1 on or off in System ON mode."]
            pub fn S1POWER(self) -> u8 {
                const OFFSET: u8 = 1;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 2) Keep RAM section S2 on or off in System ON mode."]
            pub fn S2POWER(self) -> u8 {
                const OFFSET: u8 = 2;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 3) Keep RAM section S3 on or off in System ON mode."]
            pub fn S3POWER(self) -> u8 {
                const OFFSET: u8 = 3;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 4) Keep RAM section S4 on or off in System ON mode."]
            pub fn S4POWER(self) -> u8 {
                const OFFSET: u8 = 4;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 5) Keep RAM section S5 on or off in System ON mode."]
            pub fn S5POWER(self) -> u8 {
                const OFFSET: u8 = 5;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 6) Keep RAM section S6 on or off in System ON mode."]
            pub fn S6POWER(self) -> u8 {
                const OFFSET: u8 = 6;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 7) Keep RAM section S7 on or off in System ON mode."]
            pub fn S7POWER(self) -> u8 {
                const OFFSET: u8 = 7;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 8) Keep RAM section S8 on or off in System ON mode."]
            pub fn S8POWER(self) -> u8 {
                const OFFSET: u8 = 8;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 9) Keep RAM section S9 on or off in System ON mode."]
            pub fn S9POWER(self) -> u8 {
                const OFFSET: u8 = 9;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 10) Keep RAM section S10 on or off in System ON mode."]
            pub fn S10POWER(self) -> u8 {
                const OFFSET: u8 = 10;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 11) Keep RAM section S11 on or off in System ON mode."]
            pub fn S11POWER(self) -> u8 {
                const OFFSET: u8 = 11;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 12) Keep RAM section S12 on or off in System ON mode."]
            pub fn S12POWER(self) -> u8 {
                const OFFSET: u8 = 12;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 13) Keep RAM section S13 on or off in System ON mode."]
            pub fn S13POWER(self) -> u8 {
                const OFFSET: u8 = 13;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 14) Keep RAM section S14 on or off in System ON mode."]
            pub fn S14POWER(self) -> u8 {
                const OFFSET: u8 = 14;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 15) Keep RAM section S15 on or off in System ON mode."]
            pub fn S15POWER(self) -> u8 {
                const OFFSET: u8 = 15;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 16) Keep retention on RAM section S0 when RAM section is off"]
            pub fn S0RETENTION(self) -> u8 {
                const OFFSET: u8 = 16;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 17) Keep retention on RAM section S1 when RAM section is off"]
            pub fn S1RETENTION(self) -> u8 {
                const OFFSET: u8 = 17;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 18) Keep retention on RAM section S2 when RAM section is off"]
            pub fn S2RETENTION(self) -> u8 {
                const OFFSET: u8 = 18;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 19) Keep retention on RAM section S3 when RAM section is off"]
            pub fn S3RETENTION(self) -> u8 {
                const OFFSET: u8 = 19;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 20) Keep retention on RAM section S4 when RAM section is off"]
            pub fn S4RETENTION(self) -> u8 {
                const OFFSET: u8 = 20;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 21) Keep retention on RAM section S5 when RAM section is off"]
            pub fn S5RETENTION(self) -> u8 {
                const OFFSET: u8 = 21;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 22) Keep retention on RAM section S6 when RAM section is off"]
            pub fn S6RETENTION(self) -> u8 {
                const OFFSET: u8 = 22;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 23) Keep retention on RAM section S7 when RAM section is off"]
            pub fn S7RETENTION(self) -> u8 {
                const OFFSET: u8 = 23;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 24) Keep retention on RAM section S8 when RAM section is off"]
            pub fn S8RETENTION(self) -> u8 {
                const OFFSET: u8 = 24;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 25) Keep retention on RAM section S9 when RAM section is off"]
            pub fn S9RETENTION(self) -> u8 {
                const OFFSET: u8 = 25;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 26) Keep retention on RAM section S10 when RAM section is off"]
            pub fn S10RETENTION(self) -> u8 {
                const OFFSET: u8 = 26;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 27) Keep retention on RAM section S11 when RAM section is off"]
            pub fn S11RETENTION(self) -> u8 {
                const OFFSET: u8 = 27;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 28) Keep retention on RAM section S12 when RAM section is off"]
            pub fn S12RETENTION(self) -> u8 {
                const OFFSET: u8 = 28;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 29) Keep retention on RAM section S13 when RAM section is off"]
            pub fn S13RETENTION(self) -> u8 {
                const OFFSET: u8 = 29;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 30) Keep retention on RAM section S14 when RAM section is off"]
            pub fn S14RETENTION(self) -> u8 {
                const OFFSET: u8 = 30;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 31) Keep retention on RAM section S15 when RAM section is off"]
            pub fn S15RETENTION(self) -> u8 {
                const OFFSET: u8 = 31;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u32 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "RAM3_POWER {{ S15RETENTION: {31}, S14RETENTION: {30}, S13RETENTION: {29}, S12RETENTION: {28}, S11RETENTION: {27}, S10RETENTION: {26}, S9RETENTION: {25}, S8RETENTION: {24}, S7RETENTION: {23}, S6RETENTION: {22}, S5RETENTION: {21}, S4RETENTION: {20}, S3RETENTION: {19}, S2RETENTION: {18}, S1RETENTION: {17}, S0RETENTION: {16}, S15POWER: {15}, S14POWER: {14}, S13POWER: {13}, S12POWER: {12}, S11POWER: {11}, S10POWER: {10}, S9POWER: {9}, S8POWER: {8}, S7POWER: {7}, S6POWER: {6}, S5POWER: {5}, S4POWER: {4}, S3POWER: {3}, S2POWER: {2}, S1POWER: {1}, S0POWER: {0} }}@16103505351708479012"]
                #[link_section = ".binfmt.RAM3_POWER {{ S15RETENTION: {31}, S14RETENTION: {30}, S13RETENTION: {29}, S12RETENTION: {28}, S11RETENTION: {27}, S10RETENTION: {26}, S9RETENTION: {25}, S8RETENTION: {24}, S7RETENTION: {23}, S6RETENTION: {22}, S5RETENTION: {21}, S4RETENTION: {20}, S3RETENTION: {19}, S2RETENTION: {18}, S1RETENTION: {17}, S0RETENTION: {16}, S15POWER: {15}, S14POWER: {14}, S13POWER: {13}, S12POWER: {12}, S11POWER: {11}, S10POWER: {10}, S9POWER: {9}, S8POWER: {8}, S7POWER: {7}, S6POWER: {6}, S5POWER: {5}, S4POWER: {4}, S3POWER: {3}, S2POWER: {2}, S1POWER: {1}, S0POWER: {0} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 0) Keep RAM section S0 on or off in System ON mode."]
            #[allow(non_snake_case)]
            pub fn S0POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 1) Keep RAM section S1 on or off in System ON mode."]
            #[allow(non_snake_case)]
            pub fn S1POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 1;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 2) Keep RAM section S2 on or off in System ON mode."]
            #[allow(non_snake_case)]
            pub fn S2POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 2;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 3) Keep RAM section S3 on or off in System ON mode."]
            #[allow(non_snake_case)]
            pub fn S3POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 3;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 4) Keep RAM section S4 on or off in System ON mode."]
            #[allow(non_snake_case)]
            pub fn S4POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 4;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 5) Keep RAM section S5 on or off in System ON mode."]
            #[allow(non_snake_case)]
            pub fn S5POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 5;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 6) Keep RAM section S6 on or off in System ON mode."]
            #[allow(non_snake_case)]
            pub fn S6POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 6;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 7) Keep RAM section S7 on or off in System ON mode."]
            #[allow(non_snake_case)]
            pub fn S7POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 7;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 8) Keep RAM section S8 on or off in System ON mode."]
            #[allow(non_snake_case)]
            pub fn S8POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 8;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 9) Keep RAM section S9 on or off in System ON mode."]
            #[allow(non_snake_case)]
            pub fn S9POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 9;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 10) Keep RAM section S10 on or off in System ON mode."]
            #[allow(non_snake_case)]
            pub fn S10POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 10;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 11) Keep RAM section S11 on or off in System ON mode."]
            #[allow(non_snake_case)]
            pub fn S11POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 11;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 12) Keep RAM section S12 on or off in System ON mode."]
            #[allow(non_snake_case)]
            pub fn S12POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 12;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 13) Keep RAM section S13 on or off in System ON mode."]
            #[allow(non_snake_case)]
            pub fn S13POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 13;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 14) Keep RAM section S14 on or off in System ON mode."]
            #[allow(non_snake_case)]
            pub fn S14POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 14;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 15) Keep RAM section S15 on or off in System ON mode."]
            #[allow(non_snake_case)]
            pub fn S15POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 15;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 16) Keep retention on RAM section S0 when RAM section is off"]
            #[allow(non_snake_case)]
            pub fn S0RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 16;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 17) Keep retention on RAM section S1 when RAM section is off"]
            #[allow(non_snake_case)]
            pub fn S1RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 17;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 18) Keep retention on RAM section S2 when RAM section is off"]
            #[allow(non_snake_case)]
            pub fn S2RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 18;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 19) Keep retention on RAM section S3 when RAM section is off"]
            #[allow(non_snake_case)]
            pub fn S3RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 19;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 20) Keep retention on RAM section S4 when RAM section is off"]
            #[allow(non_snake_case)]
            pub fn S4RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 20;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 21) Keep retention on RAM section S5 when RAM section is off"]
            #[allow(non_snake_case)]
            pub fn S5RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 21;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 22) Keep retention on RAM section S6 when RAM section is off"]
            #[allow(non_snake_case)]
            pub fn S6RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 22;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 23) Keep retention on RAM section S7 when RAM section is off"]
            #[allow(non_snake_case)]
            pub fn S7RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 23;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 24) Keep retention on RAM section S8 when RAM section is off"]
            #[allow(non_snake_case)]
            pub fn S8RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 24;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 25) Keep retention on RAM section S9 when RAM section is off"]
            #[allow(non_snake_case)]
            pub fn S9RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 25;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 26) Keep retention on RAM section S10 when RAM section is off"]
            #[allow(non_snake_case)]
            pub fn S10RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 26;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 27) Keep retention on RAM section S11 when RAM section is off"]
            #[allow(non_snake_case)]
            pub fn S11RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 27;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 28) Keep retention on RAM section S12 when RAM section is off"]
            #[allow(non_snake_case)]
            pub fn S12RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 28;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 29) Keep retention on RAM section S13 when RAM section is off"]
            #[allow(non_snake_case)]
            pub fn S13RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 29;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 30) Keep retention on RAM section S14 when RAM section is off"]
            #[allow(non_snake_case)]
            pub fn S14RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 30;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 31) Keep retention on RAM section S15 when RAM section is off"]
            #[allow(non_snake_case)]
            pub fn S15RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 31;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Description cluster: RAMn power control set register"]
    pub type RAM3_POWERSET = ram3_powerset::Register;
    #[doc = "Description cluster: RAMn power control set register"]
    pub mod ram3_powerset {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0934) as *mut _
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 0) Keep RAM section S0 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S0POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 1) Keep RAM section S1 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S1POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 1;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 2) Keep RAM section S2 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S2POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 2;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 3) Keep RAM section S3 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S3POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 3;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 4) Keep RAM section S4 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S4POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 4;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 5) Keep RAM section S5 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S5POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 5;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 6) Keep RAM section S6 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S6POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 6;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 7) Keep RAM section S7 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S7POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 7;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 8) Keep RAM section S8 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S8POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 8;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 9) Keep RAM section S9 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S9POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 9;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 10) Keep RAM section S10 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S10POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 10;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 11) Keep RAM section S11 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S11POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 11;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 12) Keep RAM section S12 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S12POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 12;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 13) Keep RAM section S13 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S13POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 13;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 14) Keep RAM section S14 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S14POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 14;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 15) Keep RAM section S15 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S15POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 15;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 16) Keep retention on RAM section S0 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S0RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 16;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 17) Keep retention on RAM section S1 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S1RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 17;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 18) Keep retention on RAM section S2 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S2RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 18;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 19) Keep retention on RAM section S3 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S3RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 19;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 20) Keep retention on RAM section S4 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S4RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 20;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 21) Keep retention on RAM section S5 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S5RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 21;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 22) Keep retention on RAM section S6 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S6RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 22;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 23) Keep retention on RAM section S7 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S7RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 23;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 24) Keep retention on RAM section S8 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S8RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 24;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 25) Keep retention on RAM section S9 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S9RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 25;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 26) Keep retention on RAM section S10 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S10RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 26;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 27) Keep retention on RAM section S11 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S11RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 27;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 28) Keep retention on RAM section S12 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S12RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 28;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 29) Keep retention on RAM section S13 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S13RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 29;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 30) Keep retention on RAM section S14 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S14RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 30;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 31) Keep retention on RAM section S15 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S15RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 31;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Description cluster: RAMn power control clear register"]
    pub type RAM3_POWERCLR = ram3_powerclr::Register;
    #[doc = "Description cluster: RAMn power control clear register"]
    pub mod ram3_powerclr {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0938) as *mut _
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 0) Keep RAM section S0 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S0POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 1) Keep RAM section S1 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S1POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 1;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 2) Keep RAM section S2 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S2POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 2;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 3) Keep RAM section S3 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S3POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 3;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 4) Keep RAM section S4 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S4POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 4;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 5) Keep RAM section S5 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S5POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 5;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 6) Keep RAM section S6 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S6POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 6;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 7) Keep RAM section S7 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S7POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 7;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 8) Keep RAM section S8 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S8POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 8;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 9) Keep RAM section S9 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S9POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 9;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 10) Keep RAM section S10 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S10POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 10;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 11) Keep RAM section S11 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S11POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 11;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 12) Keep RAM section S12 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S12POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 12;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 13) Keep RAM section S13 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S13POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 13;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 14) Keep RAM section S14 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S14POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 14;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 15) Keep RAM section S15 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S15POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 15;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 16) Keep retention on RAM section S0 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S0RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 16;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 17) Keep retention on RAM section S1 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S1RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 17;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 18) Keep retention on RAM section S2 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S2RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 18;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 19) Keep retention on RAM section S3 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S3RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 19;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 20) Keep retention on RAM section S4 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S4RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 20;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 21) Keep retention on RAM section S5 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S5RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 21;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 22) Keep retention on RAM section S6 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S6RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 22;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 23) Keep retention on RAM section S7 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S7RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 23;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 24) Keep retention on RAM section S8 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S8RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 24;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 25) Keep retention on RAM section S9 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S9RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 25;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 26) Keep retention on RAM section S10 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S10RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 26;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 27) Keep retention on RAM section S11 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S11RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 27;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 28) Keep retention on RAM section S12 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S12RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 28;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 29) Keep retention on RAM section S13 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S13RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 29;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 30) Keep retention on RAM section S14 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S14RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 30;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 31) Keep retention on RAM section S15 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S15RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 31;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Description cluster: RAMn power control register"]
    pub type RAM4_POWER = ram4_power::Register;
    #[doc = "Description cluster: RAMn power control register"]
    pub mod ram4_power {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0940) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bit 0) Keep RAM section S0 on or off in System ON mode."]
            pub fn S0POWER(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 1) Keep RAM section S1 on or off in System ON mode."]
            pub fn S1POWER(self) -> u8 {
                const OFFSET: u8 = 1;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 2) Keep RAM section S2 on or off in System ON mode."]
            pub fn S2POWER(self) -> u8 {
                const OFFSET: u8 = 2;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 3) Keep RAM section S3 on or off in System ON mode."]
            pub fn S3POWER(self) -> u8 {
                const OFFSET: u8 = 3;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 4) Keep RAM section S4 on or off in System ON mode."]
            pub fn S4POWER(self) -> u8 {
                const OFFSET: u8 = 4;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 5) Keep RAM section S5 on or off in System ON mode."]
            pub fn S5POWER(self) -> u8 {
                const OFFSET: u8 = 5;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 6) Keep RAM section S6 on or off in System ON mode."]
            pub fn S6POWER(self) -> u8 {
                const OFFSET: u8 = 6;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 7) Keep RAM section S7 on or off in System ON mode."]
            pub fn S7POWER(self) -> u8 {
                const OFFSET: u8 = 7;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 8) Keep RAM section S8 on or off in System ON mode."]
            pub fn S8POWER(self) -> u8 {
                const OFFSET: u8 = 8;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 9) Keep RAM section S9 on or off in System ON mode."]
            pub fn S9POWER(self) -> u8 {
                const OFFSET: u8 = 9;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 10) Keep RAM section S10 on or off in System ON mode."]
            pub fn S10POWER(self) -> u8 {
                const OFFSET: u8 = 10;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 11) Keep RAM section S11 on or off in System ON mode."]
            pub fn S11POWER(self) -> u8 {
                const OFFSET: u8 = 11;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 12) Keep RAM section S12 on or off in System ON mode."]
            pub fn S12POWER(self) -> u8 {
                const OFFSET: u8 = 12;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 13) Keep RAM section S13 on or off in System ON mode."]
            pub fn S13POWER(self) -> u8 {
                const OFFSET: u8 = 13;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 14) Keep RAM section S14 on or off in System ON mode."]
            pub fn S14POWER(self) -> u8 {
                const OFFSET: u8 = 14;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 15) Keep RAM section S15 on or off in System ON mode."]
            pub fn S15POWER(self) -> u8 {
                const OFFSET: u8 = 15;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 16) Keep retention on RAM section S0 when RAM section is off"]
            pub fn S0RETENTION(self) -> u8 {
                const OFFSET: u8 = 16;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 17) Keep retention on RAM section S1 when RAM section is off"]
            pub fn S1RETENTION(self) -> u8 {
                const OFFSET: u8 = 17;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 18) Keep retention on RAM section S2 when RAM section is off"]
            pub fn S2RETENTION(self) -> u8 {
                const OFFSET: u8 = 18;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 19) Keep retention on RAM section S3 when RAM section is off"]
            pub fn S3RETENTION(self) -> u8 {
                const OFFSET: u8 = 19;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 20) Keep retention on RAM section S4 when RAM section is off"]
            pub fn S4RETENTION(self) -> u8 {
                const OFFSET: u8 = 20;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 21) Keep retention on RAM section S5 when RAM section is off"]
            pub fn S5RETENTION(self) -> u8 {
                const OFFSET: u8 = 21;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 22) Keep retention on RAM section S6 when RAM section is off"]
            pub fn S6RETENTION(self) -> u8 {
                const OFFSET: u8 = 22;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 23) Keep retention on RAM section S7 when RAM section is off"]
            pub fn S7RETENTION(self) -> u8 {
                const OFFSET: u8 = 23;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 24) Keep retention on RAM section S8 when RAM section is off"]
            pub fn S8RETENTION(self) -> u8 {
                const OFFSET: u8 = 24;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 25) Keep retention on RAM section S9 when RAM section is off"]
            pub fn S9RETENTION(self) -> u8 {
                const OFFSET: u8 = 25;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 26) Keep retention on RAM section S10 when RAM section is off"]
            pub fn S10RETENTION(self) -> u8 {
                const OFFSET: u8 = 26;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 27) Keep retention on RAM section S11 when RAM section is off"]
            pub fn S11RETENTION(self) -> u8 {
                const OFFSET: u8 = 27;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 28) Keep retention on RAM section S12 when RAM section is off"]
            pub fn S12RETENTION(self) -> u8 {
                const OFFSET: u8 = 28;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 29) Keep retention on RAM section S13 when RAM section is off"]
            pub fn S13RETENTION(self) -> u8 {
                const OFFSET: u8 = 29;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 30) Keep retention on RAM section S14 when RAM section is off"]
            pub fn S14RETENTION(self) -> u8 {
                const OFFSET: u8 = 30;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 31) Keep retention on RAM section S15 when RAM section is off"]
            pub fn S15RETENTION(self) -> u8 {
                const OFFSET: u8 = 31;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u32 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "RAM4_POWER {{ S15RETENTION: {31}, S14RETENTION: {30}, S13RETENTION: {29}, S12RETENTION: {28}, S11RETENTION: {27}, S10RETENTION: {26}, S9RETENTION: {25}, S8RETENTION: {24}, S7RETENTION: {23}, S6RETENTION: {22}, S5RETENTION: {21}, S4RETENTION: {20}, S3RETENTION: {19}, S2RETENTION: {18}, S1RETENTION: {17}, S0RETENTION: {16}, S15POWER: {15}, S14POWER: {14}, S13POWER: {13}, S12POWER: {12}, S11POWER: {11}, S10POWER: {10}, S9POWER: {9}, S8POWER: {8}, S7POWER: {7}, S6POWER: {6}, S5POWER: {5}, S4POWER: {4}, S3POWER: {3}, S2POWER: {2}, S1POWER: {1}, S0POWER: {0} }}@9613821617557580693"]
                #[link_section = ".binfmt.RAM4_POWER {{ S15RETENTION: {31}, S14RETENTION: {30}, S13RETENTION: {29}, S12RETENTION: {28}, S11RETENTION: {27}, S10RETENTION: {26}, S9RETENTION: {25}, S8RETENTION: {24}, S7RETENTION: {23}, S6RETENTION: {22}, S5RETENTION: {21}, S4RETENTION: {20}, S3RETENTION: {19}, S2RETENTION: {18}, S1RETENTION: {17}, S0RETENTION: {16}, S15POWER: {15}, S14POWER: {14}, S13POWER: {13}, S12POWER: {12}, S11POWER: {11}, S10POWER: {10}, S9POWER: {9}, S8POWER: {8}, S7POWER: {7}, S6POWER: {6}, S5POWER: {5}, S4POWER: {4}, S3POWER: {3}, S2POWER: {2}, S1POWER: {1}, S0POWER: {0} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 0) Keep RAM section S0 on or off in System ON mode."]
            #[allow(non_snake_case)]
            pub fn S0POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 1) Keep RAM section S1 on or off in System ON mode."]
            #[allow(non_snake_case)]
            pub fn S1POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 1;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 2) Keep RAM section S2 on or off in System ON mode."]
            #[allow(non_snake_case)]
            pub fn S2POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 2;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 3) Keep RAM section S3 on or off in System ON mode."]
            #[allow(non_snake_case)]
            pub fn S3POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 3;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 4) Keep RAM section S4 on or off in System ON mode."]
            #[allow(non_snake_case)]
            pub fn S4POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 4;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 5) Keep RAM section S5 on or off in System ON mode."]
            #[allow(non_snake_case)]
            pub fn S5POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 5;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 6) Keep RAM section S6 on or off in System ON mode."]
            #[allow(non_snake_case)]
            pub fn S6POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 6;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 7) Keep RAM section S7 on or off in System ON mode."]
            #[allow(non_snake_case)]
            pub fn S7POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 7;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 8) Keep RAM section S8 on or off in System ON mode."]
            #[allow(non_snake_case)]
            pub fn S8POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 8;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 9) Keep RAM section S9 on or off in System ON mode."]
            #[allow(non_snake_case)]
            pub fn S9POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 9;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 10) Keep RAM section S10 on or off in System ON mode."]
            #[allow(non_snake_case)]
            pub fn S10POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 10;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 11) Keep RAM section S11 on or off in System ON mode."]
            #[allow(non_snake_case)]
            pub fn S11POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 11;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 12) Keep RAM section S12 on or off in System ON mode."]
            #[allow(non_snake_case)]
            pub fn S12POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 12;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 13) Keep RAM section S13 on or off in System ON mode."]
            #[allow(non_snake_case)]
            pub fn S13POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 13;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 14) Keep RAM section S14 on or off in System ON mode."]
            #[allow(non_snake_case)]
            pub fn S14POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 14;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 15) Keep RAM section S15 on or off in System ON mode."]
            #[allow(non_snake_case)]
            pub fn S15POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 15;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 16) Keep retention on RAM section S0 when RAM section is off"]
            #[allow(non_snake_case)]
            pub fn S0RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 16;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 17) Keep retention on RAM section S1 when RAM section is off"]
            #[allow(non_snake_case)]
            pub fn S1RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 17;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 18) Keep retention on RAM section S2 when RAM section is off"]
            #[allow(non_snake_case)]
            pub fn S2RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 18;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 19) Keep retention on RAM section S3 when RAM section is off"]
            #[allow(non_snake_case)]
            pub fn S3RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 19;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 20) Keep retention on RAM section S4 when RAM section is off"]
            #[allow(non_snake_case)]
            pub fn S4RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 20;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 21) Keep retention on RAM section S5 when RAM section is off"]
            #[allow(non_snake_case)]
            pub fn S5RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 21;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 22) Keep retention on RAM section S6 when RAM section is off"]
            #[allow(non_snake_case)]
            pub fn S6RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 22;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 23) Keep retention on RAM section S7 when RAM section is off"]
            #[allow(non_snake_case)]
            pub fn S7RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 23;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 24) Keep retention on RAM section S8 when RAM section is off"]
            #[allow(non_snake_case)]
            pub fn S8RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 24;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 25) Keep retention on RAM section S9 when RAM section is off"]
            #[allow(non_snake_case)]
            pub fn S9RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 25;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 26) Keep retention on RAM section S10 when RAM section is off"]
            #[allow(non_snake_case)]
            pub fn S10RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 26;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 27) Keep retention on RAM section S11 when RAM section is off"]
            #[allow(non_snake_case)]
            pub fn S11RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 27;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 28) Keep retention on RAM section S12 when RAM section is off"]
            #[allow(non_snake_case)]
            pub fn S12RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 28;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 29) Keep retention on RAM section S13 when RAM section is off"]
            #[allow(non_snake_case)]
            pub fn S13RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 29;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 30) Keep retention on RAM section S14 when RAM section is off"]
            #[allow(non_snake_case)]
            pub fn S14RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 30;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 31) Keep retention on RAM section S15 when RAM section is off"]
            #[allow(non_snake_case)]
            pub fn S15RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 31;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Description cluster: RAMn power control set register"]
    pub type RAM4_POWERSET = ram4_powerset::Register;
    #[doc = "Description cluster: RAMn power control set register"]
    pub mod ram4_powerset {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0944) as *mut _
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 0) Keep RAM section S0 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S0POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 1) Keep RAM section S1 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S1POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 1;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 2) Keep RAM section S2 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S2POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 2;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 3) Keep RAM section S3 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S3POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 3;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 4) Keep RAM section S4 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S4POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 4;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 5) Keep RAM section S5 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S5POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 5;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 6) Keep RAM section S6 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S6POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 6;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 7) Keep RAM section S7 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S7POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 7;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 8) Keep RAM section S8 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S8POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 8;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 9) Keep RAM section S9 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S9POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 9;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 10) Keep RAM section S10 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S10POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 10;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 11) Keep RAM section S11 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S11POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 11;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 12) Keep RAM section S12 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S12POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 12;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 13) Keep RAM section S13 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S13POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 13;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 14) Keep RAM section S14 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S14POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 14;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 15) Keep RAM section S15 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S15POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 15;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 16) Keep retention on RAM section S0 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S0RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 16;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 17) Keep retention on RAM section S1 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S1RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 17;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 18) Keep retention on RAM section S2 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S2RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 18;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 19) Keep retention on RAM section S3 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S3RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 19;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 20) Keep retention on RAM section S4 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S4RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 20;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 21) Keep retention on RAM section S5 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S5RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 21;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 22) Keep retention on RAM section S6 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S6RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 22;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 23) Keep retention on RAM section S7 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S7RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 23;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 24) Keep retention on RAM section S8 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S8RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 24;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 25) Keep retention on RAM section S9 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S9RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 25;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 26) Keep retention on RAM section S10 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S10RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 26;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 27) Keep retention on RAM section S11 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S11RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 27;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 28) Keep retention on RAM section S12 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S12RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 28;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 29) Keep retention on RAM section S13 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S13RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 29;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 30) Keep retention on RAM section S14 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S14RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 30;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 31) Keep retention on RAM section S15 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S15RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 31;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Description cluster: RAMn power control clear register"]
    pub type RAM4_POWERCLR = ram4_powerclr::Register;
    #[doc = "Description cluster: RAMn power control clear register"]
    pub mod ram4_powerclr {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0948) as *mut _
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 0) Keep RAM section S0 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S0POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 1) Keep RAM section S1 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S1POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 1;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 2) Keep RAM section S2 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S2POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 2;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 3) Keep RAM section S3 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S3POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 3;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 4) Keep RAM section S4 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S4POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 4;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 5) Keep RAM section S5 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S5POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 5;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 6) Keep RAM section S6 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S6POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 6;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 7) Keep RAM section S7 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S7POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 7;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 8) Keep RAM section S8 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S8POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 8;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 9) Keep RAM section S9 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S9POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 9;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 10) Keep RAM section S10 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S10POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 10;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 11) Keep RAM section S11 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S11POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 11;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 12) Keep RAM section S12 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S12POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 12;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 13) Keep RAM section S13 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S13POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 13;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 14) Keep RAM section S14 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S14POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 14;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 15) Keep RAM section S15 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S15POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 15;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 16) Keep retention on RAM section S0 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S0RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 16;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 17) Keep retention on RAM section S1 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S1RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 17;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 18) Keep retention on RAM section S2 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S2RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 18;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 19) Keep retention on RAM section S3 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S3RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 19;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 20) Keep retention on RAM section S4 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S4RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 20;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 21) Keep retention on RAM section S5 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S5RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 21;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 22) Keep retention on RAM section S6 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S6RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 22;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 23) Keep retention on RAM section S7 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S7RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 23;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 24) Keep retention on RAM section S8 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S8RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 24;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 25) Keep retention on RAM section S9 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S9RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 25;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 26) Keep retention on RAM section S10 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S10RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 26;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 27) Keep retention on RAM section S11 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S11RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 27;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 28) Keep retention on RAM section S12 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S12RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 28;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 29) Keep retention on RAM section S13 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S13RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 29;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 30) Keep retention on RAM section S14 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S14RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 30;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 31) Keep retention on RAM section S15 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S15RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 31;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Description cluster: RAMn power control register"]
    pub type RAM5_POWER = ram5_power::Register;
    #[doc = "Description cluster: RAMn power control register"]
    pub mod ram5_power {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0950) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bit 0) Keep RAM section S0 on or off in System ON mode."]
            pub fn S0POWER(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 1) Keep RAM section S1 on or off in System ON mode."]
            pub fn S1POWER(self) -> u8 {
                const OFFSET: u8 = 1;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 2) Keep RAM section S2 on or off in System ON mode."]
            pub fn S2POWER(self) -> u8 {
                const OFFSET: u8 = 2;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 3) Keep RAM section S3 on or off in System ON mode."]
            pub fn S3POWER(self) -> u8 {
                const OFFSET: u8 = 3;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 4) Keep RAM section S4 on or off in System ON mode."]
            pub fn S4POWER(self) -> u8 {
                const OFFSET: u8 = 4;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 5) Keep RAM section S5 on or off in System ON mode."]
            pub fn S5POWER(self) -> u8 {
                const OFFSET: u8 = 5;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 6) Keep RAM section S6 on or off in System ON mode."]
            pub fn S6POWER(self) -> u8 {
                const OFFSET: u8 = 6;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 7) Keep RAM section S7 on or off in System ON mode."]
            pub fn S7POWER(self) -> u8 {
                const OFFSET: u8 = 7;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 8) Keep RAM section S8 on or off in System ON mode."]
            pub fn S8POWER(self) -> u8 {
                const OFFSET: u8 = 8;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 9) Keep RAM section S9 on or off in System ON mode."]
            pub fn S9POWER(self) -> u8 {
                const OFFSET: u8 = 9;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 10) Keep RAM section S10 on or off in System ON mode."]
            pub fn S10POWER(self) -> u8 {
                const OFFSET: u8 = 10;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 11) Keep RAM section S11 on or off in System ON mode."]
            pub fn S11POWER(self) -> u8 {
                const OFFSET: u8 = 11;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 12) Keep RAM section S12 on or off in System ON mode."]
            pub fn S12POWER(self) -> u8 {
                const OFFSET: u8 = 12;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 13) Keep RAM section S13 on or off in System ON mode."]
            pub fn S13POWER(self) -> u8 {
                const OFFSET: u8 = 13;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 14) Keep RAM section S14 on or off in System ON mode."]
            pub fn S14POWER(self) -> u8 {
                const OFFSET: u8 = 14;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 15) Keep RAM section S15 on or off in System ON mode."]
            pub fn S15POWER(self) -> u8 {
                const OFFSET: u8 = 15;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 16) Keep retention on RAM section S0 when RAM section is off"]
            pub fn S0RETENTION(self) -> u8 {
                const OFFSET: u8 = 16;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 17) Keep retention on RAM section S1 when RAM section is off"]
            pub fn S1RETENTION(self) -> u8 {
                const OFFSET: u8 = 17;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 18) Keep retention on RAM section S2 when RAM section is off"]
            pub fn S2RETENTION(self) -> u8 {
                const OFFSET: u8 = 18;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 19) Keep retention on RAM section S3 when RAM section is off"]
            pub fn S3RETENTION(self) -> u8 {
                const OFFSET: u8 = 19;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 20) Keep retention on RAM section S4 when RAM section is off"]
            pub fn S4RETENTION(self) -> u8 {
                const OFFSET: u8 = 20;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 21) Keep retention on RAM section S5 when RAM section is off"]
            pub fn S5RETENTION(self) -> u8 {
                const OFFSET: u8 = 21;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 22) Keep retention on RAM section S6 when RAM section is off"]
            pub fn S6RETENTION(self) -> u8 {
                const OFFSET: u8 = 22;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 23) Keep retention on RAM section S7 when RAM section is off"]
            pub fn S7RETENTION(self) -> u8 {
                const OFFSET: u8 = 23;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 24) Keep retention on RAM section S8 when RAM section is off"]
            pub fn S8RETENTION(self) -> u8 {
                const OFFSET: u8 = 24;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 25) Keep retention on RAM section S9 when RAM section is off"]
            pub fn S9RETENTION(self) -> u8 {
                const OFFSET: u8 = 25;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 26) Keep retention on RAM section S10 when RAM section is off"]
            pub fn S10RETENTION(self) -> u8 {
                const OFFSET: u8 = 26;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 27) Keep retention on RAM section S11 when RAM section is off"]
            pub fn S11RETENTION(self) -> u8 {
                const OFFSET: u8 = 27;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 28) Keep retention on RAM section S12 when RAM section is off"]
            pub fn S12RETENTION(self) -> u8 {
                const OFFSET: u8 = 28;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 29) Keep retention on RAM section S13 when RAM section is off"]
            pub fn S13RETENTION(self) -> u8 {
                const OFFSET: u8 = 29;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 30) Keep retention on RAM section S14 when RAM section is off"]
            pub fn S14RETENTION(self) -> u8 {
                const OFFSET: u8 = 30;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 31) Keep retention on RAM section S15 when RAM section is off"]
            pub fn S15RETENTION(self) -> u8 {
                const OFFSET: u8 = 31;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u32 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "RAM5_POWER {{ S15RETENTION: {31}, S14RETENTION: {30}, S13RETENTION: {29}, S12RETENTION: {28}, S11RETENTION: {27}, S10RETENTION: {26}, S9RETENTION: {25}, S8RETENTION: {24}, S7RETENTION: {23}, S6RETENTION: {22}, S5RETENTION: {21}, S4RETENTION: {20}, S3RETENTION: {19}, S2RETENTION: {18}, S1RETENTION: {17}, S0RETENTION: {16}, S15POWER: {15}, S14POWER: {14}, S13POWER: {13}, S12POWER: {12}, S11POWER: {11}, S10POWER: {10}, S9POWER: {9}, S8POWER: {8}, S7POWER: {7}, S6POWER: {6}, S5POWER: {5}, S4POWER: {4}, S3POWER: {3}, S2POWER: {2}, S1POWER: {1}, S0POWER: {0} }}@16144774329997379572"]
                #[link_section = ".binfmt.RAM5_POWER {{ S15RETENTION: {31}, S14RETENTION: {30}, S13RETENTION: {29}, S12RETENTION: {28}, S11RETENTION: {27}, S10RETENTION: {26}, S9RETENTION: {25}, S8RETENTION: {24}, S7RETENTION: {23}, S6RETENTION: {22}, S5RETENTION: {21}, S4RETENTION: {20}, S3RETENTION: {19}, S2RETENTION: {18}, S1RETENTION: {17}, S0RETENTION: {16}, S15POWER: {15}, S14POWER: {14}, S13POWER: {13}, S12POWER: {12}, S11POWER: {11}, S10POWER: {10}, S9POWER: {9}, S8POWER: {8}, S7POWER: {7}, S6POWER: {6}, S5POWER: {5}, S4POWER: {4}, S3POWER: {3}, S2POWER: {2}, S1POWER: {1}, S0POWER: {0} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 0) Keep RAM section S0 on or off in System ON mode."]
            #[allow(non_snake_case)]
            pub fn S0POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 1) Keep RAM section S1 on or off in System ON mode."]
            #[allow(non_snake_case)]
            pub fn S1POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 1;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 2) Keep RAM section S2 on or off in System ON mode."]
            #[allow(non_snake_case)]
            pub fn S2POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 2;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 3) Keep RAM section S3 on or off in System ON mode."]
            #[allow(non_snake_case)]
            pub fn S3POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 3;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 4) Keep RAM section S4 on or off in System ON mode."]
            #[allow(non_snake_case)]
            pub fn S4POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 4;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 5) Keep RAM section S5 on or off in System ON mode."]
            #[allow(non_snake_case)]
            pub fn S5POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 5;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 6) Keep RAM section S6 on or off in System ON mode."]
            #[allow(non_snake_case)]
            pub fn S6POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 6;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 7) Keep RAM section S7 on or off in System ON mode."]
            #[allow(non_snake_case)]
            pub fn S7POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 7;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 8) Keep RAM section S8 on or off in System ON mode."]
            #[allow(non_snake_case)]
            pub fn S8POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 8;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 9) Keep RAM section S9 on or off in System ON mode."]
            #[allow(non_snake_case)]
            pub fn S9POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 9;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 10) Keep RAM section S10 on or off in System ON mode."]
            #[allow(non_snake_case)]
            pub fn S10POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 10;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 11) Keep RAM section S11 on or off in System ON mode."]
            #[allow(non_snake_case)]
            pub fn S11POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 11;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 12) Keep RAM section S12 on or off in System ON mode."]
            #[allow(non_snake_case)]
            pub fn S12POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 12;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 13) Keep RAM section S13 on or off in System ON mode."]
            #[allow(non_snake_case)]
            pub fn S13POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 13;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 14) Keep RAM section S14 on or off in System ON mode."]
            #[allow(non_snake_case)]
            pub fn S14POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 14;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 15) Keep RAM section S15 on or off in System ON mode."]
            #[allow(non_snake_case)]
            pub fn S15POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 15;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 16) Keep retention on RAM section S0 when RAM section is off"]
            #[allow(non_snake_case)]
            pub fn S0RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 16;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 17) Keep retention on RAM section S1 when RAM section is off"]
            #[allow(non_snake_case)]
            pub fn S1RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 17;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 18) Keep retention on RAM section S2 when RAM section is off"]
            #[allow(non_snake_case)]
            pub fn S2RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 18;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 19) Keep retention on RAM section S3 when RAM section is off"]
            #[allow(non_snake_case)]
            pub fn S3RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 19;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 20) Keep retention on RAM section S4 when RAM section is off"]
            #[allow(non_snake_case)]
            pub fn S4RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 20;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 21) Keep retention on RAM section S5 when RAM section is off"]
            #[allow(non_snake_case)]
            pub fn S5RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 21;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 22) Keep retention on RAM section S6 when RAM section is off"]
            #[allow(non_snake_case)]
            pub fn S6RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 22;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 23) Keep retention on RAM section S7 when RAM section is off"]
            #[allow(non_snake_case)]
            pub fn S7RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 23;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 24) Keep retention on RAM section S8 when RAM section is off"]
            #[allow(non_snake_case)]
            pub fn S8RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 24;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 25) Keep retention on RAM section S9 when RAM section is off"]
            #[allow(non_snake_case)]
            pub fn S9RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 25;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 26) Keep retention on RAM section S10 when RAM section is off"]
            #[allow(non_snake_case)]
            pub fn S10RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 26;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 27) Keep retention on RAM section S11 when RAM section is off"]
            #[allow(non_snake_case)]
            pub fn S11RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 27;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 28) Keep retention on RAM section S12 when RAM section is off"]
            #[allow(non_snake_case)]
            pub fn S12RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 28;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 29) Keep retention on RAM section S13 when RAM section is off"]
            #[allow(non_snake_case)]
            pub fn S13RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 29;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 30) Keep retention on RAM section S14 when RAM section is off"]
            #[allow(non_snake_case)]
            pub fn S14RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 30;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 31) Keep retention on RAM section S15 when RAM section is off"]
            #[allow(non_snake_case)]
            pub fn S15RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 31;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Description cluster: RAMn power control set register"]
    pub type RAM5_POWERSET = ram5_powerset::Register;
    #[doc = "Description cluster: RAMn power control set register"]
    pub mod ram5_powerset {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0954) as *mut _
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 0) Keep RAM section S0 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S0POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 1) Keep RAM section S1 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S1POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 1;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 2) Keep RAM section S2 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S2POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 2;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 3) Keep RAM section S3 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S3POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 3;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 4) Keep RAM section S4 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S4POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 4;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 5) Keep RAM section S5 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S5POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 5;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 6) Keep RAM section S6 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S6POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 6;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 7) Keep RAM section S7 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S7POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 7;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 8) Keep RAM section S8 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S8POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 8;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 9) Keep RAM section S9 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S9POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 9;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 10) Keep RAM section S10 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S10POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 10;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 11) Keep RAM section S11 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S11POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 11;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 12) Keep RAM section S12 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S12POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 12;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 13) Keep RAM section S13 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S13POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 13;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 14) Keep RAM section S14 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S14POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 14;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 15) Keep RAM section S15 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S15POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 15;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 16) Keep retention on RAM section S0 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S0RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 16;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 17) Keep retention on RAM section S1 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S1RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 17;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 18) Keep retention on RAM section S2 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S2RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 18;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 19) Keep retention on RAM section S3 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S3RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 19;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 20) Keep retention on RAM section S4 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S4RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 20;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 21) Keep retention on RAM section S5 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S5RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 21;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 22) Keep retention on RAM section S6 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S6RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 22;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 23) Keep retention on RAM section S7 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S7RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 23;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 24) Keep retention on RAM section S8 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S8RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 24;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 25) Keep retention on RAM section S9 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S9RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 25;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 26) Keep retention on RAM section S10 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S10RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 26;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 27) Keep retention on RAM section S11 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S11RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 27;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 28) Keep retention on RAM section S12 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S12RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 28;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 29) Keep retention on RAM section S13 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S13RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 29;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 30) Keep retention on RAM section S14 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S14RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 30;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 31) Keep retention on RAM section S15 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S15RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 31;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Description cluster: RAMn power control clear register"]
    pub type RAM5_POWERCLR = ram5_powerclr::Register;
    #[doc = "Description cluster: RAMn power control clear register"]
    pub mod ram5_powerclr {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0958) as *mut _
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 0) Keep RAM section S0 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S0POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 1) Keep RAM section S1 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S1POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 1;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 2) Keep RAM section S2 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S2POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 2;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 3) Keep RAM section S3 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S3POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 3;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 4) Keep RAM section S4 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S4POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 4;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 5) Keep RAM section S5 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S5POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 5;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 6) Keep RAM section S6 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S6POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 6;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 7) Keep RAM section S7 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S7POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 7;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 8) Keep RAM section S8 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S8POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 8;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 9) Keep RAM section S9 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S9POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 9;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 10) Keep RAM section S10 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S10POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 10;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 11) Keep RAM section S11 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S11POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 11;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 12) Keep RAM section S12 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S12POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 12;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 13) Keep RAM section S13 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S13POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 13;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 14) Keep RAM section S14 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S14POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 14;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 15) Keep RAM section S15 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S15POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 15;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 16) Keep retention on RAM section S0 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S0RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 16;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 17) Keep retention on RAM section S1 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S1RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 17;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 18) Keep retention on RAM section S2 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S2RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 18;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 19) Keep retention on RAM section S3 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S3RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 19;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 20) Keep retention on RAM section S4 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S4RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 20;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 21) Keep retention on RAM section S5 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S5RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 21;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 22) Keep retention on RAM section S6 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S6RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 22;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 23) Keep retention on RAM section S7 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S7RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 23;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 24) Keep retention on RAM section S8 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S8RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 24;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 25) Keep retention on RAM section S9 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S9RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 25;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 26) Keep retention on RAM section S10 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S10RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 26;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 27) Keep retention on RAM section S11 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S11RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 27;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 28) Keep retention on RAM section S12 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S12RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 28;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 29) Keep retention on RAM section S13 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S13RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 29;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 30) Keep retention on RAM section S14 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S14RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 30;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 31) Keep retention on RAM section S15 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S15RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 31;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Description cluster: RAMn power control register"]
    pub type RAM6_POWER = ram6_power::Register;
    #[doc = "Description cluster: RAMn power control register"]
    pub mod ram6_power {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0960) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bit 0) Keep RAM section S0 on or off in System ON mode."]
            pub fn S0POWER(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 1) Keep RAM section S1 on or off in System ON mode."]
            pub fn S1POWER(self) -> u8 {
                const OFFSET: u8 = 1;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 2) Keep RAM section S2 on or off in System ON mode."]
            pub fn S2POWER(self) -> u8 {
                const OFFSET: u8 = 2;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 3) Keep RAM section S3 on or off in System ON mode."]
            pub fn S3POWER(self) -> u8 {
                const OFFSET: u8 = 3;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 4) Keep RAM section S4 on or off in System ON mode."]
            pub fn S4POWER(self) -> u8 {
                const OFFSET: u8 = 4;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 5) Keep RAM section S5 on or off in System ON mode."]
            pub fn S5POWER(self) -> u8 {
                const OFFSET: u8 = 5;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 6) Keep RAM section S6 on or off in System ON mode."]
            pub fn S6POWER(self) -> u8 {
                const OFFSET: u8 = 6;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 7) Keep RAM section S7 on or off in System ON mode."]
            pub fn S7POWER(self) -> u8 {
                const OFFSET: u8 = 7;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 8) Keep RAM section S8 on or off in System ON mode."]
            pub fn S8POWER(self) -> u8 {
                const OFFSET: u8 = 8;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 9) Keep RAM section S9 on or off in System ON mode."]
            pub fn S9POWER(self) -> u8 {
                const OFFSET: u8 = 9;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 10) Keep RAM section S10 on or off in System ON mode."]
            pub fn S10POWER(self) -> u8 {
                const OFFSET: u8 = 10;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 11) Keep RAM section S11 on or off in System ON mode."]
            pub fn S11POWER(self) -> u8 {
                const OFFSET: u8 = 11;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 12) Keep RAM section S12 on or off in System ON mode."]
            pub fn S12POWER(self) -> u8 {
                const OFFSET: u8 = 12;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 13) Keep RAM section S13 on or off in System ON mode."]
            pub fn S13POWER(self) -> u8 {
                const OFFSET: u8 = 13;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 14) Keep RAM section S14 on or off in System ON mode."]
            pub fn S14POWER(self) -> u8 {
                const OFFSET: u8 = 14;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 15) Keep RAM section S15 on or off in System ON mode."]
            pub fn S15POWER(self) -> u8 {
                const OFFSET: u8 = 15;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 16) Keep retention on RAM section S0 when RAM section is off"]
            pub fn S0RETENTION(self) -> u8 {
                const OFFSET: u8 = 16;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 17) Keep retention on RAM section S1 when RAM section is off"]
            pub fn S1RETENTION(self) -> u8 {
                const OFFSET: u8 = 17;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 18) Keep retention on RAM section S2 when RAM section is off"]
            pub fn S2RETENTION(self) -> u8 {
                const OFFSET: u8 = 18;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 19) Keep retention on RAM section S3 when RAM section is off"]
            pub fn S3RETENTION(self) -> u8 {
                const OFFSET: u8 = 19;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 20) Keep retention on RAM section S4 when RAM section is off"]
            pub fn S4RETENTION(self) -> u8 {
                const OFFSET: u8 = 20;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 21) Keep retention on RAM section S5 when RAM section is off"]
            pub fn S5RETENTION(self) -> u8 {
                const OFFSET: u8 = 21;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 22) Keep retention on RAM section S6 when RAM section is off"]
            pub fn S6RETENTION(self) -> u8 {
                const OFFSET: u8 = 22;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 23) Keep retention on RAM section S7 when RAM section is off"]
            pub fn S7RETENTION(self) -> u8 {
                const OFFSET: u8 = 23;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 24) Keep retention on RAM section S8 when RAM section is off"]
            pub fn S8RETENTION(self) -> u8 {
                const OFFSET: u8 = 24;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 25) Keep retention on RAM section S9 when RAM section is off"]
            pub fn S9RETENTION(self) -> u8 {
                const OFFSET: u8 = 25;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 26) Keep retention on RAM section S10 when RAM section is off"]
            pub fn S10RETENTION(self) -> u8 {
                const OFFSET: u8 = 26;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 27) Keep retention on RAM section S11 when RAM section is off"]
            pub fn S11RETENTION(self) -> u8 {
                const OFFSET: u8 = 27;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 28) Keep retention on RAM section S12 when RAM section is off"]
            pub fn S12RETENTION(self) -> u8 {
                const OFFSET: u8 = 28;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 29) Keep retention on RAM section S13 when RAM section is off"]
            pub fn S13RETENTION(self) -> u8 {
                const OFFSET: u8 = 29;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 30) Keep retention on RAM section S14 when RAM section is off"]
            pub fn S14RETENTION(self) -> u8 {
                const OFFSET: u8 = 30;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 31) Keep retention on RAM section S15 when RAM section is off"]
            pub fn S15RETENTION(self) -> u8 {
                const OFFSET: u8 = 31;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u32 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "RAM6_POWER {{ S15RETENTION: {31}, S14RETENTION: {30}, S13RETENTION: {29}, S12RETENTION: {28}, S11RETENTION: {27}, S10RETENTION: {26}, S9RETENTION: {25}, S8RETENTION: {24}, S7RETENTION: {23}, S6RETENTION: {22}, S5RETENTION: {21}, S4RETENTION: {20}, S3RETENTION: {19}, S2RETENTION: {18}, S1RETENTION: {17}, S0RETENTION: {16}, S15POWER: {15}, S14POWER: {14}, S13POWER: {13}, S12POWER: {12}, S11POWER: {11}, S10POWER: {10}, S9POWER: {9}, S8POWER: {8}, S7POWER: {7}, S6POWER: {6}, S5POWER: {5}, S4POWER: {4}, S3POWER: {3}, S2POWER: {2}, S1POWER: {1}, S0POWER: {0} }}@16246755392153058337"]
                #[link_section = ".binfmt.RAM6_POWER {{ S15RETENTION: {31}, S14RETENTION: {30}, S13RETENTION: {29}, S12RETENTION: {28}, S11RETENTION: {27}, S10RETENTION: {26}, S9RETENTION: {25}, S8RETENTION: {24}, S7RETENTION: {23}, S6RETENTION: {22}, S5RETENTION: {21}, S4RETENTION: {20}, S3RETENTION: {19}, S2RETENTION: {18}, S1RETENTION: {17}, S0RETENTION: {16}, S15POWER: {15}, S14POWER: {14}, S13POWER: {13}, S12POWER: {12}, S11POWER: {11}, S10POWER: {10}, S9POWER: {9}, S8POWER: {8}, S7POWER: {7}, S6POWER: {6}, S5POWER: {5}, S4POWER: {4}, S3POWER: {3}, S2POWER: {2}, S1POWER: {1}, S0POWER: {0} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 0) Keep RAM section S0 on or off in System ON mode."]
            #[allow(non_snake_case)]
            pub fn S0POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 1) Keep RAM section S1 on or off in System ON mode."]
            #[allow(non_snake_case)]
            pub fn S1POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 1;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 2) Keep RAM section S2 on or off in System ON mode."]
            #[allow(non_snake_case)]
            pub fn S2POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 2;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 3) Keep RAM section S3 on or off in System ON mode."]
            #[allow(non_snake_case)]
            pub fn S3POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 3;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 4) Keep RAM section S4 on or off in System ON mode."]
            #[allow(non_snake_case)]
            pub fn S4POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 4;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 5) Keep RAM section S5 on or off in System ON mode."]
            #[allow(non_snake_case)]
            pub fn S5POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 5;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 6) Keep RAM section S6 on or off in System ON mode."]
            #[allow(non_snake_case)]
            pub fn S6POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 6;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 7) Keep RAM section S7 on or off in System ON mode."]
            #[allow(non_snake_case)]
            pub fn S7POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 7;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 8) Keep RAM section S8 on or off in System ON mode."]
            #[allow(non_snake_case)]
            pub fn S8POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 8;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 9) Keep RAM section S9 on or off in System ON mode."]
            #[allow(non_snake_case)]
            pub fn S9POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 9;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 10) Keep RAM section S10 on or off in System ON mode."]
            #[allow(non_snake_case)]
            pub fn S10POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 10;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 11) Keep RAM section S11 on or off in System ON mode."]
            #[allow(non_snake_case)]
            pub fn S11POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 11;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 12) Keep RAM section S12 on or off in System ON mode."]
            #[allow(non_snake_case)]
            pub fn S12POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 12;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 13) Keep RAM section S13 on or off in System ON mode."]
            #[allow(non_snake_case)]
            pub fn S13POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 13;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 14) Keep RAM section S14 on or off in System ON mode."]
            #[allow(non_snake_case)]
            pub fn S14POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 14;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 15) Keep RAM section S15 on or off in System ON mode."]
            #[allow(non_snake_case)]
            pub fn S15POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 15;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 16) Keep retention on RAM section S0 when RAM section is off"]
            #[allow(non_snake_case)]
            pub fn S0RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 16;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 17) Keep retention on RAM section S1 when RAM section is off"]
            #[allow(non_snake_case)]
            pub fn S1RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 17;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 18) Keep retention on RAM section S2 when RAM section is off"]
            #[allow(non_snake_case)]
            pub fn S2RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 18;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 19) Keep retention on RAM section S3 when RAM section is off"]
            #[allow(non_snake_case)]
            pub fn S3RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 19;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 20) Keep retention on RAM section S4 when RAM section is off"]
            #[allow(non_snake_case)]
            pub fn S4RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 20;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 21) Keep retention on RAM section S5 when RAM section is off"]
            #[allow(non_snake_case)]
            pub fn S5RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 21;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 22) Keep retention on RAM section S6 when RAM section is off"]
            #[allow(non_snake_case)]
            pub fn S6RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 22;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 23) Keep retention on RAM section S7 when RAM section is off"]
            #[allow(non_snake_case)]
            pub fn S7RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 23;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 24) Keep retention on RAM section S8 when RAM section is off"]
            #[allow(non_snake_case)]
            pub fn S8RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 24;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 25) Keep retention on RAM section S9 when RAM section is off"]
            #[allow(non_snake_case)]
            pub fn S9RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 25;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 26) Keep retention on RAM section S10 when RAM section is off"]
            #[allow(non_snake_case)]
            pub fn S10RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 26;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 27) Keep retention on RAM section S11 when RAM section is off"]
            #[allow(non_snake_case)]
            pub fn S11RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 27;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 28) Keep retention on RAM section S12 when RAM section is off"]
            #[allow(non_snake_case)]
            pub fn S12RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 28;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 29) Keep retention on RAM section S13 when RAM section is off"]
            #[allow(non_snake_case)]
            pub fn S13RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 29;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 30) Keep retention on RAM section S14 when RAM section is off"]
            #[allow(non_snake_case)]
            pub fn S14RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 30;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 31) Keep retention on RAM section S15 when RAM section is off"]
            #[allow(non_snake_case)]
            pub fn S15RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 31;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Description cluster: RAMn power control set register"]
    pub type RAM6_POWERSET = ram6_powerset::Register;
    #[doc = "Description cluster: RAMn power control set register"]
    pub mod ram6_powerset {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0964) as *mut _
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 0) Keep RAM section S0 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S0POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 1) Keep RAM section S1 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S1POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 1;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 2) Keep RAM section S2 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S2POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 2;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 3) Keep RAM section S3 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S3POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 3;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 4) Keep RAM section S4 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S4POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 4;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 5) Keep RAM section S5 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S5POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 5;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 6) Keep RAM section S6 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S6POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 6;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 7) Keep RAM section S7 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S7POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 7;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 8) Keep RAM section S8 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S8POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 8;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 9) Keep RAM section S9 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S9POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 9;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 10) Keep RAM section S10 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S10POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 10;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 11) Keep RAM section S11 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S11POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 11;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 12) Keep RAM section S12 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S12POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 12;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 13) Keep RAM section S13 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S13POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 13;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 14) Keep RAM section S14 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S14POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 14;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 15) Keep RAM section S15 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S15POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 15;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 16) Keep retention on RAM section S0 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S0RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 16;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 17) Keep retention on RAM section S1 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S1RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 17;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 18) Keep retention on RAM section S2 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S2RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 18;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 19) Keep retention on RAM section S3 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S3RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 19;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 20) Keep retention on RAM section S4 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S4RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 20;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 21) Keep retention on RAM section S5 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S5RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 21;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 22) Keep retention on RAM section S6 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S6RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 22;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 23) Keep retention on RAM section S7 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S7RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 23;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 24) Keep retention on RAM section S8 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S8RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 24;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 25) Keep retention on RAM section S9 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S9RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 25;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 26) Keep retention on RAM section S10 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S10RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 26;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 27) Keep retention on RAM section S11 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S11RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 27;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 28) Keep retention on RAM section S12 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S12RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 28;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 29) Keep retention on RAM section S13 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S13RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 29;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 30) Keep retention on RAM section S14 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S14RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 30;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 31) Keep retention on RAM section S15 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S15RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 31;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Description cluster: RAMn power control clear register"]
    pub type RAM6_POWERCLR = ram6_powerclr::Register;
    #[doc = "Description cluster: RAMn power control clear register"]
    pub mod ram6_powerclr {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0968) as *mut _
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 0) Keep RAM section S0 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S0POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 1) Keep RAM section S1 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S1POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 1;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 2) Keep RAM section S2 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S2POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 2;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 3) Keep RAM section S3 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S3POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 3;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 4) Keep RAM section S4 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S4POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 4;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 5) Keep RAM section S5 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S5POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 5;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 6) Keep RAM section S6 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S6POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 6;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 7) Keep RAM section S7 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S7POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 7;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 8) Keep RAM section S8 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S8POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 8;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 9) Keep RAM section S9 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S9POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 9;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 10) Keep RAM section S10 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S10POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 10;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 11) Keep RAM section S11 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S11POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 11;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 12) Keep RAM section S12 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S12POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 12;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 13) Keep RAM section S13 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S13POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 13;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 14) Keep RAM section S14 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S14POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 14;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 15) Keep RAM section S15 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S15POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 15;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 16) Keep retention on RAM section S0 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S0RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 16;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 17) Keep retention on RAM section S1 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S1RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 17;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 18) Keep retention on RAM section S2 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S2RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 18;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 19) Keep retention on RAM section S3 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S3RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 19;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 20) Keep retention on RAM section S4 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S4RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 20;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 21) Keep retention on RAM section S5 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S5RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 21;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 22) Keep retention on RAM section S6 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S6RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 22;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 23) Keep retention on RAM section S7 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S7RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 23;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 24) Keep retention on RAM section S8 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S8RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 24;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 25) Keep retention on RAM section S9 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S9RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 25;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 26) Keep retention on RAM section S10 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S10RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 26;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 27) Keep retention on RAM section S11 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S11RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 27;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 28) Keep retention on RAM section S12 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S12RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 28;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 29) Keep retention on RAM section S13 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S13RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 29;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 30) Keep retention on RAM section S14 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S14RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 30;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 31) Keep retention on RAM section S15 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S15RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 31;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Description cluster: RAMn power control register"]
    pub type RAM7_POWER = ram7_power::Register;
    #[doc = "Description cluster: RAMn power control register"]
    pub mod ram7_power {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0970) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bit 0) Keep RAM section S0 on or off in System ON mode."]
            pub fn S0POWER(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 1) Keep RAM section S1 on or off in System ON mode."]
            pub fn S1POWER(self) -> u8 {
                const OFFSET: u8 = 1;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 2) Keep RAM section S2 on or off in System ON mode."]
            pub fn S2POWER(self) -> u8 {
                const OFFSET: u8 = 2;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 3) Keep RAM section S3 on or off in System ON mode."]
            pub fn S3POWER(self) -> u8 {
                const OFFSET: u8 = 3;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 4) Keep RAM section S4 on or off in System ON mode."]
            pub fn S4POWER(self) -> u8 {
                const OFFSET: u8 = 4;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 5) Keep RAM section S5 on or off in System ON mode."]
            pub fn S5POWER(self) -> u8 {
                const OFFSET: u8 = 5;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 6) Keep RAM section S6 on or off in System ON mode."]
            pub fn S6POWER(self) -> u8 {
                const OFFSET: u8 = 6;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 7) Keep RAM section S7 on or off in System ON mode."]
            pub fn S7POWER(self) -> u8 {
                const OFFSET: u8 = 7;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 8) Keep RAM section S8 on or off in System ON mode."]
            pub fn S8POWER(self) -> u8 {
                const OFFSET: u8 = 8;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 9) Keep RAM section S9 on or off in System ON mode."]
            pub fn S9POWER(self) -> u8 {
                const OFFSET: u8 = 9;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 10) Keep RAM section S10 on or off in System ON mode."]
            pub fn S10POWER(self) -> u8 {
                const OFFSET: u8 = 10;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 11) Keep RAM section S11 on or off in System ON mode."]
            pub fn S11POWER(self) -> u8 {
                const OFFSET: u8 = 11;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 12) Keep RAM section S12 on or off in System ON mode."]
            pub fn S12POWER(self) -> u8 {
                const OFFSET: u8 = 12;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 13) Keep RAM section S13 on or off in System ON mode."]
            pub fn S13POWER(self) -> u8 {
                const OFFSET: u8 = 13;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 14) Keep RAM section S14 on or off in System ON mode."]
            pub fn S14POWER(self) -> u8 {
                const OFFSET: u8 = 14;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 15) Keep RAM section S15 on or off in System ON mode."]
            pub fn S15POWER(self) -> u8 {
                const OFFSET: u8 = 15;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 16) Keep retention on RAM section S0 when RAM section is off"]
            pub fn S0RETENTION(self) -> u8 {
                const OFFSET: u8 = 16;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 17) Keep retention on RAM section S1 when RAM section is off"]
            pub fn S1RETENTION(self) -> u8 {
                const OFFSET: u8 = 17;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 18) Keep retention on RAM section S2 when RAM section is off"]
            pub fn S2RETENTION(self) -> u8 {
                const OFFSET: u8 = 18;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 19) Keep retention on RAM section S3 when RAM section is off"]
            pub fn S3RETENTION(self) -> u8 {
                const OFFSET: u8 = 19;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 20) Keep retention on RAM section S4 when RAM section is off"]
            pub fn S4RETENTION(self) -> u8 {
                const OFFSET: u8 = 20;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 21) Keep retention on RAM section S5 when RAM section is off"]
            pub fn S5RETENTION(self) -> u8 {
                const OFFSET: u8 = 21;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 22) Keep retention on RAM section S6 when RAM section is off"]
            pub fn S6RETENTION(self) -> u8 {
                const OFFSET: u8 = 22;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 23) Keep retention on RAM section S7 when RAM section is off"]
            pub fn S7RETENTION(self) -> u8 {
                const OFFSET: u8 = 23;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 24) Keep retention on RAM section S8 when RAM section is off"]
            pub fn S8RETENTION(self) -> u8 {
                const OFFSET: u8 = 24;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 25) Keep retention on RAM section S9 when RAM section is off"]
            pub fn S9RETENTION(self) -> u8 {
                const OFFSET: u8 = 25;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 26) Keep retention on RAM section S10 when RAM section is off"]
            pub fn S10RETENTION(self) -> u8 {
                const OFFSET: u8 = 26;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 27) Keep retention on RAM section S11 when RAM section is off"]
            pub fn S11RETENTION(self) -> u8 {
                const OFFSET: u8 = 27;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 28) Keep retention on RAM section S12 when RAM section is off"]
            pub fn S12RETENTION(self) -> u8 {
                const OFFSET: u8 = 28;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 29) Keep retention on RAM section S13 when RAM section is off"]
            pub fn S13RETENTION(self) -> u8 {
                const OFFSET: u8 = 29;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 30) Keep retention on RAM section S14 when RAM section is off"]
            pub fn S14RETENTION(self) -> u8 {
                const OFFSET: u8 = 30;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 31) Keep retention on RAM section S15 when RAM section is off"]
            pub fn S15RETENTION(self) -> u8 {
                const OFFSET: u8 = 31;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u32 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "RAM7_POWER {{ S15RETENTION: {31}, S14RETENTION: {30}, S13RETENTION: {29}, S12RETENTION: {28}, S11RETENTION: {27}, S10RETENTION: {26}, S9RETENTION: {25}, S8RETENTION: {24}, S7RETENTION: {23}, S6RETENTION: {22}, S5RETENTION: {21}, S4RETENTION: {20}, S3RETENTION: {19}, S2RETENTION: {18}, S1RETENTION: {17}, S0RETENTION: {16}, S15POWER: {15}, S14POWER: {14}, S13POWER: {13}, S12POWER: {12}, S11POWER: {11}, S10POWER: {10}, S9POWER: {9}, S8POWER: {8}, S7POWER: {7}, S6POWER: {6}, S5POWER: {5}, S4POWER: {4}, S3POWER: {3}, S2POWER: {2}, S1POWER: {1}, S0POWER: {0} }}@4600285885412475727"]
                #[link_section = ".binfmt.RAM7_POWER {{ S15RETENTION: {31}, S14RETENTION: {30}, S13RETENTION: {29}, S12RETENTION: {28}, S11RETENTION: {27}, S10RETENTION: {26}, S9RETENTION: {25}, S8RETENTION: {24}, S7RETENTION: {23}, S6RETENTION: {22}, S5RETENTION: {21}, S4RETENTION: {20}, S3RETENTION: {19}, S2RETENTION: {18}, S1RETENTION: {17}, S0RETENTION: {16}, S15POWER: {15}, S14POWER: {14}, S13POWER: {13}, S12POWER: {12}, S11POWER: {11}, S10POWER: {10}, S9POWER: {9}, S8POWER: {8}, S7POWER: {7}, S6POWER: {6}, S5POWER: {5}, S4POWER: {4}, S3POWER: {3}, S2POWER: {2}, S1POWER: {1}, S0POWER: {0} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 0) Keep RAM section S0 on or off in System ON mode."]
            #[allow(non_snake_case)]
            pub fn S0POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 1) Keep RAM section S1 on or off in System ON mode."]
            #[allow(non_snake_case)]
            pub fn S1POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 1;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 2) Keep RAM section S2 on or off in System ON mode."]
            #[allow(non_snake_case)]
            pub fn S2POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 2;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 3) Keep RAM section S3 on or off in System ON mode."]
            #[allow(non_snake_case)]
            pub fn S3POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 3;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 4) Keep RAM section S4 on or off in System ON mode."]
            #[allow(non_snake_case)]
            pub fn S4POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 4;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 5) Keep RAM section S5 on or off in System ON mode."]
            #[allow(non_snake_case)]
            pub fn S5POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 5;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 6) Keep RAM section S6 on or off in System ON mode."]
            #[allow(non_snake_case)]
            pub fn S6POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 6;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 7) Keep RAM section S7 on or off in System ON mode."]
            #[allow(non_snake_case)]
            pub fn S7POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 7;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 8) Keep RAM section S8 on or off in System ON mode."]
            #[allow(non_snake_case)]
            pub fn S8POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 8;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 9) Keep RAM section S9 on or off in System ON mode."]
            #[allow(non_snake_case)]
            pub fn S9POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 9;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 10) Keep RAM section S10 on or off in System ON mode."]
            #[allow(non_snake_case)]
            pub fn S10POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 10;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 11) Keep RAM section S11 on or off in System ON mode."]
            #[allow(non_snake_case)]
            pub fn S11POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 11;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 12) Keep RAM section S12 on or off in System ON mode."]
            #[allow(non_snake_case)]
            pub fn S12POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 12;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 13) Keep RAM section S13 on or off in System ON mode."]
            #[allow(non_snake_case)]
            pub fn S13POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 13;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 14) Keep RAM section S14 on or off in System ON mode."]
            #[allow(non_snake_case)]
            pub fn S14POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 14;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 15) Keep RAM section S15 on or off in System ON mode."]
            #[allow(non_snake_case)]
            pub fn S15POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 15;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 16) Keep retention on RAM section S0 when RAM section is off"]
            #[allow(non_snake_case)]
            pub fn S0RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 16;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 17) Keep retention on RAM section S1 when RAM section is off"]
            #[allow(non_snake_case)]
            pub fn S1RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 17;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 18) Keep retention on RAM section S2 when RAM section is off"]
            #[allow(non_snake_case)]
            pub fn S2RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 18;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 19) Keep retention on RAM section S3 when RAM section is off"]
            #[allow(non_snake_case)]
            pub fn S3RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 19;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 20) Keep retention on RAM section S4 when RAM section is off"]
            #[allow(non_snake_case)]
            pub fn S4RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 20;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 21) Keep retention on RAM section S5 when RAM section is off"]
            #[allow(non_snake_case)]
            pub fn S5RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 21;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 22) Keep retention on RAM section S6 when RAM section is off"]
            #[allow(non_snake_case)]
            pub fn S6RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 22;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 23) Keep retention on RAM section S7 when RAM section is off"]
            #[allow(non_snake_case)]
            pub fn S7RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 23;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 24) Keep retention on RAM section S8 when RAM section is off"]
            #[allow(non_snake_case)]
            pub fn S8RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 24;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 25) Keep retention on RAM section S9 when RAM section is off"]
            #[allow(non_snake_case)]
            pub fn S9RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 25;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 26) Keep retention on RAM section S10 when RAM section is off"]
            #[allow(non_snake_case)]
            pub fn S10RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 26;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 27) Keep retention on RAM section S11 when RAM section is off"]
            #[allow(non_snake_case)]
            pub fn S11RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 27;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 28) Keep retention on RAM section S12 when RAM section is off"]
            #[allow(non_snake_case)]
            pub fn S12RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 28;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 29) Keep retention on RAM section S13 when RAM section is off"]
            #[allow(non_snake_case)]
            pub fn S13RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 29;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 30) Keep retention on RAM section S14 when RAM section is off"]
            #[allow(non_snake_case)]
            pub fn S14RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 30;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 31) Keep retention on RAM section S15 when RAM section is off"]
            #[allow(non_snake_case)]
            pub fn S15RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 31;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Description cluster: RAMn power control set register"]
    pub type RAM7_POWERSET = ram7_powerset::Register;
    #[doc = "Description cluster: RAMn power control set register"]
    pub mod ram7_powerset {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0974) as *mut _
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 0) Keep RAM section S0 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S0POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 1) Keep RAM section S1 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S1POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 1;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 2) Keep RAM section S2 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S2POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 2;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 3) Keep RAM section S3 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S3POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 3;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 4) Keep RAM section S4 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S4POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 4;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 5) Keep RAM section S5 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S5POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 5;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 6) Keep RAM section S6 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S6POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 6;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 7) Keep RAM section S7 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S7POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 7;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 8) Keep RAM section S8 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S8POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 8;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 9) Keep RAM section S9 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S9POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 9;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 10) Keep RAM section S10 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S10POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 10;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 11) Keep RAM section S11 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S11POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 11;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 12) Keep RAM section S12 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S12POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 12;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 13) Keep RAM section S13 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S13POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 13;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 14) Keep RAM section S14 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S14POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 14;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 15) Keep RAM section S15 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S15POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 15;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 16) Keep retention on RAM section S0 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S0RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 16;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 17) Keep retention on RAM section S1 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S1RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 17;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 18) Keep retention on RAM section S2 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S2RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 18;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 19) Keep retention on RAM section S3 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S3RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 19;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 20) Keep retention on RAM section S4 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S4RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 20;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 21) Keep retention on RAM section S5 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S5RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 21;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 22) Keep retention on RAM section S6 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S6RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 22;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 23) Keep retention on RAM section S7 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S7RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 23;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 24) Keep retention on RAM section S8 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S8RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 24;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 25) Keep retention on RAM section S9 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S9RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 25;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 26) Keep retention on RAM section S10 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S10RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 26;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 27) Keep retention on RAM section S11 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S11RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 27;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 28) Keep retention on RAM section S12 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S12RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 28;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 29) Keep retention on RAM section S13 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S13RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 29;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 30) Keep retention on RAM section S14 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S14RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 30;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 31) Keep retention on RAM section S15 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S15RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 31;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Description cluster: RAMn power control clear register"]
    pub type RAM7_POWERCLR = ram7_powerclr::Register;
    #[doc = "Description cluster: RAMn power control clear register"]
    pub mod ram7_powerclr {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0978) as *mut _
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 0) Keep RAM section S0 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S0POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 1) Keep RAM section S1 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S1POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 1;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 2) Keep RAM section S2 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S2POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 2;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 3) Keep RAM section S3 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S3POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 3;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 4) Keep RAM section S4 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S4POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 4;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 5) Keep RAM section S5 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S5POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 5;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 6) Keep RAM section S6 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S6POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 6;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 7) Keep RAM section S7 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S7POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 7;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 8) Keep RAM section S8 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S8POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 8;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 9) Keep RAM section S9 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S9POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 9;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 10) Keep RAM section S10 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S10POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 10;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 11) Keep RAM section S11 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S11POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 11;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 12) Keep RAM section S12 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S12POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 12;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 13) Keep RAM section S13 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S13POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 13;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 14) Keep RAM section S14 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S14POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 14;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 15) Keep RAM section S15 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S15POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 15;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 16) Keep retention on RAM section S0 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S0RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 16;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 17) Keep retention on RAM section S1 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S1RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 17;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 18) Keep retention on RAM section S2 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S2RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 18;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 19) Keep retention on RAM section S3 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S3RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 19;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 20) Keep retention on RAM section S4 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S4RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 20;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 21) Keep retention on RAM section S5 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S5RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 21;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 22) Keep retention on RAM section S6 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S6RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 22;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 23) Keep retention on RAM section S7 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S7RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 23;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 24) Keep retention on RAM section S8 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S8RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 24;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 25) Keep retention on RAM section S9 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S9RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 25;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 26) Keep retention on RAM section S10 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S10RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 26;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 27) Keep retention on RAM section S11 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S11RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 27;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 28) Keep retention on RAM section S12 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S12RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 28;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 29) Keep retention on RAM section S13 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S13RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 29;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 30) Keep retention on RAM section S14 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S14RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 30;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 31) Keep retention on RAM section S15 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S15RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 31;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Description cluster: RAMn power control register"]
    pub type RAM8_POWER = ram8_power::Register;
    #[doc = "Description cluster: RAMn power control register"]
    pub mod ram8_power {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0980) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bit 0) Keep RAM section S0 on or off in System ON mode."]
            pub fn S0POWER(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 1) Keep RAM section S1 on or off in System ON mode."]
            pub fn S1POWER(self) -> u8 {
                const OFFSET: u8 = 1;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 2) Keep RAM section S2 on or off in System ON mode."]
            pub fn S2POWER(self) -> u8 {
                const OFFSET: u8 = 2;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 3) Keep RAM section S3 on or off in System ON mode."]
            pub fn S3POWER(self) -> u8 {
                const OFFSET: u8 = 3;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 4) Keep RAM section S4 on or off in System ON mode."]
            pub fn S4POWER(self) -> u8 {
                const OFFSET: u8 = 4;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 5) Keep RAM section S5 on or off in System ON mode."]
            pub fn S5POWER(self) -> u8 {
                const OFFSET: u8 = 5;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 6) Keep RAM section S6 on or off in System ON mode."]
            pub fn S6POWER(self) -> u8 {
                const OFFSET: u8 = 6;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 7) Keep RAM section S7 on or off in System ON mode."]
            pub fn S7POWER(self) -> u8 {
                const OFFSET: u8 = 7;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 8) Keep RAM section S8 on or off in System ON mode."]
            pub fn S8POWER(self) -> u8 {
                const OFFSET: u8 = 8;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 9) Keep RAM section S9 on or off in System ON mode."]
            pub fn S9POWER(self) -> u8 {
                const OFFSET: u8 = 9;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 10) Keep RAM section S10 on or off in System ON mode."]
            pub fn S10POWER(self) -> u8 {
                const OFFSET: u8 = 10;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 11) Keep RAM section S11 on or off in System ON mode."]
            pub fn S11POWER(self) -> u8 {
                const OFFSET: u8 = 11;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 12) Keep RAM section S12 on or off in System ON mode."]
            pub fn S12POWER(self) -> u8 {
                const OFFSET: u8 = 12;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 13) Keep RAM section S13 on or off in System ON mode."]
            pub fn S13POWER(self) -> u8 {
                const OFFSET: u8 = 13;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 14) Keep RAM section S14 on or off in System ON mode."]
            pub fn S14POWER(self) -> u8 {
                const OFFSET: u8 = 14;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 15) Keep RAM section S15 on or off in System ON mode."]
            pub fn S15POWER(self) -> u8 {
                const OFFSET: u8 = 15;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 16) Keep retention on RAM section S0 when RAM section is off"]
            pub fn S0RETENTION(self) -> u8 {
                const OFFSET: u8 = 16;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 17) Keep retention on RAM section S1 when RAM section is off"]
            pub fn S1RETENTION(self) -> u8 {
                const OFFSET: u8 = 17;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 18) Keep retention on RAM section S2 when RAM section is off"]
            pub fn S2RETENTION(self) -> u8 {
                const OFFSET: u8 = 18;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 19) Keep retention on RAM section S3 when RAM section is off"]
            pub fn S3RETENTION(self) -> u8 {
                const OFFSET: u8 = 19;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 20) Keep retention on RAM section S4 when RAM section is off"]
            pub fn S4RETENTION(self) -> u8 {
                const OFFSET: u8 = 20;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 21) Keep retention on RAM section S5 when RAM section is off"]
            pub fn S5RETENTION(self) -> u8 {
                const OFFSET: u8 = 21;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 22) Keep retention on RAM section S6 when RAM section is off"]
            pub fn S6RETENTION(self) -> u8 {
                const OFFSET: u8 = 22;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 23) Keep retention on RAM section S7 when RAM section is off"]
            pub fn S7RETENTION(self) -> u8 {
                const OFFSET: u8 = 23;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 24) Keep retention on RAM section S8 when RAM section is off"]
            pub fn S8RETENTION(self) -> u8 {
                const OFFSET: u8 = 24;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 25) Keep retention on RAM section S9 when RAM section is off"]
            pub fn S9RETENTION(self) -> u8 {
                const OFFSET: u8 = 25;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 26) Keep retention on RAM section S10 when RAM section is off"]
            pub fn S10RETENTION(self) -> u8 {
                const OFFSET: u8 = 26;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 27) Keep retention on RAM section S11 when RAM section is off"]
            pub fn S11RETENTION(self) -> u8 {
                const OFFSET: u8 = 27;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 28) Keep retention on RAM section S12 when RAM section is off"]
            pub fn S12RETENTION(self) -> u8 {
                const OFFSET: u8 = 28;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 29) Keep retention on RAM section S13 when RAM section is off"]
            pub fn S13RETENTION(self) -> u8 {
                const OFFSET: u8 = 29;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 30) Keep retention on RAM section S14 when RAM section is off"]
            pub fn S14RETENTION(self) -> u8 {
                const OFFSET: u8 = 30;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 31) Keep retention on RAM section S15 when RAM section is off"]
            pub fn S15RETENTION(self) -> u8 {
                const OFFSET: u8 = 31;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u32 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "RAM8_POWER {{ S15RETENTION: {31}, S14RETENTION: {30}, S13RETENTION: {29}, S12RETENTION: {28}, S11RETENTION: {27}, S10RETENTION: {26}, S9RETENTION: {25}, S8RETENTION: {24}, S7RETENTION: {23}, S6RETENTION: {22}, S5RETENTION: {21}, S4RETENTION: {20}, S3RETENTION: {19}, S2RETENTION: {18}, S1RETENTION: {17}, S0RETENTION: {16}, S15POWER: {15}, S14POWER: {14}, S13POWER: {13}, S12POWER: {12}, S11POWER: {11}, S10POWER: {10}, S9POWER: {9}, S8POWER: {8}, S7POWER: {7}, S6POWER: {6}, S5POWER: {5}, S4POWER: {4}, S3POWER: {3}, S2POWER: {2}, S1POWER: {1}, S0POWER: {0} }}@12440054157383408780"]
                #[link_section = ".binfmt.RAM8_POWER {{ S15RETENTION: {31}, S14RETENTION: {30}, S13RETENTION: {29}, S12RETENTION: {28}, S11RETENTION: {27}, S10RETENTION: {26}, S9RETENTION: {25}, S8RETENTION: {24}, S7RETENTION: {23}, S6RETENTION: {22}, S5RETENTION: {21}, S4RETENTION: {20}, S3RETENTION: {19}, S2RETENTION: {18}, S1RETENTION: {17}, S0RETENTION: {16}, S15POWER: {15}, S14POWER: {14}, S13POWER: {13}, S12POWER: {12}, S11POWER: {11}, S10POWER: {10}, S9POWER: {9}, S8POWER: {8}, S7POWER: {7}, S6POWER: {6}, S5POWER: {5}, S4POWER: {4}, S3POWER: {3}, S2POWER: {2}, S1POWER: {1}, S0POWER: {0} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 0) Keep RAM section S0 on or off in System ON mode."]
            #[allow(non_snake_case)]
            pub fn S0POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 1) Keep RAM section S1 on or off in System ON mode."]
            #[allow(non_snake_case)]
            pub fn S1POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 1;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 2) Keep RAM section S2 on or off in System ON mode."]
            #[allow(non_snake_case)]
            pub fn S2POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 2;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 3) Keep RAM section S3 on or off in System ON mode."]
            #[allow(non_snake_case)]
            pub fn S3POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 3;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 4) Keep RAM section S4 on or off in System ON mode."]
            #[allow(non_snake_case)]
            pub fn S4POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 4;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 5) Keep RAM section S5 on or off in System ON mode."]
            #[allow(non_snake_case)]
            pub fn S5POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 5;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 6) Keep RAM section S6 on or off in System ON mode."]
            #[allow(non_snake_case)]
            pub fn S6POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 6;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 7) Keep RAM section S7 on or off in System ON mode."]
            #[allow(non_snake_case)]
            pub fn S7POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 7;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 8) Keep RAM section S8 on or off in System ON mode."]
            #[allow(non_snake_case)]
            pub fn S8POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 8;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 9) Keep RAM section S9 on or off in System ON mode."]
            #[allow(non_snake_case)]
            pub fn S9POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 9;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 10) Keep RAM section S10 on or off in System ON mode."]
            #[allow(non_snake_case)]
            pub fn S10POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 10;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 11) Keep RAM section S11 on or off in System ON mode."]
            #[allow(non_snake_case)]
            pub fn S11POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 11;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 12) Keep RAM section S12 on or off in System ON mode."]
            #[allow(non_snake_case)]
            pub fn S12POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 12;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 13) Keep RAM section S13 on or off in System ON mode."]
            #[allow(non_snake_case)]
            pub fn S13POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 13;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 14) Keep RAM section S14 on or off in System ON mode."]
            #[allow(non_snake_case)]
            pub fn S14POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 14;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 15) Keep RAM section S15 on or off in System ON mode."]
            #[allow(non_snake_case)]
            pub fn S15POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 15;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 16) Keep retention on RAM section S0 when RAM section is off"]
            #[allow(non_snake_case)]
            pub fn S0RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 16;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 17) Keep retention on RAM section S1 when RAM section is off"]
            #[allow(non_snake_case)]
            pub fn S1RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 17;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 18) Keep retention on RAM section S2 when RAM section is off"]
            #[allow(non_snake_case)]
            pub fn S2RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 18;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 19) Keep retention on RAM section S3 when RAM section is off"]
            #[allow(non_snake_case)]
            pub fn S3RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 19;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 20) Keep retention on RAM section S4 when RAM section is off"]
            #[allow(non_snake_case)]
            pub fn S4RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 20;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 21) Keep retention on RAM section S5 when RAM section is off"]
            #[allow(non_snake_case)]
            pub fn S5RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 21;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 22) Keep retention on RAM section S6 when RAM section is off"]
            #[allow(non_snake_case)]
            pub fn S6RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 22;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 23) Keep retention on RAM section S7 when RAM section is off"]
            #[allow(non_snake_case)]
            pub fn S7RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 23;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 24) Keep retention on RAM section S8 when RAM section is off"]
            #[allow(non_snake_case)]
            pub fn S8RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 24;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 25) Keep retention on RAM section S9 when RAM section is off"]
            #[allow(non_snake_case)]
            pub fn S9RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 25;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 26) Keep retention on RAM section S10 when RAM section is off"]
            #[allow(non_snake_case)]
            pub fn S10RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 26;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 27) Keep retention on RAM section S11 when RAM section is off"]
            #[allow(non_snake_case)]
            pub fn S11RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 27;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 28) Keep retention on RAM section S12 when RAM section is off"]
            #[allow(non_snake_case)]
            pub fn S12RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 28;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 29) Keep retention on RAM section S13 when RAM section is off"]
            #[allow(non_snake_case)]
            pub fn S13RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 29;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 30) Keep retention on RAM section S14 when RAM section is off"]
            #[allow(non_snake_case)]
            pub fn S14RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 30;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 31) Keep retention on RAM section S15 when RAM section is off"]
            #[allow(non_snake_case)]
            pub fn S15RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 31;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Description cluster: RAMn power control set register"]
    pub type RAM8_POWERSET = ram8_powerset::Register;
    #[doc = "Description cluster: RAMn power control set register"]
    pub mod ram8_powerset {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0984) as *mut _
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 0) Keep RAM section S0 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S0POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 1) Keep RAM section S1 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S1POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 1;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 2) Keep RAM section S2 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S2POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 2;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 3) Keep RAM section S3 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S3POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 3;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 4) Keep RAM section S4 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S4POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 4;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 5) Keep RAM section S5 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S5POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 5;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 6) Keep RAM section S6 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S6POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 6;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 7) Keep RAM section S7 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S7POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 7;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 8) Keep RAM section S8 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S8POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 8;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 9) Keep RAM section S9 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S9POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 9;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 10) Keep RAM section S10 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S10POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 10;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 11) Keep RAM section S11 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S11POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 11;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 12) Keep RAM section S12 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S12POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 12;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 13) Keep RAM section S13 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S13POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 13;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 14) Keep RAM section S14 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S14POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 14;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 15) Keep RAM section S15 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S15POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 15;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 16) Keep retention on RAM section S0 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S0RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 16;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 17) Keep retention on RAM section S1 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S1RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 17;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 18) Keep retention on RAM section S2 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S2RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 18;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 19) Keep retention on RAM section S3 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S3RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 19;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 20) Keep retention on RAM section S4 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S4RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 20;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 21) Keep retention on RAM section S5 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S5RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 21;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 22) Keep retention on RAM section S6 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S6RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 22;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 23) Keep retention on RAM section S7 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S7RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 23;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 24) Keep retention on RAM section S8 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S8RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 24;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 25) Keep retention on RAM section S9 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S9RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 25;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 26) Keep retention on RAM section S10 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S10RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 26;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 27) Keep retention on RAM section S11 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S11RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 27;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 28) Keep retention on RAM section S12 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S12RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 28;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 29) Keep retention on RAM section S13 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S13RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 29;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 30) Keep retention on RAM section S14 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S14RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 30;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 31) Keep retention on RAM section S15 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S15RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 31;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Description cluster: RAMn power control clear register"]
    pub type RAM8_POWERCLR = ram8_powerclr::Register;
    #[doc = "Description cluster: RAMn power control clear register"]
    pub mod ram8_powerclr {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0988) as *mut _
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 0) Keep RAM section S0 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S0POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 1) Keep RAM section S1 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S1POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 1;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 2) Keep RAM section S2 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S2POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 2;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 3) Keep RAM section S3 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S3POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 3;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 4) Keep RAM section S4 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S4POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 4;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 5) Keep RAM section S5 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S5POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 5;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 6) Keep RAM section S6 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S6POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 6;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 7) Keep RAM section S7 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S7POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 7;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 8) Keep RAM section S8 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S8POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 8;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 9) Keep RAM section S9 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S9POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 9;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 10) Keep RAM section S10 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S10POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 10;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 11) Keep RAM section S11 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S11POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 11;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 12) Keep RAM section S12 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S12POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 12;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 13) Keep RAM section S13 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S13POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 13;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 14) Keep RAM section S14 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S14POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 14;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 15) Keep RAM section S15 of RAMn on or off in System ON mode"]
            #[allow(non_snake_case)]
            pub fn S15POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 15;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 16) Keep retention on RAM section S0 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S0RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 16;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 17) Keep retention on RAM section S1 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S1RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 17;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 18) Keep retention on RAM section S2 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S2RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 18;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 19) Keep retention on RAM section S3 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S3RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 19;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 20) Keep retention on RAM section S4 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S4RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 20;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 21) Keep retention on RAM section S5 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S5RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 21;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 22) Keep retention on RAM section S6 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S6RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 22;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 23) Keep retention on RAM section S7 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S7RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 23;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 24) Keep retention on RAM section S8 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S8RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 24;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 25) Keep retention on RAM section S9 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S9RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 25;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 26) Keep retention on RAM section S10 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S10RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 26;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 27) Keep retention on RAM section S11 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S11RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 27;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 28) Keep retention on RAM section S12 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S12RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 28;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 29) Keep retention on RAM section S13 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S13RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 29;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 30) Keep retention on RAM section S14 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S14RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 30;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 31) Keep retention on RAM section S15 when RAM section is switched off"]
            #[allow(non_snake_case)]
            pub fn S15RETENTION(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 31;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
    }
    use core::sync::atomic::{AtomicBool, Ordering};
    const BASE_ADDRESS: usize = 0x4000_0000;
    #[allow(non_snake_case)]
    #[doc = "Singleton handle to the POWER registers"]
    pub struct Registers {
        #[doc = "Enable Constant Latency mode"]
        pub TASKS_CONSTLAT: TASKS_CONSTLAT,
        #[doc = "Enable Low-power mode (variable latency)"]
        pub TASKS_LOWPWR: TASKS_LOWPWR,
        #[doc = "Power failure warning"]
        pub EVENTS_POFWARN: EVENTS_POFWARN,
        #[doc = "CPU entered WFI/WFE sleep"]
        pub EVENTS_SLEEPENTER: EVENTS_SLEEPENTER,
        #[doc = "CPU exited WFI/WFE sleep"]
        pub EVENTS_SLEEPEXIT: EVENTS_SLEEPEXIT,
        #[doc = "Voltage supply detected on VBUS"]
        pub EVENTS_USBDETECTED: EVENTS_USBDETECTED,
        #[doc = "Voltage supply removed from VBUS"]
        pub EVENTS_USBREMOVED: EVENTS_USBREMOVED,
        #[doc = "USB 3.3 V supply ready"]
        pub EVENTS_USBPWRRDY: EVENTS_USBPWRRDY,
        #[doc = "Enable interrupt"]
        pub INTENSET: INTENSET,
        #[doc = "Disable interrupt"]
        pub INTENCLR: INTENCLR,
        #[doc = "Reset reason"]
        pub RESETREAS: RESETREAS,
        #[doc = "Deprecated register - RAM status register"]
        pub RAMSTATUS: RAMSTATUS,
        #[doc = "USB supply status"]
        pub USBREGSTATUS: USBREGSTATUS,
        #[doc = "System OFF register"]
        pub SYSTEMOFF: SYSTEMOFF,
        #[doc = "Power-fail comparator configuration"]
        pub POFCON: POFCON,
        #[doc = "General purpose retention register"]
        pub GPREGRET: GPREGRET,
        #[doc = "General purpose retention register"]
        pub GPREGRET2: GPREGRET2,
        #[doc = "Enable DC/DC converter for REG1 stage"]
        pub DCDCEN: DCDCEN,
        #[doc = "Enable DC/DC converter for REG0 stage"]
        pub DCDCEN0: DCDCEN0,
        #[doc = "Main supply status"]
        pub MAINREGSTATUS: MAINREGSTATUS,
        #[doc = "Description cluster: RAMn power control register"]
        pub RAM0_POWER: RAM0_POWER,
        #[doc = "Description cluster: RAMn power control set register"]
        pub RAM0_POWERSET: RAM0_POWERSET,
        #[doc = "Description cluster: RAMn power control clear register"]
        pub RAM0_POWERCLR: RAM0_POWERCLR,
        #[doc = "Description cluster: RAMn power control register"]
        pub RAM1_POWER: RAM1_POWER,
        #[doc = "Description cluster: RAMn power control set register"]
        pub RAM1_POWERSET: RAM1_POWERSET,
        #[doc = "Description cluster: RAMn power control clear register"]
        pub RAM1_POWERCLR: RAM1_POWERCLR,
        #[doc = "Description cluster: RAMn power control register"]
        pub RAM2_POWER: RAM2_POWER,
        #[doc = "Description cluster: RAMn power control set register"]
        pub RAM2_POWERSET: RAM2_POWERSET,
        #[doc = "Description cluster: RAMn power control clear register"]
        pub RAM2_POWERCLR: RAM2_POWERCLR,
        #[doc = "Description cluster: RAMn power control register"]
        pub RAM3_POWER: RAM3_POWER,
        #[doc = "Description cluster: RAMn power control set register"]
        pub RAM3_POWERSET: RAM3_POWERSET,
        #[doc = "Description cluster: RAMn power control clear register"]
        pub RAM3_POWERCLR: RAM3_POWERCLR,
        #[doc = "Description cluster: RAMn power control register"]
        pub RAM4_POWER: RAM4_POWER,
        #[doc = "Description cluster: RAMn power control set register"]
        pub RAM4_POWERSET: RAM4_POWERSET,
        #[doc = "Description cluster: RAMn power control clear register"]
        pub RAM4_POWERCLR: RAM4_POWERCLR,
        #[doc = "Description cluster: RAMn power control register"]
        pub RAM5_POWER: RAM5_POWER,
        #[doc = "Description cluster: RAMn power control set register"]
        pub RAM5_POWERSET: RAM5_POWERSET,
        #[doc = "Description cluster: RAMn power control clear register"]
        pub RAM5_POWERCLR: RAM5_POWERCLR,
        #[doc = "Description cluster: RAMn power control register"]
        pub RAM6_POWER: RAM6_POWER,
        #[doc = "Description cluster: RAMn power control set register"]
        pub RAM6_POWERSET: RAM6_POWERSET,
        #[doc = "Description cluster: RAMn power control clear register"]
        pub RAM6_POWERCLR: RAM6_POWERCLR,
        #[doc = "Description cluster: RAMn power control register"]
        pub RAM7_POWER: RAM7_POWER,
        #[doc = "Description cluster: RAMn power control set register"]
        pub RAM7_POWERSET: RAM7_POWERSET,
        #[doc = "Description cluster: RAMn power control clear register"]
        pub RAM7_POWERCLR: RAM7_POWERCLR,
        #[doc = "Description cluster: RAMn power control register"]
        pub RAM8_POWER: RAM8_POWER,
        #[doc = "Description cluster: RAMn power control set register"]
        pub RAM8_POWERSET: RAM8_POWERSET,
        #[doc = "Description cluster: RAMn power control clear register"]
        pub RAM8_POWERCLR: RAM8_POWERCLR,
    }
    unsafe impl Send for Registers {}
    impl Registers {
        #[doc = r" # Safety"]
        #[doc = r" Singleton"]
        unsafe fn new() -> Self {
            Self {
                TASKS_CONSTLAT: TASKS_CONSTLAT::new(),
                TASKS_LOWPWR: TASKS_LOWPWR::new(),
                EVENTS_POFWARN: EVENTS_POFWARN::new(),
                EVENTS_SLEEPENTER: EVENTS_SLEEPENTER::new(),
                EVENTS_SLEEPEXIT: EVENTS_SLEEPEXIT::new(),
                EVENTS_USBDETECTED: EVENTS_USBDETECTED::new(),
                EVENTS_USBREMOVED: EVENTS_USBREMOVED::new(),
                EVENTS_USBPWRRDY: EVENTS_USBPWRRDY::new(),
                INTENSET: INTENSET::new(),
                INTENCLR: INTENCLR::new(),
                RESETREAS: RESETREAS::new(),
                RAMSTATUS: RAMSTATUS::new(),
                USBREGSTATUS: USBREGSTATUS::new(),
                SYSTEMOFF: SYSTEMOFF::new(),
                POFCON: POFCON::new(),
                GPREGRET: GPREGRET::new(),
                GPREGRET2: GPREGRET2::new(),
                DCDCEN: DCDCEN::new(),
                DCDCEN0: DCDCEN0::new(),
                MAINREGSTATUS: MAINREGSTATUS::new(),
                RAM0_POWER: RAM0_POWER::new(),
                RAM0_POWERSET: RAM0_POWERSET::new(),
                RAM0_POWERCLR: RAM0_POWERCLR::new(),
                RAM1_POWER: RAM1_POWER::new(),
                RAM1_POWERSET: RAM1_POWERSET::new(),
                RAM1_POWERCLR: RAM1_POWERCLR::new(),
                RAM2_POWER: RAM2_POWER::new(),
                RAM2_POWERSET: RAM2_POWERSET::new(),
                RAM2_POWERCLR: RAM2_POWERCLR::new(),
                RAM3_POWER: RAM3_POWER::new(),
                RAM3_POWERSET: RAM3_POWERSET::new(),
                RAM3_POWERCLR: RAM3_POWERCLR::new(),
                RAM4_POWER: RAM4_POWER::new(),
                RAM4_POWERSET: RAM4_POWERSET::new(),
                RAM4_POWERCLR: RAM4_POWERCLR::new(),
                RAM5_POWER: RAM5_POWER::new(),
                RAM5_POWERSET: RAM5_POWERSET::new(),
                RAM5_POWERCLR: RAM5_POWERCLR::new(),
                RAM6_POWER: RAM6_POWER::new(),
                RAM6_POWERSET: RAM6_POWERSET::new(),
                RAM6_POWERCLR: RAM6_POWERCLR::new(),
                RAM7_POWER: RAM7_POWER::new(),
                RAM7_POWERSET: RAM7_POWERSET::new(),
                RAM7_POWERCLR: RAM7_POWERCLR::new(),
                RAM8_POWER: RAM8_POWER::new(),
                RAM8_POWERSET: RAM8_POWERSET::new(),
                RAM8_POWERCLR: RAM8_POWERCLR::new(),
            }
        }
        fn taken() -> &'static AtomicBool {
            static TAKEN: AtomicBool = AtomicBool::new(false);
            &TAKEN
        }
        #[doc = r" Grants temporary access to the peripheral, without checking if it has already been"]
        #[doc = r" taken"]
        #[inline(always)]
        pub fn borrow_unchecked<T>(f: impl FnOnce(&Self) -> T) -> T {
            f(unsafe { &Self::new() })
        }
        #[doc = r" Seals the peripheral making it impossible to `take` it"]
        pub fn seal() {
            Self::taken().store(true, Ordering::Relaxed)
        }
        #[doc = r" Takes ownership of the peripheral"]
        #[doc = r""]
        #[doc = r" This constructor returns the `Some` variant only once"]
        pub fn take() -> Option<Self> {
            let taken = Self::taken();
            if taken
                .compare_exchange(false, true, Ordering::Relaxed, Ordering::Relaxed)
                .is_ok()
            {
                Some(unsafe { Self::new() })
            } else {
                None
            }
        }
    }
}
#[allow(non_camel_case_types)]
#[cfg(feature = "P0")]
#[doc = "GPIO Port 1"]
pub type P0 = p0::Registers;
#[cfg(feature = "P0")]
#[doc = "GPIO Port 1"]
pub mod p0 {
    #[allow(non_camel_case_types)]
    #[doc = "Write GPIO port"]
    pub type OUT = out::Register;
    #[doc = "Write GPIO port"]
    pub mod out {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0504) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bit 0) Pin 0"]
            pub fn PIN0(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 1) Pin 1"]
            pub fn PIN1(self) -> u8 {
                const OFFSET: u8 = 1;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 2) Pin 2"]
            pub fn PIN2(self) -> u8 {
                const OFFSET: u8 = 2;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 3) Pin 3"]
            pub fn PIN3(self) -> u8 {
                const OFFSET: u8 = 3;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 4) Pin 4"]
            pub fn PIN4(self) -> u8 {
                const OFFSET: u8 = 4;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 5) Pin 5"]
            pub fn PIN5(self) -> u8 {
                const OFFSET: u8 = 5;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 6) Pin 6"]
            pub fn PIN6(self) -> u8 {
                const OFFSET: u8 = 6;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 7) Pin 7"]
            pub fn PIN7(self) -> u8 {
                const OFFSET: u8 = 7;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 8) Pin 8"]
            pub fn PIN8(self) -> u8 {
                const OFFSET: u8 = 8;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 9) Pin 9"]
            pub fn PIN9(self) -> u8 {
                const OFFSET: u8 = 9;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 10) Pin 10"]
            pub fn PIN10(self) -> u8 {
                const OFFSET: u8 = 10;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 11) Pin 11"]
            pub fn PIN11(self) -> u8 {
                const OFFSET: u8 = 11;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 12) Pin 12"]
            pub fn PIN12(self) -> u8 {
                const OFFSET: u8 = 12;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 13) Pin 13"]
            pub fn PIN13(self) -> u8 {
                const OFFSET: u8 = 13;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 14) Pin 14"]
            pub fn PIN14(self) -> u8 {
                const OFFSET: u8 = 14;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 15) Pin 15"]
            pub fn PIN15(self) -> u8 {
                const OFFSET: u8 = 15;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 16) Pin 16"]
            pub fn PIN16(self) -> u8 {
                const OFFSET: u8 = 16;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 17) Pin 17"]
            pub fn PIN17(self) -> u8 {
                const OFFSET: u8 = 17;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 18) Pin 18"]
            pub fn PIN18(self) -> u8 {
                const OFFSET: u8 = 18;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 19) Pin 19"]
            pub fn PIN19(self) -> u8 {
                const OFFSET: u8 = 19;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 20) Pin 20"]
            pub fn PIN20(self) -> u8 {
                const OFFSET: u8 = 20;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 21) Pin 21"]
            pub fn PIN21(self) -> u8 {
                const OFFSET: u8 = 21;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 22) Pin 22"]
            pub fn PIN22(self) -> u8 {
                const OFFSET: u8 = 22;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 23) Pin 23"]
            pub fn PIN23(self) -> u8 {
                const OFFSET: u8 = 23;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 24) Pin 24"]
            pub fn PIN24(self) -> u8 {
                const OFFSET: u8 = 24;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 25) Pin 25"]
            pub fn PIN25(self) -> u8 {
                const OFFSET: u8 = 25;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 26) Pin 26"]
            pub fn PIN26(self) -> u8 {
                const OFFSET: u8 = 26;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 27) Pin 27"]
            pub fn PIN27(self) -> u8 {
                const OFFSET: u8 = 27;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 28) Pin 28"]
            pub fn PIN28(self) -> u8 {
                const OFFSET: u8 = 28;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 29) Pin 29"]
            pub fn PIN29(self) -> u8 {
                const OFFSET: u8 = 29;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 30) Pin 30"]
            pub fn PIN30(self) -> u8 {
                const OFFSET: u8 = 30;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 31) Pin 31"]
            pub fn PIN31(self) -> u8 {
                const OFFSET: u8 = 31;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u32 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "OUT {{ PIN31: {31}, PIN30: {30}, PIN29: {29}, PIN28: {28}, PIN27: {27}, PIN26: {26}, PIN25: {25}, PIN24: {24}, PIN23: {23}, PIN22: {22}, PIN21: {21}, PIN20: {20}, PIN19: {19}, PIN18: {18}, PIN17: {17}, PIN16: {16}, PIN15: {15}, PIN14: {14}, PIN13: {13}, PIN12: {12}, PIN11: {11}, PIN10: {10}, PIN9: {9}, PIN8: {8}, PIN7: {7}, PIN6: {6}, PIN5: {5}, PIN4: {4}, PIN3: {3}, PIN2: {2}, PIN1: {1}, PIN0: {0} }}@10515774924038194936"]
                #[link_section = ".binfmt.OUT {{ PIN31: {31}, PIN30: {30}, PIN29: {29}, PIN28: {28}, PIN27: {27}, PIN26: {26}, PIN25: {25}, PIN24: {24}, PIN23: {23}, PIN22: {22}, PIN21: {21}, PIN20: {20}, PIN19: {19}, PIN18: {18}, PIN17: {17}, PIN16: {16}, PIN15: {15}, PIN14: {14}, PIN13: {13}, PIN12: {12}, PIN11: {11}, PIN10: {10}, PIN9: {9}, PIN8: {8}, PIN7: {7}, PIN6: {6}, PIN5: {5}, PIN4: {4}, PIN3: {3}, PIN2: {2}, PIN1: {1}, PIN0: {0} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 0) Pin 0"]
            #[allow(non_snake_case)]
            pub fn PIN0(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 1) Pin 1"]
            #[allow(non_snake_case)]
            pub fn PIN1(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 1;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 2) Pin 2"]
            #[allow(non_snake_case)]
            pub fn PIN2(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 2;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 3) Pin 3"]
            #[allow(non_snake_case)]
            pub fn PIN3(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 3;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 4) Pin 4"]
            #[allow(non_snake_case)]
            pub fn PIN4(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 4;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 5) Pin 5"]
            #[allow(non_snake_case)]
            pub fn PIN5(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 5;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 6) Pin 6"]
            #[allow(non_snake_case)]
            pub fn PIN6(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 6;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 7) Pin 7"]
            #[allow(non_snake_case)]
            pub fn PIN7(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 7;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 8) Pin 8"]
            #[allow(non_snake_case)]
            pub fn PIN8(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 8;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 9) Pin 9"]
            #[allow(non_snake_case)]
            pub fn PIN9(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 9;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 10) Pin 10"]
            #[allow(non_snake_case)]
            pub fn PIN10(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 10;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 11) Pin 11"]
            #[allow(non_snake_case)]
            pub fn PIN11(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 11;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 12) Pin 12"]
            #[allow(non_snake_case)]
            pub fn PIN12(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 12;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 13) Pin 13"]
            #[allow(non_snake_case)]
            pub fn PIN13(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 13;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 14) Pin 14"]
            #[allow(non_snake_case)]
            pub fn PIN14(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 14;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 15) Pin 15"]
            #[allow(non_snake_case)]
            pub fn PIN15(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 15;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 16) Pin 16"]
            #[allow(non_snake_case)]
            pub fn PIN16(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 16;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 17) Pin 17"]
            #[allow(non_snake_case)]
            pub fn PIN17(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 17;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 18) Pin 18"]
            #[allow(non_snake_case)]
            pub fn PIN18(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 18;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 19) Pin 19"]
            #[allow(non_snake_case)]
            pub fn PIN19(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 19;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 20) Pin 20"]
            #[allow(non_snake_case)]
            pub fn PIN20(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 20;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 21) Pin 21"]
            #[allow(non_snake_case)]
            pub fn PIN21(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 21;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 22) Pin 22"]
            #[allow(non_snake_case)]
            pub fn PIN22(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 22;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 23) Pin 23"]
            #[allow(non_snake_case)]
            pub fn PIN23(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 23;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 24) Pin 24"]
            #[allow(non_snake_case)]
            pub fn PIN24(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 24;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 25) Pin 25"]
            #[allow(non_snake_case)]
            pub fn PIN25(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 25;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 26) Pin 26"]
            #[allow(non_snake_case)]
            pub fn PIN26(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 26;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 27) Pin 27"]
            #[allow(non_snake_case)]
            pub fn PIN27(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 27;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 28) Pin 28"]
            #[allow(non_snake_case)]
            pub fn PIN28(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 28;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 29) Pin 29"]
            #[allow(non_snake_case)]
            pub fn PIN29(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 29;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 30) Pin 30"]
            #[allow(non_snake_case)]
            pub fn PIN30(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 30;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 31) Pin 31"]
            #[allow(non_snake_case)]
            pub fn PIN31(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 31;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Set individual bits in GPIO port"]
    pub type OUTSET = outset::Register;
    #[doc = "Set individual bits in GPIO port"]
    pub mod outset {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0508) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bit 0) Pin 0"]
            pub fn PIN0(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 1) Pin 1"]
            pub fn PIN1(self) -> u8 {
                const OFFSET: u8 = 1;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 2) Pin 2"]
            pub fn PIN2(self) -> u8 {
                const OFFSET: u8 = 2;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 3) Pin 3"]
            pub fn PIN3(self) -> u8 {
                const OFFSET: u8 = 3;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 4) Pin 4"]
            pub fn PIN4(self) -> u8 {
                const OFFSET: u8 = 4;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 5) Pin 5"]
            pub fn PIN5(self) -> u8 {
                const OFFSET: u8 = 5;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 6) Pin 6"]
            pub fn PIN6(self) -> u8 {
                const OFFSET: u8 = 6;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 7) Pin 7"]
            pub fn PIN7(self) -> u8 {
                const OFFSET: u8 = 7;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 8) Pin 8"]
            pub fn PIN8(self) -> u8 {
                const OFFSET: u8 = 8;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 9) Pin 9"]
            pub fn PIN9(self) -> u8 {
                const OFFSET: u8 = 9;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 10) Pin 10"]
            pub fn PIN10(self) -> u8 {
                const OFFSET: u8 = 10;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 11) Pin 11"]
            pub fn PIN11(self) -> u8 {
                const OFFSET: u8 = 11;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 12) Pin 12"]
            pub fn PIN12(self) -> u8 {
                const OFFSET: u8 = 12;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 13) Pin 13"]
            pub fn PIN13(self) -> u8 {
                const OFFSET: u8 = 13;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 14) Pin 14"]
            pub fn PIN14(self) -> u8 {
                const OFFSET: u8 = 14;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 15) Pin 15"]
            pub fn PIN15(self) -> u8 {
                const OFFSET: u8 = 15;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 16) Pin 16"]
            pub fn PIN16(self) -> u8 {
                const OFFSET: u8 = 16;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 17) Pin 17"]
            pub fn PIN17(self) -> u8 {
                const OFFSET: u8 = 17;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 18) Pin 18"]
            pub fn PIN18(self) -> u8 {
                const OFFSET: u8 = 18;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 19) Pin 19"]
            pub fn PIN19(self) -> u8 {
                const OFFSET: u8 = 19;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 20) Pin 20"]
            pub fn PIN20(self) -> u8 {
                const OFFSET: u8 = 20;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 21) Pin 21"]
            pub fn PIN21(self) -> u8 {
                const OFFSET: u8 = 21;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 22) Pin 22"]
            pub fn PIN22(self) -> u8 {
                const OFFSET: u8 = 22;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 23) Pin 23"]
            pub fn PIN23(self) -> u8 {
                const OFFSET: u8 = 23;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 24) Pin 24"]
            pub fn PIN24(self) -> u8 {
                const OFFSET: u8 = 24;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 25) Pin 25"]
            pub fn PIN25(self) -> u8 {
                const OFFSET: u8 = 25;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 26) Pin 26"]
            pub fn PIN26(self) -> u8 {
                const OFFSET: u8 = 26;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 27) Pin 27"]
            pub fn PIN27(self) -> u8 {
                const OFFSET: u8 = 27;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 28) Pin 28"]
            pub fn PIN28(self) -> u8 {
                const OFFSET: u8 = 28;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 29) Pin 29"]
            pub fn PIN29(self) -> u8 {
                const OFFSET: u8 = 29;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 30) Pin 30"]
            pub fn PIN30(self) -> u8 {
                const OFFSET: u8 = 30;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 31) Pin 31"]
            pub fn PIN31(self) -> u8 {
                const OFFSET: u8 = 31;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u32 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "OUTSET {{ PIN31: {31}, PIN30: {30}, PIN29: {29}, PIN28: {28}, PIN27: {27}, PIN26: {26}, PIN25: {25}, PIN24: {24}, PIN23: {23}, PIN22: {22}, PIN21: {21}, PIN20: {20}, PIN19: {19}, PIN18: {18}, PIN17: {17}, PIN16: {16}, PIN15: {15}, PIN14: {14}, PIN13: {13}, PIN12: {12}, PIN11: {11}, PIN10: {10}, PIN9: {9}, PIN8: {8}, PIN7: {7}, PIN6: {6}, PIN5: {5}, PIN4: {4}, PIN3: {3}, PIN2: {2}, PIN1: {1}, PIN0: {0} }}@276385035402082009"]
                #[link_section = ".binfmt.OUTSET {{ PIN31: {31}, PIN30: {30}, PIN29: {29}, PIN28: {28}, PIN27: {27}, PIN26: {26}, PIN25: {25}, PIN24: {24}, PIN23: {23}, PIN22: {22}, PIN21: {21}, PIN20: {20}, PIN19: {19}, PIN18: {18}, PIN17: {17}, PIN16: {16}, PIN15: {15}, PIN14: {14}, PIN13: {13}, PIN12: {12}, PIN11: {11}, PIN10: {10}, PIN9: {9}, PIN8: {8}, PIN7: {7}, PIN6: {6}, PIN5: {5}, PIN4: {4}, PIN3: {3}, PIN2: {2}, PIN1: {1}, PIN0: {0} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 0) Pin 0"]
            #[allow(non_snake_case)]
            pub fn PIN0(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 1) Pin 1"]
            #[allow(non_snake_case)]
            pub fn PIN1(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 1;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 2) Pin 2"]
            #[allow(non_snake_case)]
            pub fn PIN2(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 2;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 3) Pin 3"]
            #[allow(non_snake_case)]
            pub fn PIN3(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 3;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 4) Pin 4"]
            #[allow(non_snake_case)]
            pub fn PIN4(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 4;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 5) Pin 5"]
            #[allow(non_snake_case)]
            pub fn PIN5(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 5;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 6) Pin 6"]
            #[allow(non_snake_case)]
            pub fn PIN6(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 6;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 7) Pin 7"]
            #[allow(non_snake_case)]
            pub fn PIN7(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 7;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 8) Pin 8"]
            #[allow(non_snake_case)]
            pub fn PIN8(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 8;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 9) Pin 9"]
            #[allow(non_snake_case)]
            pub fn PIN9(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 9;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 10) Pin 10"]
            #[allow(non_snake_case)]
            pub fn PIN10(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 10;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 11) Pin 11"]
            #[allow(non_snake_case)]
            pub fn PIN11(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 11;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 12) Pin 12"]
            #[allow(non_snake_case)]
            pub fn PIN12(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 12;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 13) Pin 13"]
            #[allow(non_snake_case)]
            pub fn PIN13(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 13;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 14) Pin 14"]
            #[allow(non_snake_case)]
            pub fn PIN14(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 14;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 15) Pin 15"]
            #[allow(non_snake_case)]
            pub fn PIN15(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 15;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 16) Pin 16"]
            #[allow(non_snake_case)]
            pub fn PIN16(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 16;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 17) Pin 17"]
            #[allow(non_snake_case)]
            pub fn PIN17(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 17;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 18) Pin 18"]
            #[allow(non_snake_case)]
            pub fn PIN18(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 18;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 19) Pin 19"]
            #[allow(non_snake_case)]
            pub fn PIN19(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 19;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 20) Pin 20"]
            #[allow(non_snake_case)]
            pub fn PIN20(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 20;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 21) Pin 21"]
            #[allow(non_snake_case)]
            pub fn PIN21(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 21;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 22) Pin 22"]
            #[allow(non_snake_case)]
            pub fn PIN22(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 22;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 23) Pin 23"]
            #[allow(non_snake_case)]
            pub fn PIN23(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 23;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 24) Pin 24"]
            #[allow(non_snake_case)]
            pub fn PIN24(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 24;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 25) Pin 25"]
            #[allow(non_snake_case)]
            pub fn PIN25(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 25;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 26) Pin 26"]
            #[allow(non_snake_case)]
            pub fn PIN26(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 26;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 27) Pin 27"]
            #[allow(non_snake_case)]
            pub fn PIN27(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 27;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 28) Pin 28"]
            #[allow(non_snake_case)]
            pub fn PIN28(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 28;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 29) Pin 29"]
            #[allow(non_snake_case)]
            pub fn PIN29(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 29;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 30) Pin 30"]
            #[allow(non_snake_case)]
            pub fn PIN30(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 30;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 31) Pin 31"]
            #[allow(non_snake_case)]
            pub fn PIN31(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 31;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Clear individual bits in GPIO port"]
    pub type OUTCLR = outclr::Register;
    #[doc = "Clear individual bits in GPIO port"]
    pub mod outclr {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x050c) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bit 0) Pin 0"]
            pub fn PIN0(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 1) Pin 1"]
            pub fn PIN1(self) -> u8 {
                const OFFSET: u8 = 1;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 2) Pin 2"]
            pub fn PIN2(self) -> u8 {
                const OFFSET: u8 = 2;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 3) Pin 3"]
            pub fn PIN3(self) -> u8 {
                const OFFSET: u8 = 3;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 4) Pin 4"]
            pub fn PIN4(self) -> u8 {
                const OFFSET: u8 = 4;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 5) Pin 5"]
            pub fn PIN5(self) -> u8 {
                const OFFSET: u8 = 5;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 6) Pin 6"]
            pub fn PIN6(self) -> u8 {
                const OFFSET: u8 = 6;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 7) Pin 7"]
            pub fn PIN7(self) -> u8 {
                const OFFSET: u8 = 7;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 8) Pin 8"]
            pub fn PIN8(self) -> u8 {
                const OFFSET: u8 = 8;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 9) Pin 9"]
            pub fn PIN9(self) -> u8 {
                const OFFSET: u8 = 9;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 10) Pin 10"]
            pub fn PIN10(self) -> u8 {
                const OFFSET: u8 = 10;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 11) Pin 11"]
            pub fn PIN11(self) -> u8 {
                const OFFSET: u8 = 11;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 12) Pin 12"]
            pub fn PIN12(self) -> u8 {
                const OFFSET: u8 = 12;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 13) Pin 13"]
            pub fn PIN13(self) -> u8 {
                const OFFSET: u8 = 13;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 14) Pin 14"]
            pub fn PIN14(self) -> u8 {
                const OFFSET: u8 = 14;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 15) Pin 15"]
            pub fn PIN15(self) -> u8 {
                const OFFSET: u8 = 15;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 16) Pin 16"]
            pub fn PIN16(self) -> u8 {
                const OFFSET: u8 = 16;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 17) Pin 17"]
            pub fn PIN17(self) -> u8 {
                const OFFSET: u8 = 17;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 18) Pin 18"]
            pub fn PIN18(self) -> u8 {
                const OFFSET: u8 = 18;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 19) Pin 19"]
            pub fn PIN19(self) -> u8 {
                const OFFSET: u8 = 19;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 20) Pin 20"]
            pub fn PIN20(self) -> u8 {
                const OFFSET: u8 = 20;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 21) Pin 21"]
            pub fn PIN21(self) -> u8 {
                const OFFSET: u8 = 21;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 22) Pin 22"]
            pub fn PIN22(self) -> u8 {
                const OFFSET: u8 = 22;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 23) Pin 23"]
            pub fn PIN23(self) -> u8 {
                const OFFSET: u8 = 23;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 24) Pin 24"]
            pub fn PIN24(self) -> u8 {
                const OFFSET: u8 = 24;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 25) Pin 25"]
            pub fn PIN25(self) -> u8 {
                const OFFSET: u8 = 25;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 26) Pin 26"]
            pub fn PIN26(self) -> u8 {
                const OFFSET: u8 = 26;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 27) Pin 27"]
            pub fn PIN27(self) -> u8 {
                const OFFSET: u8 = 27;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 28) Pin 28"]
            pub fn PIN28(self) -> u8 {
                const OFFSET: u8 = 28;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 29) Pin 29"]
            pub fn PIN29(self) -> u8 {
                const OFFSET: u8 = 29;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 30) Pin 30"]
            pub fn PIN30(self) -> u8 {
                const OFFSET: u8 = 30;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 31) Pin 31"]
            pub fn PIN31(self) -> u8 {
                const OFFSET: u8 = 31;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u32 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "OUTCLR {{ PIN31: {31}, PIN30: {30}, PIN29: {29}, PIN28: {28}, PIN27: {27}, PIN26: {26}, PIN25: {25}, PIN24: {24}, PIN23: {23}, PIN22: {22}, PIN21: {21}, PIN20: {20}, PIN19: {19}, PIN18: {18}, PIN17: {17}, PIN16: {16}, PIN15: {15}, PIN14: {14}, PIN13: {13}, PIN12: {12}, PIN11: {11}, PIN10: {10}, PIN9: {9}, PIN8: {8}, PIN7: {7}, PIN6: {6}, PIN5: {5}, PIN4: {4}, PIN3: {3}, PIN2: {2}, PIN1: {1}, PIN0: {0} }}@17723374923238906429"]
                #[link_section = ".binfmt.OUTCLR {{ PIN31: {31}, PIN30: {30}, PIN29: {29}, PIN28: {28}, PIN27: {27}, PIN26: {26}, PIN25: {25}, PIN24: {24}, PIN23: {23}, PIN22: {22}, PIN21: {21}, PIN20: {20}, PIN19: {19}, PIN18: {18}, PIN17: {17}, PIN16: {16}, PIN15: {15}, PIN14: {14}, PIN13: {13}, PIN12: {12}, PIN11: {11}, PIN10: {10}, PIN9: {9}, PIN8: {8}, PIN7: {7}, PIN6: {6}, PIN5: {5}, PIN4: {4}, PIN3: {3}, PIN2: {2}, PIN1: {1}, PIN0: {0} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 0) Pin 0"]
            #[allow(non_snake_case)]
            pub fn PIN0(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 1) Pin 1"]
            #[allow(non_snake_case)]
            pub fn PIN1(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 1;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 2) Pin 2"]
            #[allow(non_snake_case)]
            pub fn PIN2(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 2;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 3) Pin 3"]
            #[allow(non_snake_case)]
            pub fn PIN3(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 3;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 4) Pin 4"]
            #[allow(non_snake_case)]
            pub fn PIN4(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 4;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 5) Pin 5"]
            #[allow(non_snake_case)]
            pub fn PIN5(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 5;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 6) Pin 6"]
            #[allow(non_snake_case)]
            pub fn PIN6(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 6;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 7) Pin 7"]
            #[allow(non_snake_case)]
            pub fn PIN7(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 7;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 8) Pin 8"]
            #[allow(non_snake_case)]
            pub fn PIN8(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 8;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 9) Pin 9"]
            #[allow(non_snake_case)]
            pub fn PIN9(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 9;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 10) Pin 10"]
            #[allow(non_snake_case)]
            pub fn PIN10(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 10;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 11) Pin 11"]
            #[allow(non_snake_case)]
            pub fn PIN11(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 11;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 12) Pin 12"]
            #[allow(non_snake_case)]
            pub fn PIN12(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 12;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 13) Pin 13"]
            #[allow(non_snake_case)]
            pub fn PIN13(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 13;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 14) Pin 14"]
            #[allow(non_snake_case)]
            pub fn PIN14(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 14;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 15) Pin 15"]
            #[allow(non_snake_case)]
            pub fn PIN15(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 15;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 16) Pin 16"]
            #[allow(non_snake_case)]
            pub fn PIN16(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 16;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 17) Pin 17"]
            #[allow(non_snake_case)]
            pub fn PIN17(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 17;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 18) Pin 18"]
            #[allow(non_snake_case)]
            pub fn PIN18(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 18;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 19) Pin 19"]
            #[allow(non_snake_case)]
            pub fn PIN19(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 19;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 20) Pin 20"]
            #[allow(non_snake_case)]
            pub fn PIN20(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 20;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 21) Pin 21"]
            #[allow(non_snake_case)]
            pub fn PIN21(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 21;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 22) Pin 22"]
            #[allow(non_snake_case)]
            pub fn PIN22(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 22;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 23) Pin 23"]
            #[allow(non_snake_case)]
            pub fn PIN23(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 23;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 24) Pin 24"]
            #[allow(non_snake_case)]
            pub fn PIN24(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 24;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 25) Pin 25"]
            #[allow(non_snake_case)]
            pub fn PIN25(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 25;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 26) Pin 26"]
            #[allow(non_snake_case)]
            pub fn PIN26(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 26;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 27) Pin 27"]
            #[allow(non_snake_case)]
            pub fn PIN27(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 27;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 28) Pin 28"]
            #[allow(non_snake_case)]
            pub fn PIN28(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 28;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 29) Pin 29"]
            #[allow(non_snake_case)]
            pub fn PIN29(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 29;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 30) Pin 30"]
            #[allow(non_snake_case)]
            pub fn PIN30(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 30;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 31) Pin 31"]
            #[allow(non_snake_case)]
            pub fn PIN31(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 31;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Read GPIO port"]
    pub type IN = in_::Register;
    #[doc = "Read GPIO port"]
    pub mod in_ {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *const u32 {
                (super::BASE_ADDRESS + 0x0510) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bit 0) Pin 0"]
            pub fn PIN0(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 1) Pin 1"]
            pub fn PIN1(self) -> u8 {
                const OFFSET: u8 = 1;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 2) Pin 2"]
            pub fn PIN2(self) -> u8 {
                const OFFSET: u8 = 2;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 3) Pin 3"]
            pub fn PIN3(self) -> u8 {
                const OFFSET: u8 = 3;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 4) Pin 4"]
            pub fn PIN4(self) -> u8 {
                const OFFSET: u8 = 4;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 5) Pin 5"]
            pub fn PIN5(self) -> u8 {
                const OFFSET: u8 = 5;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 6) Pin 6"]
            pub fn PIN6(self) -> u8 {
                const OFFSET: u8 = 6;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 7) Pin 7"]
            pub fn PIN7(self) -> u8 {
                const OFFSET: u8 = 7;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 8) Pin 8"]
            pub fn PIN8(self) -> u8 {
                const OFFSET: u8 = 8;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 9) Pin 9"]
            pub fn PIN9(self) -> u8 {
                const OFFSET: u8 = 9;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 10) Pin 10"]
            pub fn PIN10(self) -> u8 {
                const OFFSET: u8 = 10;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 11) Pin 11"]
            pub fn PIN11(self) -> u8 {
                const OFFSET: u8 = 11;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 12) Pin 12"]
            pub fn PIN12(self) -> u8 {
                const OFFSET: u8 = 12;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 13) Pin 13"]
            pub fn PIN13(self) -> u8 {
                const OFFSET: u8 = 13;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 14) Pin 14"]
            pub fn PIN14(self) -> u8 {
                const OFFSET: u8 = 14;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 15) Pin 15"]
            pub fn PIN15(self) -> u8 {
                const OFFSET: u8 = 15;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 16) Pin 16"]
            pub fn PIN16(self) -> u8 {
                const OFFSET: u8 = 16;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 17) Pin 17"]
            pub fn PIN17(self) -> u8 {
                const OFFSET: u8 = 17;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 18) Pin 18"]
            pub fn PIN18(self) -> u8 {
                const OFFSET: u8 = 18;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 19) Pin 19"]
            pub fn PIN19(self) -> u8 {
                const OFFSET: u8 = 19;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 20) Pin 20"]
            pub fn PIN20(self) -> u8 {
                const OFFSET: u8 = 20;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 21) Pin 21"]
            pub fn PIN21(self) -> u8 {
                const OFFSET: u8 = 21;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 22) Pin 22"]
            pub fn PIN22(self) -> u8 {
                const OFFSET: u8 = 22;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 23) Pin 23"]
            pub fn PIN23(self) -> u8 {
                const OFFSET: u8 = 23;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 24) Pin 24"]
            pub fn PIN24(self) -> u8 {
                const OFFSET: u8 = 24;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 25) Pin 25"]
            pub fn PIN25(self) -> u8 {
                const OFFSET: u8 = 25;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 26) Pin 26"]
            pub fn PIN26(self) -> u8 {
                const OFFSET: u8 = 26;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 27) Pin 27"]
            pub fn PIN27(self) -> u8 {
                const OFFSET: u8 = 27;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 28) Pin 28"]
            pub fn PIN28(self) -> u8 {
                const OFFSET: u8 = 28;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 29) Pin 29"]
            pub fn PIN29(self) -> u8 {
                const OFFSET: u8 = 29;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 30) Pin 30"]
            pub fn PIN30(self) -> u8 {
                const OFFSET: u8 = 30;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 31) Pin 31"]
            pub fn PIN31(self) -> u8 {
                const OFFSET: u8 = 31;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u32 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "IN {{ PIN31: {31}, PIN30: {30}, PIN29: {29}, PIN28: {28}, PIN27: {27}, PIN26: {26}, PIN25: {25}, PIN24: {24}, PIN23: {23}, PIN22: {22}, PIN21: {21}, PIN20: {20}, PIN19: {19}, PIN18: {18}, PIN17: {17}, PIN16: {16}, PIN15: {15}, PIN14: {14}, PIN13: {13}, PIN12: {12}, PIN11: {11}, PIN10: {10}, PIN9: {9}, PIN8: {8}, PIN7: {7}, PIN6: {6}, PIN5: {5}, PIN4: {4}, PIN3: {3}, PIN2: {2}, PIN1: {1}, PIN0: {0} }}@1620292148007066318"]
                #[link_section = ".binfmt.IN {{ PIN31: {31}, PIN30: {30}, PIN29: {29}, PIN28: {28}, PIN27: {27}, PIN26: {26}, PIN25: {25}, PIN24: {24}, PIN23: {23}, PIN22: {22}, PIN21: {21}, PIN20: {20}, PIN19: {19}, PIN18: {18}, PIN17: {17}, PIN16: {16}, PIN15: {15}, PIN14: {14}, PIN13: {13}, PIN12: {12}, PIN11: {11}, PIN10: {10}, PIN9: {9}, PIN8: {8}, PIN7: {7}, PIN6: {6}, PIN5: {5}, PIN4: {4}, PIN3: {3}, PIN2: {2}, PIN1: {1}, PIN0: {0} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Direction of GPIO pins"]
    pub type DIR = dir::Register;
    #[doc = "Direction of GPIO pins"]
    pub mod dir {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0514) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bit 0) Pin 0"]
            pub fn PIN0(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 1) Pin 1"]
            pub fn PIN1(self) -> u8 {
                const OFFSET: u8 = 1;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 2) Pin 2"]
            pub fn PIN2(self) -> u8 {
                const OFFSET: u8 = 2;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 3) Pin 3"]
            pub fn PIN3(self) -> u8 {
                const OFFSET: u8 = 3;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 4) Pin 4"]
            pub fn PIN4(self) -> u8 {
                const OFFSET: u8 = 4;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 5) Pin 5"]
            pub fn PIN5(self) -> u8 {
                const OFFSET: u8 = 5;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 6) Pin 6"]
            pub fn PIN6(self) -> u8 {
                const OFFSET: u8 = 6;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 7) Pin 7"]
            pub fn PIN7(self) -> u8 {
                const OFFSET: u8 = 7;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 8) Pin 8"]
            pub fn PIN8(self) -> u8 {
                const OFFSET: u8 = 8;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 9) Pin 9"]
            pub fn PIN9(self) -> u8 {
                const OFFSET: u8 = 9;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 10) Pin 10"]
            pub fn PIN10(self) -> u8 {
                const OFFSET: u8 = 10;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 11) Pin 11"]
            pub fn PIN11(self) -> u8 {
                const OFFSET: u8 = 11;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 12) Pin 12"]
            pub fn PIN12(self) -> u8 {
                const OFFSET: u8 = 12;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 13) Pin 13"]
            pub fn PIN13(self) -> u8 {
                const OFFSET: u8 = 13;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 14) Pin 14"]
            pub fn PIN14(self) -> u8 {
                const OFFSET: u8 = 14;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 15) Pin 15"]
            pub fn PIN15(self) -> u8 {
                const OFFSET: u8 = 15;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 16) Pin 16"]
            pub fn PIN16(self) -> u8 {
                const OFFSET: u8 = 16;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 17) Pin 17"]
            pub fn PIN17(self) -> u8 {
                const OFFSET: u8 = 17;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 18) Pin 18"]
            pub fn PIN18(self) -> u8 {
                const OFFSET: u8 = 18;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 19) Pin 19"]
            pub fn PIN19(self) -> u8 {
                const OFFSET: u8 = 19;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 20) Pin 20"]
            pub fn PIN20(self) -> u8 {
                const OFFSET: u8 = 20;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 21) Pin 21"]
            pub fn PIN21(self) -> u8 {
                const OFFSET: u8 = 21;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 22) Pin 22"]
            pub fn PIN22(self) -> u8 {
                const OFFSET: u8 = 22;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 23) Pin 23"]
            pub fn PIN23(self) -> u8 {
                const OFFSET: u8 = 23;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 24) Pin 24"]
            pub fn PIN24(self) -> u8 {
                const OFFSET: u8 = 24;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 25) Pin 25"]
            pub fn PIN25(self) -> u8 {
                const OFFSET: u8 = 25;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 26) Pin 26"]
            pub fn PIN26(self) -> u8 {
                const OFFSET: u8 = 26;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 27) Pin 27"]
            pub fn PIN27(self) -> u8 {
                const OFFSET: u8 = 27;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 28) Pin 28"]
            pub fn PIN28(self) -> u8 {
                const OFFSET: u8 = 28;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 29) Pin 29"]
            pub fn PIN29(self) -> u8 {
                const OFFSET: u8 = 29;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 30) Pin 30"]
            pub fn PIN30(self) -> u8 {
                const OFFSET: u8 = 30;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 31) Pin 31"]
            pub fn PIN31(self) -> u8 {
                const OFFSET: u8 = 31;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u32 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "DIR {{ PIN31: {31}, PIN30: {30}, PIN29: {29}, PIN28: {28}, PIN27: {27}, PIN26: {26}, PIN25: {25}, PIN24: {24}, PIN23: {23}, PIN22: {22}, PIN21: {21}, PIN20: {20}, PIN19: {19}, PIN18: {18}, PIN17: {17}, PIN16: {16}, PIN15: {15}, PIN14: {14}, PIN13: {13}, PIN12: {12}, PIN11: {11}, PIN10: {10}, PIN9: {9}, PIN8: {8}, PIN7: {7}, PIN6: {6}, PIN5: {5}, PIN4: {4}, PIN3: {3}, PIN2: {2}, PIN1: {1}, PIN0: {0} }}@10369167584234403487"]
                #[link_section = ".binfmt.DIR {{ PIN31: {31}, PIN30: {30}, PIN29: {29}, PIN28: {28}, PIN27: {27}, PIN26: {26}, PIN25: {25}, PIN24: {24}, PIN23: {23}, PIN22: {22}, PIN21: {21}, PIN20: {20}, PIN19: {19}, PIN18: {18}, PIN17: {17}, PIN16: {16}, PIN15: {15}, PIN14: {14}, PIN13: {13}, PIN12: {12}, PIN11: {11}, PIN10: {10}, PIN9: {9}, PIN8: {8}, PIN7: {7}, PIN6: {6}, PIN5: {5}, PIN4: {4}, PIN3: {3}, PIN2: {2}, PIN1: {1}, PIN0: {0} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 0) Pin 0"]
            #[allow(non_snake_case)]
            pub fn PIN0(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 1) Pin 1"]
            #[allow(non_snake_case)]
            pub fn PIN1(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 1;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 2) Pin 2"]
            #[allow(non_snake_case)]
            pub fn PIN2(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 2;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 3) Pin 3"]
            #[allow(non_snake_case)]
            pub fn PIN3(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 3;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 4) Pin 4"]
            #[allow(non_snake_case)]
            pub fn PIN4(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 4;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 5) Pin 5"]
            #[allow(non_snake_case)]
            pub fn PIN5(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 5;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 6) Pin 6"]
            #[allow(non_snake_case)]
            pub fn PIN6(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 6;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 7) Pin 7"]
            #[allow(non_snake_case)]
            pub fn PIN7(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 7;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 8) Pin 8"]
            #[allow(non_snake_case)]
            pub fn PIN8(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 8;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 9) Pin 9"]
            #[allow(non_snake_case)]
            pub fn PIN9(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 9;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 10) Pin 10"]
            #[allow(non_snake_case)]
            pub fn PIN10(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 10;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 11) Pin 11"]
            #[allow(non_snake_case)]
            pub fn PIN11(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 11;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 12) Pin 12"]
            #[allow(non_snake_case)]
            pub fn PIN12(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 12;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 13) Pin 13"]
            #[allow(non_snake_case)]
            pub fn PIN13(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 13;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 14) Pin 14"]
            #[allow(non_snake_case)]
            pub fn PIN14(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 14;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 15) Pin 15"]
            #[allow(non_snake_case)]
            pub fn PIN15(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 15;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 16) Pin 16"]
            #[allow(non_snake_case)]
            pub fn PIN16(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 16;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 17) Pin 17"]
            #[allow(non_snake_case)]
            pub fn PIN17(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 17;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 18) Pin 18"]
            #[allow(non_snake_case)]
            pub fn PIN18(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 18;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 19) Pin 19"]
            #[allow(non_snake_case)]
            pub fn PIN19(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 19;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 20) Pin 20"]
            #[allow(non_snake_case)]
            pub fn PIN20(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 20;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 21) Pin 21"]
            #[allow(non_snake_case)]
            pub fn PIN21(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 21;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 22) Pin 22"]
            #[allow(non_snake_case)]
            pub fn PIN22(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 22;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 23) Pin 23"]
            #[allow(non_snake_case)]
            pub fn PIN23(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 23;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 24) Pin 24"]
            #[allow(non_snake_case)]
            pub fn PIN24(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 24;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 25) Pin 25"]
            #[allow(non_snake_case)]
            pub fn PIN25(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 25;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 26) Pin 26"]
            #[allow(non_snake_case)]
            pub fn PIN26(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 26;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 27) Pin 27"]
            #[allow(non_snake_case)]
            pub fn PIN27(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 27;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 28) Pin 28"]
            #[allow(non_snake_case)]
            pub fn PIN28(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 28;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 29) Pin 29"]
            #[allow(non_snake_case)]
            pub fn PIN29(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 29;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 30) Pin 30"]
            #[allow(non_snake_case)]
            pub fn PIN30(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 30;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 31) Pin 31"]
            #[allow(non_snake_case)]
            pub fn PIN31(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 31;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "DIR set register"]
    pub type DIRSET = dirset::Register;
    #[doc = "DIR set register"]
    pub mod dirset {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0518) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bit 0) Set as output pin 0"]
            pub fn PIN0(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 1) Set as output pin 1"]
            pub fn PIN1(self) -> u8 {
                const OFFSET: u8 = 1;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 2) Set as output pin 2"]
            pub fn PIN2(self) -> u8 {
                const OFFSET: u8 = 2;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 3) Set as output pin 3"]
            pub fn PIN3(self) -> u8 {
                const OFFSET: u8 = 3;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 4) Set as output pin 4"]
            pub fn PIN4(self) -> u8 {
                const OFFSET: u8 = 4;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 5) Set as output pin 5"]
            pub fn PIN5(self) -> u8 {
                const OFFSET: u8 = 5;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 6) Set as output pin 6"]
            pub fn PIN6(self) -> u8 {
                const OFFSET: u8 = 6;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 7) Set as output pin 7"]
            pub fn PIN7(self) -> u8 {
                const OFFSET: u8 = 7;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 8) Set as output pin 8"]
            pub fn PIN8(self) -> u8 {
                const OFFSET: u8 = 8;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 9) Set as output pin 9"]
            pub fn PIN9(self) -> u8 {
                const OFFSET: u8 = 9;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 10) Set as output pin 10"]
            pub fn PIN10(self) -> u8 {
                const OFFSET: u8 = 10;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 11) Set as output pin 11"]
            pub fn PIN11(self) -> u8 {
                const OFFSET: u8 = 11;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 12) Set as output pin 12"]
            pub fn PIN12(self) -> u8 {
                const OFFSET: u8 = 12;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 13) Set as output pin 13"]
            pub fn PIN13(self) -> u8 {
                const OFFSET: u8 = 13;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 14) Set as output pin 14"]
            pub fn PIN14(self) -> u8 {
                const OFFSET: u8 = 14;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 15) Set as output pin 15"]
            pub fn PIN15(self) -> u8 {
                const OFFSET: u8 = 15;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 16) Set as output pin 16"]
            pub fn PIN16(self) -> u8 {
                const OFFSET: u8 = 16;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 17) Set as output pin 17"]
            pub fn PIN17(self) -> u8 {
                const OFFSET: u8 = 17;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 18) Set as output pin 18"]
            pub fn PIN18(self) -> u8 {
                const OFFSET: u8 = 18;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 19) Set as output pin 19"]
            pub fn PIN19(self) -> u8 {
                const OFFSET: u8 = 19;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 20) Set as output pin 20"]
            pub fn PIN20(self) -> u8 {
                const OFFSET: u8 = 20;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 21) Set as output pin 21"]
            pub fn PIN21(self) -> u8 {
                const OFFSET: u8 = 21;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 22) Set as output pin 22"]
            pub fn PIN22(self) -> u8 {
                const OFFSET: u8 = 22;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 23) Set as output pin 23"]
            pub fn PIN23(self) -> u8 {
                const OFFSET: u8 = 23;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 24) Set as output pin 24"]
            pub fn PIN24(self) -> u8 {
                const OFFSET: u8 = 24;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 25) Set as output pin 25"]
            pub fn PIN25(self) -> u8 {
                const OFFSET: u8 = 25;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 26) Set as output pin 26"]
            pub fn PIN26(self) -> u8 {
                const OFFSET: u8 = 26;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 27) Set as output pin 27"]
            pub fn PIN27(self) -> u8 {
                const OFFSET: u8 = 27;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 28) Set as output pin 28"]
            pub fn PIN28(self) -> u8 {
                const OFFSET: u8 = 28;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 29) Set as output pin 29"]
            pub fn PIN29(self) -> u8 {
                const OFFSET: u8 = 29;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 30) Set as output pin 30"]
            pub fn PIN30(self) -> u8 {
                const OFFSET: u8 = 30;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 31) Set as output pin 31"]
            pub fn PIN31(self) -> u8 {
                const OFFSET: u8 = 31;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u32 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "DIRSET {{ PIN31: {31}, PIN30: {30}, PIN29: {29}, PIN28: {28}, PIN27: {27}, PIN26: {26}, PIN25: {25}, PIN24: {24}, PIN23: {23}, PIN22: {22}, PIN21: {21}, PIN20: {20}, PIN19: {19}, PIN18: {18}, PIN17: {17}, PIN16: {16}, PIN15: {15}, PIN14: {14}, PIN13: {13}, PIN12: {12}, PIN11: {11}, PIN10: {10}, PIN9: {9}, PIN8: {8}, PIN7: {7}, PIN6: {6}, PIN5: {5}, PIN4: {4}, PIN3: {3}, PIN2: {2}, PIN1: {1}, PIN0: {0} }}@5092751499941679970"]
                #[link_section = ".binfmt.DIRSET {{ PIN31: {31}, PIN30: {30}, PIN29: {29}, PIN28: {28}, PIN27: {27}, PIN26: {26}, PIN25: {25}, PIN24: {24}, PIN23: {23}, PIN22: {22}, PIN21: {21}, PIN20: {20}, PIN19: {19}, PIN18: {18}, PIN17: {17}, PIN16: {16}, PIN15: {15}, PIN14: {14}, PIN13: {13}, PIN12: {12}, PIN11: {11}, PIN10: {10}, PIN9: {9}, PIN8: {8}, PIN7: {7}, PIN6: {6}, PIN5: {5}, PIN4: {4}, PIN3: {3}, PIN2: {2}, PIN1: {1}, PIN0: {0} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 0) Set as output pin 0"]
            #[allow(non_snake_case)]
            pub fn PIN0(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 1) Set as output pin 1"]
            #[allow(non_snake_case)]
            pub fn PIN1(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 1;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 2) Set as output pin 2"]
            #[allow(non_snake_case)]
            pub fn PIN2(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 2;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 3) Set as output pin 3"]
            #[allow(non_snake_case)]
            pub fn PIN3(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 3;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 4) Set as output pin 4"]
            #[allow(non_snake_case)]
            pub fn PIN4(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 4;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 5) Set as output pin 5"]
            #[allow(non_snake_case)]
            pub fn PIN5(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 5;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 6) Set as output pin 6"]
            #[allow(non_snake_case)]
            pub fn PIN6(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 6;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 7) Set as output pin 7"]
            #[allow(non_snake_case)]
            pub fn PIN7(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 7;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 8) Set as output pin 8"]
            #[allow(non_snake_case)]
            pub fn PIN8(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 8;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 9) Set as output pin 9"]
            #[allow(non_snake_case)]
            pub fn PIN9(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 9;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 10) Set as output pin 10"]
            #[allow(non_snake_case)]
            pub fn PIN10(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 10;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 11) Set as output pin 11"]
            #[allow(non_snake_case)]
            pub fn PIN11(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 11;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 12) Set as output pin 12"]
            #[allow(non_snake_case)]
            pub fn PIN12(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 12;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 13) Set as output pin 13"]
            #[allow(non_snake_case)]
            pub fn PIN13(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 13;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 14) Set as output pin 14"]
            #[allow(non_snake_case)]
            pub fn PIN14(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 14;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 15) Set as output pin 15"]
            #[allow(non_snake_case)]
            pub fn PIN15(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 15;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 16) Set as output pin 16"]
            #[allow(non_snake_case)]
            pub fn PIN16(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 16;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 17) Set as output pin 17"]
            #[allow(non_snake_case)]
            pub fn PIN17(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 17;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 18) Set as output pin 18"]
            #[allow(non_snake_case)]
            pub fn PIN18(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 18;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 19) Set as output pin 19"]
            #[allow(non_snake_case)]
            pub fn PIN19(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 19;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 20) Set as output pin 20"]
            #[allow(non_snake_case)]
            pub fn PIN20(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 20;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 21) Set as output pin 21"]
            #[allow(non_snake_case)]
            pub fn PIN21(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 21;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 22) Set as output pin 22"]
            #[allow(non_snake_case)]
            pub fn PIN22(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 22;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 23) Set as output pin 23"]
            #[allow(non_snake_case)]
            pub fn PIN23(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 23;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 24) Set as output pin 24"]
            #[allow(non_snake_case)]
            pub fn PIN24(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 24;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 25) Set as output pin 25"]
            #[allow(non_snake_case)]
            pub fn PIN25(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 25;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 26) Set as output pin 26"]
            #[allow(non_snake_case)]
            pub fn PIN26(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 26;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 27) Set as output pin 27"]
            #[allow(non_snake_case)]
            pub fn PIN27(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 27;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 28) Set as output pin 28"]
            #[allow(non_snake_case)]
            pub fn PIN28(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 28;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 29) Set as output pin 29"]
            #[allow(non_snake_case)]
            pub fn PIN29(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 29;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 30) Set as output pin 30"]
            #[allow(non_snake_case)]
            pub fn PIN30(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 30;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 31) Set as output pin 31"]
            #[allow(non_snake_case)]
            pub fn PIN31(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 31;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "DIR clear register"]
    pub type DIRCLR = dirclr::Register;
    #[doc = "DIR clear register"]
    pub mod dirclr {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x051c) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bit 0) Set as input pin 0"]
            pub fn PIN0(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 1) Set as input pin 1"]
            pub fn PIN1(self) -> u8 {
                const OFFSET: u8 = 1;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 2) Set as input pin 2"]
            pub fn PIN2(self) -> u8 {
                const OFFSET: u8 = 2;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 3) Set as input pin 3"]
            pub fn PIN3(self) -> u8 {
                const OFFSET: u8 = 3;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 4) Set as input pin 4"]
            pub fn PIN4(self) -> u8 {
                const OFFSET: u8 = 4;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 5) Set as input pin 5"]
            pub fn PIN5(self) -> u8 {
                const OFFSET: u8 = 5;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 6) Set as input pin 6"]
            pub fn PIN6(self) -> u8 {
                const OFFSET: u8 = 6;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 7) Set as input pin 7"]
            pub fn PIN7(self) -> u8 {
                const OFFSET: u8 = 7;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 8) Set as input pin 8"]
            pub fn PIN8(self) -> u8 {
                const OFFSET: u8 = 8;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 9) Set as input pin 9"]
            pub fn PIN9(self) -> u8 {
                const OFFSET: u8 = 9;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 10) Set as input pin 10"]
            pub fn PIN10(self) -> u8 {
                const OFFSET: u8 = 10;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 11) Set as input pin 11"]
            pub fn PIN11(self) -> u8 {
                const OFFSET: u8 = 11;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 12) Set as input pin 12"]
            pub fn PIN12(self) -> u8 {
                const OFFSET: u8 = 12;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 13) Set as input pin 13"]
            pub fn PIN13(self) -> u8 {
                const OFFSET: u8 = 13;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 14) Set as input pin 14"]
            pub fn PIN14(self) -> u8 {
                const OFFSET: u8 = 14;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 15) Set as input pin 15"]
            pub fn PIN15(self) -> u8 {
                const OFFSET: u8 = 15;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 16) Set as input pin 16"]
            pub fn PIN16(self) -> u8 {
                const OFFSET: u8 = 16;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 17) Set as input pin 17"]
            pub fn PIN17(self) -> u8 {
                const OFFSET: u8 = 17;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 18) Set as input pin 18"]
            pub fn PIN18(self) -> u8 {
                const OFFSET: u8 = 18;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 19) Set as input pin 19"]
            pub fn PIN19(self) -> u8 {
                const OFFSET: u8 = 19;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 20) Set as input pin 20"]
            pub fn PIN20(self) -> u8 {
                const OFFSET: u8 = 20;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 21) Set as input pin 21"]
            pub fn PIN21(self) -> u8 {
                const OFFSET: u8 = 21;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 22) Set as input pin 22"]
            pub fn PIN22(self) -> u8 {
                const OFFSET: u8 = 22;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 23) Set as input pin 23"]
            pub fn PIN23(self) -> u8 {
                const OFFSET: u8 = 23;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 24) Set as input pin 24"]
            pub fn PIN24(self) -> u8 {
                const OFFSET: u8 = 24;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 25) Set as input pin 25"]
            pub fn PIN25(self) -> u8 {
                const OFFSET: u8 = 25;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 26) Set as input pin 26"]
            pub fn PIN26(self) -> u8 {
                const OFFSET: u8 = 26;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 27) Set as input pin 27"]
            pub fn PIN27(self) -> u8 {
                const OFFSET: u8 = 27;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 28) Set as input pin 28"]
            pub fn PIN28(self) -> u8 {
                const OFFSET: u8 = 28;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 29) Set as input pin 29"]
            pub fn PIN29(self) -> u8 {
                const OFFSET: u8 = 29;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 30) Set as input pin 30"]
            pub fn PIN30(self) -> u8 {
                const OFFSET: u8 = 30;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 31) Set as input pin 31"]
            pub fn PIN31(self) -> u8 {
                const OFFSET: u8 = 31;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u32 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "DIRCLR {{ PIN31: {31}, PIN30: {30}, PIN29: {29}, PIN28: {28}, PIN27: {27}, PIN26: {26}, PIN25: {25}, PIN24: {24}, PIN23: {23}, PIN22: {22}, PIN21: {21}, PIN20: {20}, PIN19: {19}, PIN18: {18}, PIN17: {17}, PIN16: {16}, PIN15: {15}, PIN14: {14}, PIN13: {13}, PIN12: {12}, PIN11: {11}, PIN10: {10}, PIN9: {9}, PIN8: {8}, PIN7: {7}, PIN6: {6}, PIN5: {5}, PIN4: {4}, PIN3: {3}, PIN2: {2}, PIN1: {1}, PIN0: {0} }}@9041567977229643077"]
                #[link_section = ".binfmt.DIRCLR {{ PIN31: {31}, PIN30: {30}, PIN29: {29}, PIN28: {28}, PIN27: {27}, PIN26: {26}, PIN25: {25}, PIN24: {24}, PIN23: {23}, PIN22: {22}, PIN21: {21}, PIN20: {20}, PIN19: {19}, PIN18: {18}, PIN17: {17}, PIN16: {16}, PIN15: {15}, PIN14: {14}, PIN13: {13}, PIN12: {12}, PIN11: {11}, PIN10: {10}, PIN9: {9}, PIN8: {8}, PIN7: {7}, PIN6: {6}, PIN5: {5}, PIN4: {4}, PIN3: {3}, PIN2: {2}, PIN1: {1}, PIN0: {0} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 0) Set as input pin 0"]
            #[allow(non_snake_case)]
            pub fn PIN0(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 1) Set as input pin 1"]
            #[allow(non_snake_case)]
            pub fn PIN1(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 1;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 2) Set as input pin 2"]
            #[allow(non_snake_case)]
            pub fn PIN2(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 2;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 3) Set as input pin 3"]
            #[allow(non_snake_case)]
            pub fn PIN3(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 3;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 4) Set as input pin 4"]
            #[allow(non_snake_case)]
            pub fn PIN4(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 4;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 5) Set as input pin 5"]
            #[allow(non_snake_case)]
            pub fn PIN5(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 5;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 6) Set as input pin 6"]
            #[allow(non_snake_case)]
            pub fn PIN6(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 6;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 7) Set as input pin 7"]
            #[allow(non_snake_case)]
            pub fn PIN7(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 7;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 8) Set as input pin 8"]
            #[allow(non_snake_case)]
            pub fn PIN8(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 8;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 9) Set as input pin 9"]
            #[allow(non_snake_case)]
            pub fn PIN9(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 9;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 10) Set as input pin 10"]
            #[allow(non_snake_case)]
            pub fn PIN10(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 10;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 11) Set as input pin 11"]
            #[allow(non_snake_case)]
            pub fn PIN11(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 11;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 12) Set as input pin 12"]
            #[allow(non_snake_case)]
            pub fn PIN12(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 12;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 13) Set as input pin 13"]
            #[allow(non_snake_case)]
            pub fn PIN13(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 13;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 14) Set as input pin 14"]
            #[allow(non_snake_case)]
            pub fn PIN14(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 14;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 15) Set as input pin 15"]
            #[allow(non_snake_case)]
            pub fn PIN15(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 15;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 16) Set as input pin 16"]
            #[allow(non_snake_case)]
            pub fn PIN16(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 16;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 17) Set as input pin 17"]
            #[allow(non_snake_case)]
            pub fn PIN17(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 17;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 18) Set as input pin 18"]
            #[allow(non_snake_case)]
            pub fn PIN18(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 18;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 19) Set as input pin 19"]
            #[allow(non_snake_case)]
            pub fn PIN19(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 19;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 20) Set as input pin 20"]
            #[allow(non_snake_case)]
            pub fn PIN20(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 20;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 21) Set as input pin 21"]
            #[allow(non_snake_case)]
            pub fn PIN21(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 21;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 22) Set as input pin 22"]
            #[allow(non_snake_case)]
            pub fn PIN22(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 22;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 23) Set as input pin 23"]
            #[allow(non_snake_case)]
            pub fn PIN23(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 23;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 24) Set as input pin 24"]
            #[allow(non_snake_case)]
            pub fn PIN24(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 24;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 25) Set as input pin 25"]
            #[allow(non_snake_case)]
            pub fn PIN25(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 25;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 26) Set as input pin 26"]
            #[allow(non_snake_case)]
            pub fn PIN26(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 26;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 27) Set as input pin 27"]
            #[allow(non_snake_case)]
            pub fn PIN27(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 27;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 28) Set as input pin 28"]
            #[allow(non_snake_case)]
            pub fn PIN28(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 28;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 29) Set as input pin 29"]
            #[allow(non_snake_case)]
            pub fn PIN29(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 29;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 30) Set as input pin 30"]
            #[allow(non_snake_case)]
            pub fn PIN30(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 30;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 31) Set as input pin 31"]
            #[allow(non_snake_case)]
            pub fn PIN31(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 31;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Latch register indicating what GPIO pins that have met the criteria set in the PIN_CNF[n].SENSE registers"]
    pub type LATCH = latch::Register;
    #[doc = "Latch register indicating what GPIO pins that have met the criteria set in the PIN_CNF[n].SENSE registers"]
    pub mod latch {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0520) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bit 0) Status on whether PIN0 has met criteria set in PIN_CNF0.SENSE register. Write '1' to clear."]
            pub fn PIN0(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 1) Status on whether PIN1 has met criteria set in PIN_CNF1.SENSE register. Write '1' to clear."]
            pub fn PIN1(self) -> u8 {
                const OFFSET: u8 = 1;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 2) Status on whether PIN2 has met criteria set in PIN_CNF2.SENSE register. Write '1' to clear."]
            pub fn PIN2(self) -> u8 {
                const OFFSET: u8 = 2;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 3) Status on whether PIN3 has met criteria set in PIN_CNF3.SENSE register. Write '1' to clear."]
            pub fn PIN3(self) -> u8 {
                const OFFSET: u8 = 3;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 4) Status on whether PIN4 has met criteria set in PIN_CNF4.SENSE register. Write '1' to clear."]
            pub fn PIN4(self) -> u8 {
                const OFFSET: u8 = 4;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 5) Status on whether PIN5 has met criteria set in PIN_CNF5.SENSE register. Write '1' to clear."]
            pub fn PIN5(self) -> u8 {
                const OFFSET: u8 = 5;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 6) Status on whether PIN6 has met criteria set in PIN_CNF6.SENSE register. Write '1' to clear."]
            pub fn PIN6(self) -> u8 {
                const OFFSET: u8 = 6;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 7) Status on whether PIN7 has met criteria set in PIN_CNF7.SENSE register. Write '1' to clear."]
            pub fn PIN7(self) -> u8 {
                const OFFSET: u8 = 7;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 8) Status on whether PIN8 has met criteria set in PIN_CNF8.SENSE register. Write '1' to clear."]
            pub fn PIN8(self) -> u8 {
                const OFFSET: u8 = 8;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 9) Status on whether PIN9 has met criteria set in PIN_CNF9.SENSE register. Write '1' to clear."]
            pub fn PIN9(self) -> u8 {
                const OFFSET: u8 = 9;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 10) Status on whether PIN10 has met criteria set in PIN_CNF10.SENSE register. Write '1' to clear."]
            pub fn PIN10(self) -> u8 {
                const OFFSET: u8 = 10;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 11) Status on whether PIN11 has met criteria set in PIN_CNF11.SENSE register. Write '1' to clear."]
            pub fn PIN11(self) -> u8 {
                const OFFSET: u8 = 11;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 12) Status on whether PIN12 has met criteria set in PIN_CNF12.SENSE register. Write '1' to clear."]
            pub fn PIN12(self) -> u8 {
                const OFFSET: u8 = 12;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 13) Status on whether PIN13 has met criteria set in PIN_CNF13.SENSE register. Write '1' to clear."]
            pub fn PIN13(self) -> u8 {
                const OFFSET: u8 = 13;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 14) Status on whether PIN14 has met criteria set in PIN_CNF14.SENSE register. Write '1' to clear."]
            pub fn PIN14(self) -> u8 {
                const OFFSET: u8 = 14;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 15) Status on whether PIN15 has met criteria set in PIN_CNF15.SENSE register. Write '1' to clear."]
            pub fn PIN15(self) -> u8 {
                const OFFSET: u8 = 15;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 16) Status on whether PIN16 has met criteria set in PIN_CNF16.SENSE register. Write '1' to clear."]
            pub fn PIN16(self) -> u8 {
                const OFFSET: u8 = 16;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 17) Status on whether PIN17 has met criteria set in PIN_CNF17.SENSE register. Write '1' to clear."]
            pub fn PIN17(self) -> u8 {
                const OFFSET: u8 = 17;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 18) Status on whether PIN18 has met criteria set in PIN_CNF18.SENSE register. Write '1' to clear."]
            pub fn PIN18(self) -> u8 {
                const OFFSET: u8 = 18;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 19) Status on whether PIN19 has met criteria set in PIN_CNF19.SENSE register. Write '1' to clear."]
            pub fn PIN19(self) -> u8 {
                const OFFSET: u8 = 19;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 20) Status on whether PIN20 has met criteria set in PIN_CNF20.SENSE register. Write '1' to clear."]
            pub fn PIN20(self) -> u8 {
                const OFFSET: u8 = 20;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 21) Status on whether PIN21 has met criteria set in PIN_CNF21.SENSE register. Write '1' to clear."]
            pub fn PIN21(self) -> u8 {
                const OFFSET: u8 = 21;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 22) Status on whether PIN22 has met criteria set in PIN_CNF22.SENSE register. Write '1' to clear."]
            pub fn PIN22(self) -> u8 {
                const OFFSET: u8 = 22;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 23) Status on whether PIN23 has met criteria set in PIN_CNF23.SENSE register. Write '1' to clear."]
            pub fn PIN23(self) -> u8 {
                const OFFSET: u8 = 23;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 24) Status on whether PIN24 has met criteria set in PIN_CNF24.SENSE register. Write '1' to clear."]
            pub fn PIN24(self) -> u8 {
                const OFFSET: u8 = 24;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 25) Status on whether PIN25 has met criteria set in PIN_CNF25.SENSE register. Write '1' to clear."]
            pub fn PIN25(self) -> u8 {
                const OFFSET: u8 = 25;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 26) Status on whether PIN26 has met criteria set in PIN_CNF26.SENSE register. Write '1' to clear."]
            pub fn PIN26(self) -> u8 {
                const OFFSET: u8 = 26;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 27) Status on whether PIN27 has met criteria set in PIN_CNF27.SENSE register. Write '1' to clear."]
            pub fn PIN27(self) -> u8 {
                const OFFSET: u8 = 27;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 28) Status on whether PIN28 has met criteria set in PIN_CNF28.SENSE register. Write '1' to clear."]
            pub fn PIN28(self) -> u8 {
                const OFFSET: u8 = 28;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 29) Status on whether PIN29 has met criteria set in PIN_CNF29.SENSE register. Write '1' to clear."]
            pub fn PIN29(self) -> u8 {
                const OFFSET: u8 = 29;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 30) Status on whether PIN30 has met criteria set in PIN_CNF30.SENSE register. Write '1' to clear."]
            pub fn PIN30(self) -> u8 {
                const OFFSET: u8 = 30;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 31) Status on whether PIN31 has met criteria set in PIN_CNF31.SENSE register. Write '1' to clear."]
            pub fn PIN31(self) -> u8 {
                const OFFSET: u8 = 31;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u32 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "LATCH {{ PIN31: {31}, PIN30: {30}, PIN29: {29}, PIN28: {28}, PIN27: {27}, PIN26: {26}, PIN25: {25}, PIN24: {24}, PIN23: {23}, PIN22: {22}, PIN21: {21}, PIN20: {20}, PIN19: {19}, PIN18: {18}, PIN17: {17}, PIN16: {16}, PIN15: {15}, PIN14: {14}, PIN13: {13}, PIN12: {12}, PIN11: {11}, PIN10: {10}, PIN9: {9}, PIN8: {8}, PIN7: {7}, PIN6: {6}, PIN5: {5}, PIN4: {4}, PIN3: {3}, PIN2: {2}, PIN1: {1}, PIN0: {0} }}@350528323449409893"]
                #[link_section = ".binfmt.LATCH {{ PIN31: {31}, PIN30: {30}, PIN29: {29}, PIN28: {28}, PIN27: {27}, PIN26: {26}, PIN25: {25}, PIN24: {24}, PIN23: {23}, PIN22: {22}, PIN21: {21}, PIN20: {20}, PIN19: {19}, PIN18: {18}, PIN17: {17}, PIN16: {16}, PIN15: {15}, PIN14: {14}, PIN13: {13}, PIN12: {12}, PIN11: {11}, PIN10: {10}, PIN9: {9}, PIN8: {8}, PIN7: {7}, PIN6: {6}, PIN5: {5}, PIN4: {4}, PIN3: {3}, PIN2: {2}, PIN1: {1}, PIN0: {0} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 0) Status on whether PIN0 has met criteria set in PIN_CNF0.SENSE register. Write '1' to clear."]
            #[allow(non_snake_case)]
            pub fn PIN0(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 1) Status on whether PIN1 has met criteria set in PIN_CNF1.SENSE register. Write '1' to clear."]
            #[allow(non_snake_case)]
            pub fn PIN1(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 1;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 2) Status on whether PIN2 has met criteria set in PIN_CNF2.SENSE register. Write '1' to clear."]
            #[allow(non_snake_case)]
            pub fn PIN2(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 2;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 3) Status on whether PIN3 has met criteria set in PIN_CNF3.SENSE register. Write '1' to clear."]
            #[allow(non_snake_case)]
            pub fn PIN3(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 3;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 4) Status on whether PIN4 has met criteria set in PIN_CNF4.SENSE register. Write '1' to clear."]
            #[allow(non_snake_case)]
            pub fn PIN4(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 4;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 5) Status on whether PIN5 has met criteria set in PIN_CNF5.SENSE register. Write '1' to clear."]
            #[allow(non_snake_case)]
            pub fn PIN5(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 5;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 6) Status on whether PIN6 has met criteria set in PIN_CNF6.SENSE register. Write '1' to clear."]
            #[allow(non_snake_case)]
            pub fn PIN6(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 6;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 7) Status on whether PIN7 has met criteria set in PIN_CNF7.SENSE register. Write '1' to clear."]
            #[allow(non_snake_case)]
            pub fn PIN7(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 7;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 8) Status on whether PIN8 has met criteria set in PIN_CNF8.SENSE register. Write '1' to clear."]
            #[allow(non_snake_case)]
            pub fn PIN8(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 8;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 9) Status on whether PIN9 has met criteria set in PIN_CNF9.SENSE register. Write '1' to clear."]
            #[allow(non_snake_case)]
            pub fn PIN9(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 9;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 10) Status on whether PIN10 has met criteria set in PIN_CNF10.SENSE register. Write '1' to clear."]
            #[allow(non_snake_case)]
            pub fn PIN10(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 10;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 11) Status on whether PIN11 has met criteria set in PIN_CNF11.SENSE register. Write '1' to clear."]
            #[allow(non_snake_case)]
            pub fn PIN11(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 11;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 12) Status on whether PIN12 has met criteria set in PIN_CNF12.SENSE register. Write '1' to clear."]
            #[allow(non_snake_case)]
            pub fn PIN12(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 12;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 13) Status on whether PIN13 has met criteria set in PIN_CNF13.SENSE register. Write '1' to clear."]
            #[allow(non_snake_case)]
            pub fn PIN13(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 13;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 14) Status on whether PIN14 has met criteria set in PIN_CNF14.SENSE register. Write '1' to clear."]
            #[allow(non_snake_case)]
            pub fn PIN14(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 14;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 15) Status on whether PIN15 has met criteria set in PIN_CNF15.SENSE register. Write '1' to clear."]
            #[allow(non_snake_case)]
            pub fn PIN15(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 15;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 16) Status on whether PIN16 has met criteria set in PIN_CNF16.SENSE register. Write '1' to clear."]
            #[allow(non_snake_case)]
            pub fn PIN16(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 16;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 17) Status on whether PIN17 has met criteria set in PIN_CNF17.SENSE register. Write '1' to clear."]
            #[allow(non_snake_case)]
            pub fn PIN17(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 17;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 18) Status on whether PIN18 has met criteria set in PIN_CNF18.SENSE register. Write '1' to clear."]
            #[allow(non_snake_case)]
            pub fn PIN18(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 18;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 19) Status on whether PIN19 has met criteria set in PIN_CNF19.SENSE register. Write '1' to clear."]
            #[allow(non_snake_case)]
            pub fn PIN19(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 19;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 20) Status on whether PIN20 has met criteria set in PIN_CNF20.SENSE register. Write '1' to clear."]
            #[allow(non_snake_case)]
            pub fn PIN20(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 20;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 21) Status on whether PIN21 has met criteria set in PIN_CNF21.SENSE register. Write '1' to clear."]
            #[allow(non_snake_case)]
            pub fn PIN21(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 21;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 22) Status on whether PIN22 has met criteria set in PIN_CNF22.SENSE register. Write '1' to clear."]
            #[allow(non_snake_case)]
            pub fn PIN22(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 22;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 23) Status on whether PIN23 has met criteria set in PIN_CNF23.SENSE register. Write '1' to clear."]
            #[allow(non_snake_case)]
            pub fn PIN23(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 23;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 24) Status on whether PIN24 has met criteria set in PIN_CNF24.SENSE register. Write '1' to clear."]
            #[allow(non_snake_case)]
            pub fn PIN24(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 24;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 25) Status on whether PIN25 has met criteria set in PIN_CNF25.SENSE register. Write '1' to clear."]
            #[allow(non_snake_case)]
            pub fn PIN25(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 25;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 26) Status on whether PIN26 has met criteria set in PIN_CNF26.SENSE register. Write '1' to clear."]
            #[allow(non_snake_case)]
            pub fn PIN26(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 26;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 27) Status on whether PIN27 has met criteria set in PIN_CNF27.SENSE register. Write '1' to clear."]
            #[allow(non_snake_case)]
            pub fn PIN27(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 27;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 28) Status on whether PIN28 has met criteria set in PIN_CNF28.SENSE register. Write '1' to clear."]
            #[allow(non_snake_case)]
            pub fn PIN28(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 28;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 29) Status on whether PIN29 has met criteria set in PIN_CNF29.SENSE register. Write '1' to clear."]
            #[allow(non_snake_case)]
            pub fn PIN29(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 29;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 30) Status on whether PIN30 has met criteria set in PIN_CNF30.SENSE register. Write '1' to clear."]
            #[allow(non_snake_case)]
            pub fn PIN30(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 30;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 31) Status on whether PIN31 has met criteria set in PIN_CNF31.SENSE register. Write '1' to clear."]
            #[allow(non_snake_case)]
            pub fn PIN31(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 31;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Select between default DETECT signal behaviour and LDETECT mode"]
    pub type DETECTMODE = detectmode::Register;
    #[doc = "Select between default DETECT signal behaviour and LDETECT mode"]
    pub mod detectmode {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0524) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bit 0) Select between default DETECT signal behaviour and LDETECT mode"]
            pub fn DETECTMODE(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u8 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "DETECTMODE {{ DETECTMODE: {0} }}@16260331393180937660"]
                #[link_section = ".binfmt.DETECTMODE {{ DETECTMODE: {0} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 0) Select between default DETECT signal behaviour and LDETECT mode"]
            #[allow(non_snake_case)]
            pub fn DETECTMODE(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Description collection: Configuration of GPIO pins"]
    pub type PIN_CNF0 = pin_cnf0::Register;
    #[doc = "Description collection: Configuration of GPIO pins"]
    pub mod pin_cnf0 {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0700) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bit 0) Pin direction. Same physical register as DIR register"]
            pub fn DIR(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 1) Connect or disconnect input buffer"]
            pub fn INPUT(self) -> u8 {
                const OFFSET: u8 = 1;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bits 2..=4) Pull configuration"]
            pub fn PULL(self) -> u8 {
                const OFFSET: u8 = 2;
                const MASK: u8 = 0x03;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bits 8..=11) Drive configuration"]
            pub fn DRIVE(self) -> u8 {
                const OFFSET: u8 = 8;
                const MASK: u8 = 0x07;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bits 16..=18) Pin sensing mechanism"]
            pub fn SENSE(self) -> u8 {
                const OFFSET: u8 = 16;
                const MASK: u8 = 0x03;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u32 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "PIN_CNF0 {{ SENSE: {16:18}, DRIVE: {8:11}, PULL: {2:4}, INPUT: {1}, DIR: {0} }}@8583704293544118633"]
                #[link_section = ".binfmt.PIN_CNF0 {{ SENSE: {16:18}, DRIVE: {8:11}, PULL: {2:4}, INPUT: {1}, DIR: {0} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 0) Pin direction. Same physical register as DIR register"]
            #[allow(non_snake_case)]
            pub fn DIR(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 1) Connect or disconnect input buffer"]
            #[allow(non_snake_case)]
            pub fn INPUT(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 1;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bits 2..=4) Pull configuration"]
            #[allow(non_snake_case)]
            pub fn PULL(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 2;
                const MASK: u8 = 0x03;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bits 8..=11) Drive configuration"]
            #[allow(non_snake_case)]
            pub fn DRIVE(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 8;
                const MASK: u8 = 0x07;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bits 16..=18) Pin sensing mechanism"]
            #[allow(non_snake_case)]
            pub fn SENSE(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 16;
                const MASK: u8 = 0x03;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Description collection: Configuration of GPIO pins"]
    pub type PIN_CNF1 = pin_cnf1::Register;
    #[doc = "Description collection: Configuration of GPIO pins"]
    pub mod pin_cnf1 {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0704) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bit 0) Pin direction. Same physical register as DIR register"]
            pub fn DIR(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 1) Connect or disconnect input buffer"]
            pub fn INPUT(self) -> u8 {
                const OFFSET: u8 = 1;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bits 2..=4) Pull configuration"]
            pub fn PULL(self) -> u8 {
                const OFFSET: u8 = 2;
                const MASK: u8 = 0x03;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bits 8..=11) Drive configuration"]
            pub fn DRIVE(self) -> u8 {
                const OFFSET: u8 = 8;
                const MASK: u8 = 0x07;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bits 16..=18) Pin sensing mechanism"]
            pub fn SENSE(self) -> u8 {
                const OFFSET: u8 = 16;
                const MASK: u8 = 0x03;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u32 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "PIN_CNF1 {{ SENSE: {16:18}, DRIVE: {8:11}, PULL: {2:4}, INPUT: {1}, DIR: {0} }}@17114935670719508865"]
                #[link_section = ".binfmt.PIN_CNF1 {{ SENSE: {16:18}, DRIVE: {8:11}, PULL: {2:4}, INPUT: {1}, DIR: {0} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 0) Pin direction. Same physical register as DIR register"]
            #[allow(non_snake_case)]
            pub fn DIR(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 1) Connect or disconnect input buffer"]
            #[allow(non_snake_case)]
            pub fn INPUT(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 1;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bits 2..=4) Pull configuration"]
            #[allow(non_snake_case)]
            pub fn PULL(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 2;
                const MASK: u8 = 0x03;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bits 8..=11) Drive configuration"]
            #[allow(non_snake_case)]
            pub fn DRIVE(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 8;
                const MASK: u8 = 0x07;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bits 16..=18) Pin sensing mechanism"]
            #[allow(non_snake_case)]
            pub fn SENSE(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 16;
                const MASK: u8 = 0x03;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Description collection: Configuration of GPIO pins"]
    pub type PIN_CNF2 = pin_cnf2::Register;
    #[doc = "Description collection: Configuration of GPIO pins"]
    pub mod pin_cnf2 {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0708) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bit 0) Pin direction. Same physical register as DIR register"]
            pub fn DIR(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 1) Connect or disconnect input buffer"]
            pub fn INPUT(self) -> u8 {
                const OFFSET: u8 = 1;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bits 2..=4) Pull configuration"]
            pub fn PULL(self) -> u8 {
                const OFFSET: u8 = 2;
                const MASK: u8 = 0x03;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bits 8..=11) Drive configuration"]
            pub fn DRIVE(self) -> u8 {
                const OFFSET: u8 = 8;
                const MASK: u8 = 0x07;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bits 16..=18) Pin sensing mechanism"]
            pub fn SENSE(self) -> u8 {
                const OFFSET: u8 = 16;
                const MASK: u8 = 0x03;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u32 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "PIN_CNF2 {{ SENSE: {16:18}, DRIVE: {8:11}, PULL: {2:4}, INPUT: {1}, DIR: {0} }}@8246922423357510024"]
                #[link_section = ".binfmt.PIN_CNF2 {{ SENSE: {16:18}, DRIVE: {8:11}, PULL: {2:4}, INPUT: {1}, DIR: {0} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 0) Pin direction. Same physical register as DIR register"]
            #[allow(non_snake_case)]
            pub fn DIR(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 1) Connect or disconnect input buffer"]
            #[allow(non_snake_case)]
            pub fn INPUT(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 1;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bits 2..=4) Pull configuration"]
            #[allow(non_snake_case)]
            pub fn PULL(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 2;
                const MASK: u8 = 0x03;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bits 8..=11) Drive configuration"]
            #[allow(non_snake_case)]
            pub fn DRIVE(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 8;
                const MASK: u8 = 0x07;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bits 16..=18) Pin sensing mechanism"]
            #[allow(non_snake_case)]
            pub fn SENSE(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 16;
                const MASK: u8 = 0x03;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Description collection: Configuration of GPIO pins"]
    pub type PIN_CNF3 = pin_cnf3::Register;
    #[doc = "Description collection: Configuration of GPIO pins"]
    pub mod pin_cnf3 {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x070c) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bit 0) Pin direction. Same physical register as DIR register"]
            pub fn DIR(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 1) Connect or disconnect input buffer"]
            pub fn INPUT(self) -> u8 {
                const OFFSET: u8 = 1;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bits 2..=4) Pull configuration"]
            pub fn PULL(self) -> u8 {
                const OFFSET: u8 = 2;
                const MASK: u8 = 0x03;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bits 8..=11) Drive configuration"]
            pub fn DRIVE(self) -> u8 {
                const OFFSET: u8 = 8;
                const MASK: u8 = 0x07;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bits 16..=18) Pin sensing mechanism"]
            pub fn SENSE(self) -> u8 {
                const OFFSET: u8 = 16;
                const MASK: u8 = 0x03;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u32 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "PIN_CNF3 {{ SENSE: {16:18}, DRIVE: {8:11}, PULL: {2:4}, INPUT: {1}, DIR: {0} }}@15963749679795694089"]
                #[link_section = ".binfmt.PIN_CNF3 {{ SENSE: {16:18}, DRIVE: {8:11}, PULL: {2:4}, INPUT: {1}, DIR: {0} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 0) Pin direction. Same physical register as DIR register"]
            #[allow(non_snake_case)]
            pub fn DIR(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 1) Connect or disconnect input buffer"]
            #[allow(non_snake_case)]
            pub fn INPUT(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 1;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bits 2..=4) Pull configuration"]
            #[allow(non_snake_case)]
            pub fn PULL(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 2;
                const MASK: u8 = 0x03;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bits 8..=11) Drive configuration"]
            #[allow(non_snake_case)]
            pub fn DRIVE(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 8;
                const MASK: u8 = 0x07;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bits 16..=18) Pin sensing mechanism"]
            #[allow(non_snake_case)]
            pub fn SENSE(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 16;
                const MASK: u8 = 0x03;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Description collection: Configuration of GPIO pins"]
    pub type PIN_CNF4 = pin_cnf4::Register;
    #[doc = "Description collection: Configuration of GPIO pins"]
    pub mod pin_cnf4 {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0710) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bit 0) Pin direction. Same physical register as DIR register"]
            pub fn DIR(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 1) Connect or disconnect input buffer"]
            pub fn INPUT(self) -> u8 {
                const OFFSET: u8 = 1;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bits 2..=4) Pull configuration"]
            pub fn PULL(self) -> u8 {
                const OFFSET: u8 = 2;
                const MASK: u8 = 0x03;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bits 8..=11) Drive configuration"]
            pub fn DRIVE(self) -> u8 {
                const OFFSET: u8 = 8;
                const MASK: u8 = 0x07;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bits 16..=18) Pin sensing mechanism"]
            pub fn SENSE(self) -> u8 {
                const OFFSET: u8 = 16;
                const MASK: u8 = 0x03;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u32 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "PIN_CNF4 {{ SENSE: {16:18}, DRIVE: {8:11}, PULL: {2:4}, INPUT: {1}, DIR: {0} }}@12308158446585874985"]
                #[link_section = ".binfmt.PIN_CNF4 {{ SENSE: {16:18}, DRIVE: {8:11}, PULL: {2:4}, INPUT: {1}, DIR: {0} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 0) Pin direction. Same physical register as DIR register"]
            #[allow(non_snake_case)]
            pub fn DIR(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 1) Connect or disconnect input buffer"]
            #[allow(non_snake_case)]
            pub fn INPUT(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 1;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bits 2..=4) Pull configuration"]
            #[allow(non_snake_case)]
            pub fn PULL(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 2;
                const MASK: u8 = 0x03;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bits 8..=11) Drive configuration"]
            #[allow(non_snake_case)]
            pub fn DRIVE(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 8;
                const MASK: u8 = 0x07;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bits 16..=18) Pin sensing mechanism"]
            #[allow(non_snake_case)]
            pub fn SENSE(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 16;
                const MASK: u8 = 0x03;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Description collection: Configuration of GPIO pins"]
    pub type PIN_CNF5 = pin_cnf5::Register;
    #[doc = "Description collection: Configuration of GPIO pins"]
    pub mod pin_cnf5 {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0714) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bit 0) Pin direction. Same physical register as DIR register"]
            pub fn DIR(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 1) Connect or disconnect input buffer"]
            pub fn INPUT(self) -> u8 {
                const OFFSET: u8 = 1;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bits 2..=4) Pull configuration"]
            pub fn PULL(self) -> u8 {
                const OFFSET: u8 = 2;
                const MASK: u8 = 0x03;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bits 8..=11) Drive configuration"]
            pub fn DRIVE(self) -> u8 {
                const OFFSET: u8 = 8;
                const MASK: u8 = 0x07;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bits 16..=18) Pin sensing mechanism"]
            pub fn SENSE(self) -> u8 {
                const OFFSET: u8 = 16;
                const MASK: u8 = 0x03;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u32 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "PIN_CNF5 {{ SENSE: {16:18}, DRIVE: {8:11}, PULL: {2:4}, INPUT: {1}, DIR: {0} }}@16296664184184455575"]
                #[link_section = ".binfmt.PIN_CNF5 {{ SENSE: {16:18}, DRIVE: {8:11}, PULL: {2:4}, INPUT: {1}, DIR: {0} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 0) Pin direction. Same physical register as DIR register"]
            #[allow(non_snake_case)]
            pub fn DIR(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 1) Connect or disconnect input buffer"]
            #[allow(non_snake_case)]
            pub fn INPUT(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 1;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bits 2..=4) Pull configuration"]
            #[allow(non_snake_case)]
            pub fn PULL(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 2;
                const MASK: u8 = 0x03;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bits 8..=11) Drive configuration"]
            #[allow(non_snake_case)]
            pub fn DRIVE(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 8;
                const MASK: u8 = 0x07;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bits 16..=18) Pin sensing mechanism"]
            #[allow(non_snake_case)]
            pub fn SENSE(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 16;
                const MASK: u8 = 0x03;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Description collection: Configuration of GPIO pins"]
    pub type PIN_CNF6 = pin_cnf6::Register;
    #[doc = "Description collection: Configuration of GPIO pins"]
    pub mod pin_cnf6 {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0718) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bit 0) Pin direction. Same physical register as DIR register"]
            pub fn DIR(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 1) Connect or disconnect input buffer"]
            pub fn INPUT(self) -> u8 {
                const OFFSET: u8 = 1;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bits 2..=4) Pull configuration"]
            pub fn PULL(self) -> u8 {
                const OFFSET: u8 = 2;
                const MASK: u8 = 0x03;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bits 8..=11) Drive configuration"]
            pub fn DRIVE(self) -> u8 {
                const OFFSET: u8 = 8;
                const MASK: u8 = 0x07;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bits 16..=18) Pin sensing mechanism"]
            pub fn SENSE(self) -> u8 {
                const OFFSET: u8 = 16;
                const MASK: u8 = 0x03;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u32 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "PIN_CNF6 {{ SENSE: {16:18}, DRIVE: {8:11}, PULL: {2:4}, INPUT: {1}, DIR: {0} }}@12824641660218644245"]
                #[link_section = ".binfmt.PIN_CNF6 {{ SENSE: {16:18}, DRIVE: {8:11}, PULL: {2:4}, INPUT: {1}, DIR: {0} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 0) Pin direction. Same physical register as DIR register"]
            #[allow(non_snake_case)]
            pub fn DIR(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 1) Connect or disconnect input buffer"]
            #[allow(non_snake_case)]
            pub fn INPUT(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 1;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bits 2..=4) Pull configuration"]
            #[allow(non_snake_case)]
            pub fn PULL(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 2;
                const MASK: u8 = 0x03;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bits 8..=11) Drive configuration"]
            #[allow(non_snake_case)]
            pub fn DRIVE(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 8;
                const MASK: u8 = 0x07;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bits 16..=18) Pin sensing mechanism"]
            #[allow(non_snake_case)]
            pub fn SENSE(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 16;
                const MASK: u8 = 0x03;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Description collection: Configuration of GPIO pins"]
    pub type PIN_CNF7 = pin_cnf7::Register;
    #[doc = "Description collection: Configuration of GPIO pins"]
    pub mod pin_cnf7 {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x071c) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bit 0) Pin direction. Same physical register as DIR register"]
            pub fn DIR(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 1) Connect or disconnect input buffer"]
            pub fn INPUT(self) -> u8 {
                const OFFSET: u8 = 1;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bits 2..=4) Pull configuration"]
            pub fn PULL(self) -> u8 {
                const OFFSET: u8 = 2;
                const MASK: u8 = 0x03;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bits 8..=11) Drive configuration"]
            pub fn DRIVE(self) -> u8 {
                const OFFSET: u8 = 8;
                const MASK: u8 = 0x07;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bits 16..=18) Pin sensing mechanism"]
            pub fn SENSE(self) -> u8 {
                const OFFSET: u8 = 16;
                const MASK: u8 = 0x03;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u32 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "PIN_CNF7 {{ SENSE: {16:18}, DRIVE: {8:11}, PULL: {2:4}, INPUT: {1}, DIR: {0} }}@6349515573823767029"]
                #[link_section = ".binfmt.PIN_CNF7 {{ SENSE: {16:18}, DRIVE: {8:11}, PULL: {2:4}, INPUT: {1}, DIR: {0} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 0) Pin direction. Same physical register as DIR register"]
            #[allow(non_snake_case)]
            pub fn DIR(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 1) Connect or disconnect input buffer"]
            #[allow(non_snake_case)]
            pub fn INPUT(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 1;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bits 2..=4) Pull configuration"]
            #[allow(non_snake_case)]
            pub fn PULL(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 2;
                const MASK: u8 = 0x03;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bits 8..=11) Drive configuration"]
            #[allow(non_snake_case)]
            pub fn DRIVE(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 8;
                const MASK: u8 = 0x07;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bits 16..=18) Pin sensing mechanism"]
            #[allow(non_snake_case)]
            pub fn SENSE(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 16;
                const MASK: u8 = 0x03;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Description collection: Configuration of GPIO pins"]
    pub type PIN_CNF8 = pin_cnf8::Register;
    #[doc = "Description collection: Configuration of GPIO pins"]
    pub mod pin_cnf8 {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0720) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bit 0) Pin direction. Same physical register as DIR register"]
            pub fn DIR(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 1) Connect or disconnect input buffer"]
            pub fn INPUT(self) -> u8 {
                const OFFSET: u8 = 1;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bits 2..=4) Pull configuration"]
            pub fn PULL(self) -> u8 {
                const OFFSET: u8 = 2;
                const MASK: u8 = 0x03;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bits 8..=11) Drive configuration"]
            pub fn DRIVE(self) -> u8 {
                const OFFSET: u8 = 8;
                const MASK: u8 = 0x07;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bits 16..=18) Pin sensing mechanism"]
            pub fn SENSE(self) -> u8 {
                const OFFSET: u8 = 16;
                const MASK: u8 = 0x03;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u32 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "PIN_CNF8 {{ SENSE: {16:18}, DRIVE: {8:11}, PULL: {2:4}, INPUT: {1}, DIR: {0} }}@5364255089292020844"]
                #[link_section = ".binfmt.PIN_CNF8 {{ SENSE: {16:18}, DRIVE: {8:11}, PULL: {2:4}, INPUT: {1}, DIR: {0} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 0) Pin direction. Same physical register as DIR register"]
            #[allow(non_snake_case)]
            pub fn DIR(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 1) Connect or disconnect input buffer"]
            #[allow(non_snake_case)]
            pub fn INPUT(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 1;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bits 2..=4) Pull configuration"]
            #[allow(non_snake_case)]
            pub fn PULL(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 2;
                const MASK: u8 = 0x03;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bits 8..=11) Drive configuration"]
            #[allow(non_snake_case)]
            pub fn DRIVE(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 8;
                const MASK: u8 = 0x07;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bits 16..=18) Pin sensing mechanism"]
            #[allow(non_snake_case)]
            pub fn SENSE(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 16;
                const MASK: u8 = 0x03;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Description collection: Configuration of GPIO pins"]
    pub type PIN_CNF9 = pin_cnf9::Register;
    #[doc = "Description collection: Configuration of GPIO pins"]
    pub mod pin_cnf9 {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0724) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bit 0) Pin direction. Same physical register as DIR register"]
            pub fn DIR(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 1) Connect or disconnect input buffer"]
            pub fn INPUT(self) -> u8 {
                const OFFSET: u8 = 1;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bits 2..=4) Pull configuration"]
            pub fn PULL(self) -> u8 {
                const OFFSET: u8 = 2;
                const MASK: u8 = 0x03;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bits 8..=11) Drive configuration"]
            pub fn DRIVE(self) -> u8 {
                const OFFSET: u8 = 8;
                const MASK: u8 = 0x07;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bits 16..=18) Pin sensing mechanism"]
            pub fn SENSE(self) -> u8 {
                const OFFSET: u8 = 16;
                const MASK: u8 = 0x03;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u32 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "PIN_CNF9 {{ SENSE: {16:18}, DRIVE: {8:11}, PULL: {2:4}, INPUT: {1}, DIR: {0} }}@10313299325513372935"]
                #[link_section = ".binfmt.PIN_CNF9 {{ SENSE: {16:18}, DRIVE: {8:11}, PULL: {2:4}, INPUT: {1}, DIR: {0} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 0) Pin direction. Same physical register as DIR register"]
            #[allow(non_snake_case)]
            pub fn DIR(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 1) Connect or disconnect input buffer"]
            #[allow(non_snake_case)]
            pub fn INPUT(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 1;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bits 2..=4) Pull configuration"]
            #[allow(non_snake_case)]
            pub fn PULL(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 2;
                const MASK: u8 = 0x03;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bits 8..=11) Drive configuration"]
            #[allow(non_snake_case)]
            pub fn DRIVE(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 8;
                const MASK: u8 = 0x07;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bits 16..=18) Pin sensing mechanism"]
            #[allow(non_snake_case)]
            pub fn SENSE(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 16;
                const MASK: u8 = 0x03;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Description collection: Configuration of GPIO pins"]
    pub type PIN_CNF10 = pin_cnf10::Register;
    #[doc = "Description collection: Configuration of GPIO pins"]
    pub mod pin_cnf10 {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0728) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bit 0) Pin direction. Same physical register as DIR register"]
            pub fn DIR(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 1) Connect or disconnect input buffer"]
            pub fn INPUT(self) -> u8 {
                const OFFSET: u8 = 1;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bits 2..=4) Pull configuration"]
            pub fn PULL(self) -> u8 {
                const OFFSET: u8 = 2;
                const MASK: u8 = 0x03;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bits 8..=11) Drive configuration"]
            pub fn DRIVE(self) -> u8 {
                const OFFSET: u8 = 8;
                const MASK: u8 = 0x07;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bits 16..=18) Pin sensing mechanism"]
            pub fn SENSE(self) -> u8 {
                const OFFSET: u8 = 16;
                const MASK: u8 = 0x03;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u32 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "PIN_CNF10 {{ SENSE: {16:18}, DRIVE: {8:11}, PULL: {2:4}, INPUT: {1}, DIR: {0} }}@14550503305275504892"]
                #[link_section = ".binfmt.PIN_CNF10 {{ SENSE: {16:18}, DRIVE: {8:11}, PULL: {2:4}, INPUT: {1}, DIR: {0} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 0) Pin direction. Same physical register as DIR register"]
            #[allow(non_snake_case)]
            pub fn DIR(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 1) Connect or disconnect input buffer"]
            #[allow(non_snake_case)]
            pub fn INPUT(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 1;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bits 2..=4) Pull configuration"]
            #[allow(non_snake_case)]
            pub fn PULL(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 2;
                const MASK: u8 = 0x03;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bits 8..=11) Drive configuration"]
            #[allow(non_snake_case)]
            pub fn DRIVE(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 8;
                const MASK: u8 = 0x07;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bits 16..=18) Pin sensing mechanism"]
            #[allow(non_snake_case)]
            pub fn SENSE(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 16;
                const MASK: u8 = 0x03;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Description collection: Configuration of GPIO pins"]
    pub type PIN_CNF11 = pin_cnf11::Register;
    #[doc = "Description collection: Configuration of GPIO pins"]
    pub mod pin_cnf11 {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x072c) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bit 0) Pin direction. Same physical register as DIR register"]
            pub fn DIR(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 1) Connect or disconnect input buffer"]
            pub fn INPUT(self) -> u8 {
                const OFFSET: u8 = 1;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bits 2..=4) Pull configuration"]
            pub fn PULL(self) -> u8 {
                const OFFSET: u8 = 2;
                const MASK: u8 = 0x03;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bits 8..=11) Drive configuration"]
            pub fn DRIVE(self) -> u8 {
                const OFFSET: u8 = 8;
                const MASK: u8 = 0x07;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bits 16..=18) Pin sensing mechanism"]
            pub fn SENSE(self) -> u8 {
                const OFFSET: u8 = 16;
                const MASK: u8 = 0x03;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u32 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "PIN_CNF11 {{ SENSE: {16:18}, DRIVE: {8:11}, PULL: {2:4}, INPUT: {1}, DIR: {0} }}@6977359549579844029"]
                #[link_section = ".binfmt.PIN_CNF11 {{ SENSE: {16:18}, DRIVE: {8:11}, PULL: {2:4}, INPUT: {1}, DIR: {0} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 0) Pin direction. Same physical register as DIR register"]
            #[allow(non_snake_case)]
            pub fn DIR(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 1) Connect or disconnect input buffer"]
            #[allow(non_snake_case)]
            pub fn INPUT(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 1;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bits 2..=4) Pull configuration"]
            #[allow(non_snake_case)]
            pub fn PULL(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 2;
                const MASK: u8 = 0x03;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bits 8..=11) Drive configuration"]
            #[allow(non_snake_case)]
            pub fn DRIVE(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 8;
                const MASK: u8 = 0x07;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bits 16..=18) Pin sensing mechanism"]
            #[allow(non_snake_case)]
            pub fn SENSE(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 16;
                const MASK: u8 = 0x03;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Description collection: Configuration of GPIO pins"]
    pub type PIN_CNF12 = pin_cnf12::Register;
    #[doc = "Description collection: Configuration of GPIO pins"]
    pub mod pin_cnf12 {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0730) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bit 0) Pin direction. Same physical register as DIR register"]
            pub fn DIR(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 1) Connect or disconnect input buffer"]
            pub fn INPUT(self) -> u8 {
                const OFFSET: u8 = 1;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bits 2..=4) Pull configuration"]
            pub fn PULL(self) -> u8 {
                const OFFSET: u8 = 2;
                const MASK: u8 = 0x03;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bits 8..=11) Drive configuration"]
            pub fn DRIVE(self) -> u8 {
                const OFFSET: u8 = 8;
                const MASK: u8 = 0x07;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bits 16..=18) Pin sensing mechanism"]
            pub fn SENSE(self) -> u8 {
                const OFFSET: u8 = 16;
                const MASK: u8 = 0x03;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u32 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "PIN_CNF12 {{ SENSE: {16:18}, DRIVE: {8:11}, PULL: {2:4}, INPUT: {1}, DIR: {0} }}@8561910780020476788"]
                #[link_section = ".binfmt.PIN_CNF12 {{ SENSE: {16:18}, DRIVE: {8:11}, PULL: {2:4}, INPUT: {1}, DIR: {0} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 0) Pin direction. Same physical register as DIR register"]
            #[allow(non_snake_case)]
            pub fn DIR(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 1) Connect or disconnect input buffer"]
            #[allow(non_snake_case)]
            pub fn INPUT(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 1;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bits 2..=4) Pull configuration"]
            #[allow(non_snake_case)]
            pub fn PULL(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 2;
                const MASK: u8 = 0x03;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bits 8..=11) Drive configuration"]
            #[allow(non_snake_case)]
            pub fn DRIVE(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 8;
                const MASK: u8 = 0x07;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bits 16..=18) Pin sensing mechanism"]
            #[allow(non_snake_case)]
            pub fn SENSE(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 16;
                const MASK: u8 = 0x03;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Description collection: Configuration of GPIO pins"]
    pub type PIN_CNF13 = pin_cnf13::Register;
    #[doc = "Description collection: Configuration of GPIO pins"]
    pub mod pin_cnf13 {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0734) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bit 0) Pin direction. Same physical register as DIR register"]
            pub fn DIR(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 1) Connect or disconnect input buffer"]
            pub fn INPUT(self) -> u8 {
                const OFFSET: u8 = 1;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bits 2..=4) Pull configuration"]
            pub fn PULL(self) -> u8 {
                const OFFSET: u8 = 2;
                const MASK: u8 = 0x03;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bits 8..=11) Drive configuration"]
            pub fn DRIVE(self) -> u8 {
                const OFFSET: u8 = 8;
                const MASK: u8 = 0x07;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bits 16..=18) Pin sensing mechanism"]
            pub fn SENSE(self) -> u8 {
                const OFFSET: u8 = 16;
                const MASK: u8 = 0x03;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u32 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "PIN_CNF13 {{ SENSE: {16:18}, DRIVE: {8:11}, PULL: {2:4}, INPUT: {1}, DIR: {0} }}@5361942994113336363"]
                #[link_section = ".binfmt.PIN_CNF13 {{ SENSE: {16:18}, DRIVE: {8:11}, PULL: {2:4}, INPUT: {1}, DIR: {0} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 0) Pin direction. Same physical register as DIR register"]
            #[allow(non_snake_case)]
            pub fn DIR(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 1) Connect or disconnect input buffer"]
            #[allow(non_snake_case)]
            pub fn INPUT(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 1;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bits 2..=4) Pull configuration"]
            #[allow(non_snake_case)]
            pub fn PULL(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 2;
                const MASK: u8 = 0x03;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bits 8..=11) Drive configuration"]
            #[allow(non_snake_case)]
            pub fn DRIVE(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 8;
                const MASK: u8 = 0x07;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bits 16..=18) Pin sensing mechanism"]
            #[allow(non_snake_case)]
            pub fn SENSE(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 16;
                const MASK: u8 = 0x03;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Description collection: Configuration of GPIO pins"]
    pub type PIN_CNF14 = pin_cnf14::Register;
    #[doc = "Description collection: Configuration of GPIO pins"]
    pub mod pin_cnf14 {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0738) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bit 0) Pin direction. Same physical register as DIR register"]
            pub fn DIR(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 1) Connect or disconnect input buffer"]
            pub fn INPUT(self) -> u8 {
                const OFFSET: u8 = 1;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bits 2..=4) Pull configuration"]
            pub fn PULL(self) -> u8 {
                const OFFSET: u8 = 2;
                const MASK: u8 = 0x03;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bits 8..=11) Drive configuration"]
            pub fn DRIVE(self) -> u8 {
                const OFFSET: u8 = 8;
                const MASK: u8 = 0x07;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bits 16..=18) Pin sensing mechanism"]
            pub fn SENSE(self) -> u8 {
                const OFFSET: u8 = 16;
                const MASK: u8 = 0x03;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u32 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "PIN_CNF14 {{ SENSE: {16:18}, DRIVE: {8:11}, PULL: {2:4}, INPUT: {1}, DIR: {0} }}@15558641222418202220"]
                #[link_section = ".binfmt.PIN_CNF14 {{ SENSE: {16:18}, DRIVE: {8:11}, PULL: {2:4}, INPUT: {1}, DIR: {0} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 0) Pin direction. Same physical register as DIR register"]
            #[allow(non_snake_case)]
            pub fn DIR(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 1) Connect or disconnect input buffer"]
            #[allow(non_snake_case)]
            pub fn INPUT(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 1;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bits 2..=4) Pull configuration"]
            #[allow(non_snake_case)]
            pub fn PULL(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 2;
                const MASK: u8 = 0x03;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bits 8..=11) Drive configuration"]
            #[allow(non_snake_case)]
            pub fn DRIVE(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 8;
                const MASK: u8 = 0x07;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bits 16..=18) Pin sensing mechanism"]
            #[allow(non_snake_case)]
            pub fn SENSE(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 16;
                const MASK: u8 = 0x03;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Description collection: Configuration of GPIO pins"]
    pub type PIN_CNF15 = pin_cnf15::Register;
    #[doc = "Description collection: Configuration of GPIO pins"]
    pub mod pin_cnf15 {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x073c) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bit 0) Pin direction. Same physical register as DIR register"]
            pub fn DIR(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 1) Connect or disconnect input buffer"]
            pub fn INPUT(self) -> u8 {
                const OFFSET: u8 = 1;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bits 2..=4) Pull configuration"]
            pub fn PULL(self) -> u8 {
                const OFFSET: u8 = 2;
                const MASK: u8 = 0x03;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bits 8..=11) Drive configuration"]
            pub fn DRIVE(self) -> u8 {
                const OFFSET: u8 = 8;
                const MASK: u8 = 0x07;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bits 16..=18) Pin sensing mechanism"]
            pub fn SENSE(self) -> u8 {
                const OFFSET: u8 = 16;
                const MASK: u8 = 0x03;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u32 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "PIN_CNF15 {{ SENSE: {16:18}, DRIVE: {8:11}, PULL: {2:4}, INPUT: {1}, DIR: {0} }}@8076334403131381592"]
                #[link_section = ".binfmt.PIN_CNF15 {{ SENSE: {16:18}, DRIVE: {8:11}, PULL: {2:4}, INPUT: {1}, DIR: {0} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 0) Pin direction. Same physical register as DIR register"]
            #[allow(non_snake_case)]
            pub fn DIR(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 1) Connect or disconnect input buffer"]
            #[allow(non_snake_case)]
            pub fn INPUT(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 1;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bits 2..=4) Pull configuration"]
            #[allow(non_snake_case)]
            pub fn PULL(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 2;
                const MASK: u8 = 0x03;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bits 8..=11) Drive configuration"]
            #[allow(non_snake_case)]
            pub fn DRIVE(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 8;
                const MASK: u8 = 0x07;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bits 16..=18) Pin sensing mechanism"]
            #[allow(non_snake_case)]
            pub fn SENSE(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 16;
                const MASK: u8 = 0x03;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Description collection: Configuration of GPIO pins"]
    pub type PIN_CNF16 = pin_cnf16::Register;
    #[doc = "Description collection: Configuration of GPIO pins"]
    pub mod pin_cnf16 {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0740) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bit 0) Pin direction. Same physical register as DIR register"]
            pub fn DIR(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 1) Connect or disconnect input buffer"]
            pub fn INPUT(self) -> u8 {
                const OFFSET: u8 = 1;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bits 2..=4) Pull configuration"]
            pub fn PULL(self) -> u8 {
                const OFFSET: u8 = 2;
                const MASK: u8 = 0x03;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bits 8..=11) Drive configuration"]
            pub fn DRIVE(self) -> u8 {
                const OFFSET: u8 = 8;
                const MASK: u8 = 0x07;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bits 16..=18) Pin sensing mechanism"]
            pub fn SENSE(self) -> u8 {
                const OFFSET: u8 = 16;
                const MASK: u8 = 0x03;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u32 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "PIN_CNF16 {{ SENSE: {16:18}, DRIVE: {8:11}, PULL: {2:4}, INPUT: {1}, DIR: {0} }}@3350780135263041577"]
                #[link_section = ".binfmt.PIN_CNF16 {{ SENSE: {16:18}, DRIVE: {8:11}, PULL: {2:4}, INPUT: {1}, DIR: {0} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 0) Pin direction. Same physical register as DIR register"]
            #[allow(non_snake_case)]
            pub fn DIR(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 1) Connect or disconnect input buffer"]
            #[allow(non_snake_case)]
            pub fn INPUT(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 1;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bits 2..=4) Pull configuration"]
            #[allow(non_snake_case)]
            pub fn PULL(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 2;
                const MASK: u8 = 0x03;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bits 8..=11) Drive configuration"]
            #[allow(non_snake_case)]
            pub fn DRIVE(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 8;
                const MASK: u8 = 0x07;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bits 16..=18) Pin sensing mechanism"]
            #[allow(non_snake_case)]
            pub fn SENSE(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 16;
                const MASK: u8 = 0x03;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Description collection: Configuration of GPIO pins"]
    pub type PIN_CNF17 = pin_cnf17::Register;
    #[doc = "Description collection: Configuration of GPIO pins"]
    pub mod pin_cnf17 {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0744) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bit 0) Pin direction. Same physical register as DIR register"]
            pub fn DIR(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 1) Connect or disconnect input buffer"]
            pub fn INPUT(self) -> u8 {
                const OFFSET: u8 = 1;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bits 2..=4) Pull configuration"]
            pub fn PULL(self) -> u8 {
                const OFFSET: u8 = 2;
                const MASK: u8 = 0x03;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bits 8..=11) Drive configuration"]
            pub fn DRIVE(self) -> u8 {
                const OFFSET: u8 = 8;
                const MASK: u8 = 0x07;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bits 16..=18) Pin sensing mechanism"]
            pub fn SENSE(self) -> u8 {
                const OFFSET: u8 = 16;
                const MASK: u8 = 0x03;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u32 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "PIN_CNF17 {{ SENSE: {16:18}, DRIVE: {8:11}, PULL: {2:4}, INPUT: {1}, DIR: {0} }}@14129865791929998616"]
                #[link_section = ".binfmt.PIN_CNF17 {{ SENSE: {16:18}, DRIVE: {8:11}, PULL: {2:4}, INPUT: {1}, DIR: {0} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 0) Pin direction. Same physical register as DIR register"]
            #[allow(non_snake_case)]
            pub fn DIR(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 1) Connect or disconnect input buffer"]
            #[allow(non_snake_case)]
            pub fn INPUT(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 1;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bits 2..=4) Pull configuration"]
            #[allow(non_snake_case)]
            pub fn PULL(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 2;
                const MASK: u8 = 0x03;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bits 8..=11) Drive configuration"]
            #[allow(non_snake_case)]
            pub fn DRIVE(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 8;
                const MASK: u8 = 0x07;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bits 16..=18) Pin sensing mechanism"]
            #[allow(non_snake_case)]
            pub fn SENSE(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 16;
                const MASK: u8 = 0x03;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Description collection: Configuration of GPIO pins"]
    pub type PIN_CNF18 = pin_cnf18::Register;
    #[doc = "Description collection: Configuration of GPIO pins"]
    pub mod pin_cnf18 {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0748) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bit 0) Pin direction. Same physical register as DIR register"]
            pub fn DIR(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 1) Connect or disconnect input buffer"]
            pub fn INPUT(self) -> u8 {
                const OFFSET: u8 = 1;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bits 2..=4) Pull configuration"]
            pub fn PULL(self) -> u8 {
                const OFFSET: u8 = 2;
                const MASK: u8 = 0x03;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bits 8..=11) Drive configuration"]
            pub fn DRIVE(self) -> u8 {
                const OFFSET: u8 = 8;
                const MASK: u8 = 0x07;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bits 16..=18) Pin sensing mechanism"]
            pub fn SENSE(self) -> u8 {
                const OFFSET: u8 = 16;
                const MASK: u8 = 0x03;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u32 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "PIN_CNF18 {{ SENSE: {16:18}, DRIVE: {8:11}, PULL: {2:4}, INPUT: {1}, DIR: {0} }}@412353784953634312"]
                #[link_section = ".binfmt.PIN_CNF18 {{ SENSE: {16:18}, DRIVE: {8:11}, PULL: {2:4}, INPUT: {1}, DIR: {0} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 0) Pin direction. Same physical register as DIR register"]
            #[allow(non_snake_case)]
            pub fn DIR(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 1) Connect or disconnect input buffer"]
            #[allow(non_snake_case)]
            pub fn INPUT(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 1;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bits 2..=4) Pull configuration"]
            #[allow(non_snake_case)]
            pub fn PULL(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 2;
                const MASK: u8 = 0x03;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bits 8..=11) Drive configuration"]
            #[allow(non_snake_case)]
            pub fn DRIVE(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 8;
                const MASK: u8 = 0x07;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bits 16..=18) Pin sensing mechanism"]
            #[allow(non_snake_case)]
            pub fn SENSE(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 16;
                const MASK: u8 = 0x03;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Description collection: Configuration of GPIO pins"]
    pub type PIN_CNF19 = pin_cnf19::Register;
    #[doc = "Description collection: Configuration of GPIO pins"]
    pub mod pin_cnf19 {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x074c) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bit 0) Pin direction. Same physical register as DIR register"]
            pub fn DIR(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 1) Connect or disconnect input buffer"]
            pub fn INPUT(self) -> u8 {
                const OFFSET: u8 = 1;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bits 2..=4) Pull configuration"]
            pub fn PULL(self) -> u8 {
                const OFFSET: u8 = 2;
                const MASK: u8 = 0x03;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bits 8..=11) Drive configuration"]
            pub fn DRIVE(self) -> u8 {
                const OFFSET: u8 = 8;
                const MASK: u8 = 0x07;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bits 16..=18) Pin sensing mechanism"]
            pub fn SENSE(self) -> u8 {
                const OFFSET: u8 = 16;
                const MASK: u8 = 0x03;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u32 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "PIN_CNF19 {{ SENSE: {16:18}, DRIVE: {8:11}, PULL: {2:4}, INPUT: {1}, DIR: {0} }}@1893288557194207911"]
                #[link_section = ".binfmt.PIN_CNF19 {{ SENSE: {16:18}, DRIVE: {8:11}, PULL: {2:4}, INPUT: {1}, DIR: {0} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 0) Pin direction. Same physical register as DIR register"]
            #[allow(non_snake_case)]
            pub fn DIR(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 1) Connect or disconnect input buffer"]
            #[allow(non_snake_case)]
            pub fn INPUT(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 1;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bits 2..=4) Pull configuration"]
            #[allow(non_snake_case)]
            pub fn PULL(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 2;
                const MASK: u8 = 0x03;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bits 8..=11) Drive configuration"]
            #[allow(non_snake_case)]
            pub fn DRIVE(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 8;
                const MASK: u8 = 0x07;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bits 16..=18) Pin sensing mechanism"]
            #[allow(non_snake_case)]
            pub fn SENSE(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 16;
                const MASK: u8 = 0x03;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Description collection: Configuration of GPIO pins"]
    pub type PIN_CNF20 = pin_cnf20::Register;
    #[doc = "Description collection: Configuration of GPIO pins"]
    pub mod pin_cnf20 {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0750) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bit 0) Pin direction. Same physical register as DIR register"]
            pub fn DIR(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 1) Connect or disconnect input buffer"]
            pub fn INPUT(self) -> u8 {
                const OFFSET: u8 = 1;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bits 2..=4) Pull configuration"]
            pub fn PULL(self) -> u8 {
                const OFFSET: u8 = 2;
                const MASK: u8 = 0x03;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bits 8..=11) Drive configuration"]
            pub fn DRIVE(self) -> u8 {
                const OFFSET: u8 = 8;
                const MASK: u8 = 0x07;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bits 16..=18) Pin sensing mechanism"]
            pub fn SENSE(self) -> u8 {
                const OFFSET: u8 = 16;
                const MASK: u8 = 0x03;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u32 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "PIN_CNF20 {{ SENSE: {16:18}, DRIVE: {8:11}, PULL: {2:4}, INPUT: {1}, DIR: {0} }}@7371479225028243479"]
                #[link_section = ".binfmt.PIN_CNF20 {{ SENSE: {16:18}, DRIVE: {8:11}, PULL: {2:4}, INPUT: {1}, DIR: {0} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 0) Pin direction. Same physical register as DIR register"]
            #[allow(non_snake_case)]
            pub fn DIR(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 1) Connect or disconnect input buffer"]
            #[allow(non_snake_case)]
            pub fn INPUT(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 1;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bits 2..=4) Pull configuration"]
            #[allow(non_snake_case)]
            pub fn PULL(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 2;
                const MASK: u8 = 0x03;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bits 8..=11) Drive configuration"]
            #[allow(non_snake_case)]
            pub fn DRIVE(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 8;
                const MASK: u8 = 0x07;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bits 16..=18) Pin sensing mechanism"]
            #[allow(non_snake_case)]
            pub fn SENSE(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 16;
                const MASK: u8 = 0x03;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Description collection: Configuration of GPIO pins"]
    pub type PIN_CNF21 = pin_cnf21::Register;
    #[doc = "Description collection: Configuration of GPIO pins"]
    pub mod pin_cnf21 {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0754) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bit 0) Pin direction. Same physical register as DIR register"]
            pub fn DIR(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 1) Connect or disconnect input buffer"]
            pub fn INPUT(self) -> u8 {
                const OFFSET: u8 = 1;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bits 2..=4) Pull configuration"]
            pub fn PULL(self) -> u8 {
                const OFFSET: u8 = 2;
                const MASK: u8 = 0x03;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bits 8..=11) Drive configuration"]
            pub fn DRIVE(self) -> u8 {
                const OFFSET: u8 = 8;
                const MASK: u8 = 0x07;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bits 16..=18) Pin sensing mechanism"]
            pub fn SENSE(self) -> u8 {
                const OFFSET: u8 = 16;
                const MASK: u8 = 0x03;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u32 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "PIN_CNF21 {{ SENSE: {16:18}, DRIVE: {8:11}, PULL: {2:4}, INPUT: {1}, DIR: {0} }}@15062426074750737784"]
                #[link_section = ".binfmt.PIN_CNF21 {{ SENSE: {16:18}, DRIVE: {8:11}, PULL: {2:4}, INPUT: {1}, DIR: {0} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 0) Pin direction. Same physical register as DIR register"]
            #[allow(non_snake_case)]
            pub fn DIR(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 1) Connect or disconnect input buffer"]
            #[allow(non_snake_case)]
            pub fn INPUT(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 1;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bits 2..=4) Pull configuration"]
            #[allow(non_snake_case)]
            pub fn PULL(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 2;
                const MASK: u8 = 0x03;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bits 8..=11) Drive configuration"]
            #[allow(non_snake_case)]
            pub fn DRIVE(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 8;
                const MASK: u8 = 0x07;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bits 16..=18) Pin sensing mechanism"]
            #[allow(non_snake_case)]
            pub fn SENSE(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 16;
                const MASK: u8 = 0x03;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Description collection: Configuration of GPIO pins"]
    pub type PIN_CNF22 = pin_cnf22::Register;
    #[doc = "Description collection: Configuration of GPIO pins"]
    pub mod pin_cnf22 {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0758) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bit 0) Pin direction. Same physical register as DIR register"]
            pub fn DIR(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 1) Connect or disconnect input buffer"]
            pub fn INPUT(self) -> u8 {
                const OFFSET: u8 = 1;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bits 2..=4) Pull configuration"]
            pub fn PULL(self) -> u8 {
                const OFFSET: u8 = 2;
                const MASK: u8 = 0x03;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bits 8..=11) Drive configuration"]
            pub fn DRIVE(self) -> u8 {
                const OFFSET: u8 = 8;
                const MASK: u8 = 0x07;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bits 16..=18) Pin sensing mechanism"]
            pub fn SENSE(self) -> u8 {
                const OFFSET: u8 = 16;
                const MASK: u8 = 0x03;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u32 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "PIN_CNF22 {{ SENSE: {16:18}, DRIVE: {8:11}, PULL: {2:4}, INPUT: {1}, DIR: {0} }}@11693499016737281227"]
                #[link_section = ".binfmt.PIN_CNF22 {{ SENSE: {16:18}, DRIVE: {8:11}, PULL: {2:4}, INPUT: {1}, DIR: {0} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 0) Pin direction. Same physical register as DIR register"]
            #[allow(non_snake_case)]
            pub fn DIR(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 1) Connect or disconnect input buffer"]
            #[allow(non_snake_case)]
            pub fn INPUT(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 1;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bits 2..=4) Pull configuration"]
            #[allow(non_snake_case)]
            pub fn PULL(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 2;
                const MASK: u8 = 0x03;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bits 8..=11) Drive configuration"]
            #[allow(non_snake_case)]
            pub fn DRIVE(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 8;
                const MASK: u8 = 0x07;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bits 16..=18) Pin sensing mechanism"]
            #[allow(non_snake_case)]
            pub fn SENSE(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 16;
                const MASK: u8 = 0x03;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Description collection: Configuration of GPIO pins"]
    pub type PIN_CNF23 = pin_cnf23::Register;
    #[doc = "Description collection: Configuration of GPIO pins"]
    pub mod pin_cnf23 {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x075c) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bit 0) Pin direction. Same physical register as DIR register"]
            pub fn DIR(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 1) Connect or disconnect input buffer"]
            pub fn INPUT(self) -> u8 {
                const OFFSET: u8 = 1;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bits 2..=4) Pull configuration"]
            pub fn PULL(self) -> u8 {
                const OFFSET: u8 = 2;
                const MASK: u8 = 0x03;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bits 8..=11) Drive configuration"]
            pub fn DRIVE(self) -> u8 {
                const OFFSET: u8 = 8;
                const MASK: u8 = 0x07;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bits 16..=18) Pin sensing mechanism"]
            pub fn SENSE(self) -> u8 {
                const OFFSET: u8 = 16;
                const MASK: u8 = 0x03;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u32 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "PIN_CNF23 {{ SENSE: {16:18}, DRIVE: {8:11}, PULL: {2:4}, INPUT: {1}, DIR: {0} }}@286532294553296075"]
                #[link_section = ".binfmt.PIN_CNF23 {{ SENSE: {16:18}, DRIVE: {8:11}, PULL: {2:4}, INPUT: {1}, DIR: {0} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 0) Pin direction. Same physical register as DIR register"]
            #[allow(non_snake_case)]
            pub fn DIR(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 1) Connect or disconnect input buffer"]
            #[allow(non_snake_case)]
            pub fn INPUT(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 1;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bits 2..=4) Pull configuration"]
            #[allow(non_snake_case)]
            pub fn PULL(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 2;
                const MASK: u8 = 0x03;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bits 8..=11) Drive configuration"]
            #[allow(non_snake_case)]
            pub fn DRIVE(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 8;
                const MASK: u8 = 0x07;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bits 16..=18) Pin sensing mechanism"]
            #[allow(non_snake_case)]
            pub fn SENSE(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 16;
                const MASK: u8 = 0x03;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Description collection: Configuration of GPIO pins"]
    pub type PIN_CNF24 = pin_cnf24::Register;
    #[doc = "Description collection: Configuration of GPIO pins"]
    pub mod pin_cnf24 {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0760) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bit 0) Pin direction. Same physical register as DIR register"]
            pub fn DIR(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 1) Connect or disconnect input buffer"]
            pub fn INPUT(self) -> u8 {
                const OFFSET: u8 = 1;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bits 2..=4) Pull configuration"]
            pub fn PULL(self) -> u8 {
                const OFFSET: u8 = 2;
                const MASK: u8 = 0x03;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bits 8..=11) Drive configuration"]
            pub fn DRIVE(self) -> u8 {
                const OFFSET: u8 = 8;
                const MASK: u8 = 0x07;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bits 16..=18) Pin sensing mechanism"]
            pub fn SENSE(self) -> u8 {
                const OFFSET: u8 = 16;
                const MASK: u8 = 0x03;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u32 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "PIN_CNF24 {{ SENSE: {16:18}, DRIVE: {8:11}, PULL: {2:4}, INPUT: {1}, DIR: {0} }}@3753084731281267746"]
                #[link_section = ".binfmt.PIN_CNF24 {{ SENSE: {16:18}, DRIVE: {8:11}, PULL: {2:4}, INPUT: {1}, DIR: {0} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 0) Pin direction. Same physical register as DIR register"]
            #[allow(non_snake_case)]
            pub fn DIR(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 1) Connect or disconnect input buffer"]
            #[allow(non_snake_case)]
            pub fn INPUT(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 1;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bits 2..=4) Pull configuration"]
            #[allow(non_snake_case)]
            pub fn PULL(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 2;
                const MASK: u8 = 0x03;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bits 8..=11) Drive configuration"]
            #[allow(non_snake_case)]
            pub fn DRIVE(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 8;
                const MASK: u8 = 0x07;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bits 16..=18) Pin sensing mechanism"]
            #[allow(non_snake_case)]
            pub fn SENSE(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 16;
                const MASK: u8 = 0x03;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Description collection: Configuration of GPIO pins"]
    pub type PIN_CNF25 = pin_cnf25::Register;
    #[doc = "Description collection: Configuration of GPIO pins"]
    pub mod pin_cnf25 {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0764) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bit 0) Pin direction. Same physical register as DIR register"]
            pub fn DIR(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 1) Connect or disconnect input buffer"]
            pub fn INPUT(self) -> u8 {
                const OFFSET: u8 = 1;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bits 2..=4) Pull configuration"]
            pub fn PULL(self) -> u8 {
                const OFFSET: u8 = 2;
                const MASK: u8 = 0x03;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bits 8..=11) Drive configuration"]
            pub fn DRIVE(self) -> u8 {
                const OFFSET: u8 = 8;
                const MASK: u8 = 0x07;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bits 16..=18) Pin sensing mechanism"]
            pub fn SENSE(self) -> u8 {
                const OFFSET: u8 = 16;
                const MASK: u8 = 0x03;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u32 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "PIN_CNF25 {{ SENSE: {16:18}, DRIVE: {8:11}, PULL: {2:4}, INPUT: {1}, DIR: {0} }}@6871139152781525088"]
                #[link_section = ".binfmt.PIN_CNF25 {{ SENSE: {16:18}, DRIVE: {8:11}, PULL: {2:4}, INPUT: {1}, DIR: {0} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 0) Pin direction. Same physical register as DIR register"]
            #[allow(non_snake_case)]
            pub fn DIR(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 1) Connect or disconnect input buffer"]
            #[allow(non_snake_case)]
            pub fn INPUT(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 1;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bits 2..=4) Pull configuration"]
            #[allow(non_snake_case)]
            pub fn PULL(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 2;
                const MASK: u8 = 0x03;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bits 8..=11) Drive configuration"]
            #[allow(non_snake_case)]
            pub fn DRIVE(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 8;
                const MASK: u8 = 0x07;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bits 16..=18) Pin sensing mechanism"]
            #[allow(non_snake_case)]
            pub fn SENSE(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 16;
                const MASK: u8 = 0x03;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Description collection: Configuration of GPIO pins"]
    pub type PIN_CNF26 = pin_cnf26::Register;
    #[doc = "Description collection: Configuration of GPIO pins"]
    pub mod pin_cnf26 {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0768) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bit 0) Pin direction. Same physical register as DIR register"]
            pub fn DIR(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 1) Connect or disconnect input buffer"]
            pub fn INPUT(self) -> u8 {
                const OFFSET: u8 = 1;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bits 2..=4) Pull configuration"]
            pub fn PULL(self) -> u8 {
                const OFFSET: u8 = 2;
                const MASK: u8 = 0x03;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bits 8..=11) Drive configuration"]
            pub fn DRIVE(self) -> u8 {
                const OFFSET: u8 = 8;
                const MASK: u8 = 0x07;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bits 16..=18) Pin sensing mechanism"]
            pub fn SENSE(self) -> u8 {
                const OFFSET: u8 = 16;
                const MASK: u8 = 0x03;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u32 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "PIN_CNF26 {{ SENSE: {16:18}, DRIVE: {8:11}, PULL: {2:4}, INPUT: {1}, DIR: {0} }}@16126443101950926882"]
                #[link_section = ".binfmt.PIN_CNF26 {{ SENSE: {16:18}, DRIVE: {8:11}, PULL: {2:4}, INPUT: {1}, DIR: {0} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 0) Pin direction. Same physical register as DIR register"]
            #[allow(non_snake_case)]
            pub fn DIR(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 1) Connect or disconnect input buffer"]
            #[allow(non_snake_case)]
            pub fn INPUT(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 1;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bits 2..=4) Pull configuration"]
            #[allow(non_snake_case)]
            pub fn PULL(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 2;
                const MASK: u8 = 0x03;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bits 8..=11) Drive configuration"]
            #[allow(non_snake_case)]
            pub fn DRIVE(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 8;
                const MASK: u8 = 0x07;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bits 16..=18) Pin sensing mechanism"]
            #[allow(non_snake_case)]
            pub fn SENSE(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 16;
                const MASK: u8 = 0x03;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Description collection: Configuration of GPIO pins"]
    pub type PIN_CNF27 = pin_cnf27::Register;
    #[doc = "Description collection: Configuration of GPIO pins"]
    pub mod pin_cnf27 {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x076c) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bit 0) Pin direction. Same physical register as DIR register"]
            pub fn DIR(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 1) Connect or disconnect input buffer"]
            pub fn INPUT(self) -> u8 {
                const OFFSET: u8 = 1;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bits 2..=4) Pull configuration"]
            pub fn PULL(self) -> u8 {
                const OFFSET: u8 = 2;
                const MASK: u8 = 0x03;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bits 8..=11) Drive configuration"]
            pub fn DRIVE(self) -> u8 {
                const OFFSET: u8 = 8;
                const MASK: u8 = 0x07;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bits 16..=18) Pin sensing mechanism"]
            pub fn SENSE(self) -> u8 {
                const OFFSET: u8 = 16;
                const MASK: u8 = 0x03;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u32 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "PIN_CNF27 {{ SENSE: {16:18}, DRIVE: {8:11}, PULL: {2:4}, INPUT: {1}, DIR: {0} }}@6360460614751234134"]
                #[link_section = ".binfmt.PIN_CNF27 {{ SENSE: {16:18}, DRIVE: {8:11}, PULL: {2:4}, INPUT: {1}, DIR: {0} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 0) Pin direction. Same physical register as DIR register"]
            #[allow(non_snake_case)]
            pub fn DIR(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 1) Connect or disconnect input buffer"]
            #[allow(non_snake_case)]
            pub fn INPUT(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 1;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bits 2..=4) Pull configuration"]
            #[allow(non_snake_case)]
            pub fn PULL(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 2;
                const MASK: u8 = 0x03;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bits 8..=11) Drive configuration"]
            #[allow(non_snake_case)]
            pub fn DRIVE(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 8;
                const MASK: u8 = 0x07;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bits 16..=18) Pin sensing mechanism"]
            #[allow(non_snake_case)]
            pub fn SENSE(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 16;
                const MASK: u8 = 0x03;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Description collection: Configuration of GPIO pins"]
    pub type PIN_CNF28 = pin_cnf28::Register;
    #[doc = "Description collection: Configuration of GPIO pins"]
    pub mod pin_cnf28 {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0770) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bit 0) Pin direction. Same physical register as DIR register"]
            pub fn DIR(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 1) Connect or disconnect input buffer"]
            pub fn INPUT(self) -> u8 {
                const OFFSET: u8 = 1;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bits 2..=4) Pull configuration"]
            pub fn PULL(self) -> u8 {
                const OFFSET: u8 = 2;
                const MASK: u8 = 0x03;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bits 8..=11) Drive configuration"]
            pub fn DRIVE(self) -> u8 {
                const OFFSET: u8 = 8;
                const MASK: u8 = 0x07;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bits 16..=18) Pin sensing mechanism"]
            pub fn SENSE(self) -> u8 {
                const OFFSET: u8 = 16;
                const MASK: u8 = 0x03;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u32 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "PIN_CNF28 {{ SENSE: {16:18}, DRIVE: {8:11}, PULL: {2:4}, INPUT: {1}, DIR: {0} }}@1125863119206074976"]
                #[link_section = ".binfmt.PIN_CNF28 {{ SENSE: {16:18}, DRIVE: {8:11}, PULL: {2:4}, INPUT: {1}, DIR: {0} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 0) Pin direction. Same physical register as DIR register"]
            #[allow(non_snake_case)]
            pub fn DIR(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 1) Connect or disconnect input buffer"]
            #[allow(non_snake_case)]
            pub fn INPUT(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 1;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bits 2..=4) Pull configuration"]
            #[allow(non_snake_case)]
            pub fn PULL(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 2;
                const MASK: u8 = 0x03;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bits 8..=11) Drive configuration"]
            #[allow(non_snake_case)]
            pub fn DRIVE(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 8;
                const MASK: u8 = 0x07;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bits 16..=18) Pin sensing mechanism"]
            #[allow(non_snake_case)]
            pub fn SENSE(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 16;
                const MASK: u8 = 0x03;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Description collection: Configuration of GPIO pins"]
    pub type PIN_CNF29 = pin_cnf29::Register;
    #[doc = "Description collection: Configuration of GPIO pins"]
    pub mod pin_cnf29 {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0774) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bit 0) Pin direction. Same physical register as DIR register"]
            pub fn DIR(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 1) Connect or disconnect input buffer"]
            pub fn INPUT(self) -> u8 {
                const OFFSET: u8 = 1;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bits 2..=4) Pull configuration"]
            pub fn PULL(self) -> u8 {
                const OFFSET: u8 = 2;
                const MASK: u8 = 0x03;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bits 8..=11) Drive configuration"]
            pub fn DRIVE(self) -> u8 {
                const OFFSET: u8 = 8;
                const MASK: u8 = 0x07;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bits 16..=18) Pin sensing mechanism"]
            pub fn SENSE(self) -> u8 {
                const OFFSET: u8 = 16;
                const MASK: u8 = 0x03;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u32 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "PIN_CNF29 {{ SENSE: {16:18}, DRIVE: {8:11}, PULL: {2:4}, INPUT: {1}, DIR: {0} }}@5759056806907091383"]
                #[link_section = ".binfmt.PIN_CNF29 {{ SENSE: {16:18}, DRIVE: {8:11}, PULL: {2:4}, INPUT: {1}, DIR: {0} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 0) Pin direction. Same physical register as DIR register"]
            #[allow(non_snake_case)]
            pub fn DIR(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 1) Connect or disconnect input buffer"]
            #[allow(non_snake_case)]
            pub fn INPUT(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 1;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bits 2..=4) Pull configuration"]
            #[allow(non_snake_case)]
            pub fn PULL(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 2;
                const MASK: u8 = 0x03;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bits 8..=11) Drive configuration"]
            #[allow(non_snake_case)]
            pub fn DRIVE(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 8;
                const MASK: u8 = 0x07;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bits 16..=18) Pin sensing mechanism"]
            #[allow(non_snake_case)]
            pub fn SENSE(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 16;
                const MASK: u8 = 0x03;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Description collection: Configuration of GPIO pins"]
    pub type PIN_CNF30 = pin_cnf30::Register;
    #[doc = "Description collection: Configuration of GPIO pins"]
    pub mod pin_cnf30 {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0778) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bit 0) Pin direction. Same physical register as DIR register"]
            pub fn DIR(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 1) Connect or disconnect input buffer"]
            pub fn INPUT(self) -> u8 {
                const OFFSET: u8 = 1;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bits 2..=4) Pull configuration"]
            pub fn PULL(self) -> u8 {
                const OFFSET: u8 = 2;
                const MASK: u8 = 0x03;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bits 8..=11) Drive configuration"]
            pub fn DRIVE(self) -> u8 {
                const OFFSET: u8 = 8;
                const MASK: u8 = 0x07;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bits 16..=18) Pin sensing mechanism"]
            pub fn SENSE(self) -> u8 {
                const OFFSET: u8 = 16;
                const MASK: u8 = 0x03;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u32 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "PIN_CNF30 {{ SENSE: {16:18}, DRIVE: {8:11}, PULL: {2:4}, INPUT: {1}, DIR: {0} }}@16538288167956589296"]
                #[link_section = ".binfmt.PIN_CNF30 {{ SENSE: {16:18}, DRIVE: {8:11}, PULL: {2:4}, INPUT: {1}, DIR: {0} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 0) Pin direction. Same physical register as DIR register"]
            #[allow(non_snake_case)]
            pub fn DIR(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 1) Connect or disconnect input buffer"]
            #[allow(non_snake_case)]
            pub fn INPUT(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 1;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bits 2..=4) Pull configuration"]
            #[allow(non_snake_case)]
            pub fn PULL(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 2;
                const MASK: u8 = 0x03;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bits 8..=11) Drive configuration"]
            #[allow(non_snake_case)]
            pub fn DRIVE(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 8;
                const MASK: u8 = 0x07;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bits 16..=18) Pin sensing mechanism"]
            #[allow(non_snake_case)]
            pub fn SENSE(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 16;
                const MASK: u8 = 0x03;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Description collection: Configuration of GPIO pins"]
    pub type PIN_CNF31 = pin_cnf31::Register;
    #[doc = "Description collection: Configuration of GPIO pins"]
    pub mod pin_cnf31 {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x077c) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bit 0) Pin direction. Same physical register as DIR register"]
            pub fn DIR(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 1) Connect or disconnect input buffer"]
            pub fn INPUT(self) -> u8 {
                const OFFSET: u8 = 1;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bits 2..=4) Pull configuration"]
            pub fn PULL(self) -> u8 {
                const OFFSET: u8 = 2;
                const MASK: u8 = 0x03;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bits 8..=11) Drive configuration"]
            pub fn DRIVE(self) -> u8 {
                const OFFSET: u8 = 8;
                const MASK: u8 = 0x07;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bits 16..=18) Pin sensing mechanism"]
            pub fn SENSE(self) -> u8 {
                const OFFSET: u8 = 16;
                const MASK: u8 = 0x03;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u32 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "PIN_CNF31 {{ SENSE: {16:18}, DRIVE: {8:11}, PULL: {2:4}, INPUT: {1}, DIR: {0} }}@616124153139839953"]
                #[link_section = ".binfmt.PIN_CNF31 {{ SENSE: {16:18}, DRIVE: {8:11}, PULL: {2:4}, INPUT: {1}, DIR: {0} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 0) Pin direction. Same physical register as DIR register"]
            #[allow(non_snake_case)]
            pub fn DIR(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 1) Connect or disconnect input buffer"]
            #[allow(non_snake_case)]
            pub fn INPUT(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 1;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bits 2..=4) Pull configuration"]
            #[allow(non_snake_case)]
            pub fn PULL(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 2;
                const MASK: u8 = 0x03;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bits 8..=11) Drive configuration"]
            #[allow(non_snake_case)]
            pub fn DRIVE(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 8;
                const MASK: u8 = 0x07;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bits 16..=18) Pin sensing mechanism"]
            #[allow(non_snake_case)]
            pub fn SENSE(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 16;
                const MASK: u8 = 0x03;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    use core::sync::atomic::{AtomicBool, Ordering};
    const BASE_ADDRESS: usize = 0x5000_0000;
    #[allow(non_snake_case)]
    #[doc = "Singleton handle to the P0 registers"]
    pub struct Registers {
        #[doc = "Write GPIO port"]
        pub OUT: OUT,
        #[doc = "Set individual bits in GPIO port"]
        pub OUTSET: OUTSET,
        #[doc = "Clear individual bits in GPIO port"]
        pub OUTCLR: OUTCLR,
        #[doc = "Read GPIO port"]
        pub IN: IN,
        #[doc = "Direction of GPIO pins"]
        pub DIR: DIR,
        #[doc = "DIR set register"]
        pub DIRSET: DIRSET,
        #[doc = "DIR clear register"]
        pub DIRCLR: DIRCLR,
        #[doc = "Latch register indicating what GPIO pins that have met the criteria set in the PIN_CNF[n].SENSE registers"]
        pub LATCH: LATCH,
        #[doc = "Select between default DETECT signal behaviour and LDETECT mode"]
        pub DETECTMODE: DETECTMODE,
        #[doc = "Description collection: Configuration of GPIO pins"]
        pub PIN_CNF0: PIN_CNF0,
        #[doc = "Description collection: Configuration of GPIO pins"]
        pub PIN_CNF1: PIN_CNF1,
        #[doc = "Description collection: Configuration of GPIO pins"]
        pub PIN_CNF2: PIN_CNF2,
        #[doc = "Description collection: Configuration of GPIO pins"]
        pub PIN_CNF3: PIN_CNF3,
        #[doc = "Description collection: Configuration of GPIO pins"]
        pub PIN_CNF4: PIN_CNF4,
        #[doc = "Description collection: Configuration of GPIO pins"]
        pub PIN_CNF5: PIN_CNF5,
        #[doc = "Description collection: Configuration of GPIO pins"]
        pub PIN_CNF6: PIN_CNF6,
        #[doc = "Description collection: Configuration of GPIO pins"]
        pub PIN_CNF7: PIN_CNF7,
        #[doc = "Description collection: Configuration of GPIO pins"]
        pub PIN_CNF8: PIN_CNF8,
        #[doc = "Description collection: Configuration of GPIO pins"]
        pub PIN_CNF9: PIN_CNF9,
        #[doc = "Description collection: Configuration of GPIO pins"]
        pub PIN_CNF10: PIN_CNF10,
        #[doc = "Description collection: Configuration of GPIO pins"]
        pub PIN_CNF11: PIN_CNF11,
        #[doc = "Description collection: Configuration of GPIO pins"]
        pub PIN_CNF12: PIN_CNF12,
        #[doc = "Description collection: Configuration of GPIO pins"]
        pub PIN_CNF13: PIN_CNF13,
        #[doc = "Description collection: Configuration of GPIO pins"]
        pub PIN_CNF14: PIN_CNF14,
        #[doc = "Description collection: Configuration of GPIO pins"]
        pub PIN_CNF15: PIN_CNF15,
        #[doc = "Description collection: Configuration of GPIO pins"]
        pub PIN_CNF16: PIN_CNF16,
        #[doc = "Description collection: Configuration of GPIO pins"]
        pub PIN_CNF17: PIN_CNF17,
        #[doc = "Description collection: Configuration of GPIO pins"]
        pub PIN_CNF18: PIN_CNF18,
        #[doc = "Description collection: Configuration of GPIO pins"]
        pub PIN_CNF19: PIN_CNF19,
        #[doc = "Description collection: Configuration of GPIO pins"]
        pub PIN_CNF20: PIN_CNF20,
        #[doc = "Description collection: Configuration of GPIO pins"]
        pub PIN_CNF21: PIN_CNF21,
        #[doc = "Description collection: Configuration of GPIO pins"]
        pub PIN_CNF22: PIN_CNF22,
        #[doc = "Description collection: Configuration of GPIO pins"]
        pub PIN_CNF23: PIN_CNF23,
        #[doc = "Description collection: Configuration of GPIO pins"]
        pub PIN_CNF24: PIN_CNF24,
        #[doc = "Description collection: Configuration of GPIO pins"]
        pub PIN_CNF25: PIN_CNF25,
        #[doc = "Description collection: Configuration of GPIO pins"]
        pub PIN_CNF26: PIN_CNF26,
        #[doc = "Description collection: Configuration of GPIO pins"]
        pub PIN_CNF27: PIN_CNF27,
        #[doc = "Description collection: Configuration of GPIO pins"]
        pub PIN_CNF28: PIN_CNF28,
        #[doc = "Description collection: Configuration of GPIO pins"]
        pub PIN_CNF29: PIN_CNF29,
        #[doc = "Description collection: Configuration of GPIO pins"]
        pub PIN_CNF30: PIN_CNF30,
        #[doc = "Description collection: Configuration of GPIO pins"]
        pub PIN_CNF31: PIN_CNF31,
    }
    unsafe impl Send for Registers {}
    impl Registers {
        #[doc = r" # Safety"]
        #[doc = r" Singleton"]
        unsafe fn new() -> Self {
            Self {
                OUT: OUT::new(),
                OUTSET: OUTSET::new(),
                OUTCLR: OUTCLR::new(),
                IN: IN::new(),
                DIR: DIR::new(),
                DIRSET: DIRSET::new(),
                DIRCLR: DIRCLR::new(),
                LATCH: LATCH::new(),
                DETECTMODE: DETECTMODE::new(),
                PIN_CNF0: PIN_CNF0::new(),
                PIN_CNF1: PIN_CNF1::new(),
                PIN_CNF2: PIN_CNF2::new(),
                PIN_CNF3: PIN_CNF3::new(),
                PIN_CNF4: PIN_CNF4::new(),
                PIN_CNF5: PIN_CNF5::new(),
                PIN_CNF6: PIN_CNF6::new(),
                PIN_CNF7: PIN_CNF7::new(),
                PIN_CNF8: PIN_CNF8::new(),
                PIN_CNF9: PIN_CNF9::new(),
                PIN_CNF10: PIN_CNF10::new(),
                PIN_CNF11: PIN_CNF11::new(),
                PIN_CNF12: PIN_CNF12::new(),
                PIN_CNF13: PIN_CNF13::new(),
                PIN_CNF14: PIN_CNF14::new(),
                PIN_CNF15: PIN_CNF15::new(),
                PIN_CNF16: PIN_CNF16::new(),
                PIN_CNF17: PIN_CNF17::new(),
                PIN_CNF18: PIN_CNF18::new(),
                PIN_CNF19: PIN_CNF19::new(),
                PIN_CNF20: PIN_CNF20::new(),
                PIN_CNF21: PIN_CNF21::new(),
                PIN_CNF22: PIN_CNF22::new(),
                PIN_CNF23: PIN_CNF23::new(),
                PIN_CNF24: PIN_CNF24::new(),
                PIN_CNF25: PIN_CNF25::new(),
                PIN_CNF26: PIN_CNF26::new(),
                PIN_CNF27: PIN_CNF27::new(),
                PIN_CNF28: PIN_CNF28::new(),
                PIN_CNF29: PIN_CNF29::new(),
                PIN_CNF30: PIN_CNF30::new(),
                PIN_CNF31: PIN_CNF31::new(),
            }
        }
        fn taken() -> &'static AtomicBool {
            static TAKEN: AtomicBool = AtomicBool::new(false);
            &TAKEN
        }
        #[doc = r" Grants temporary access to the peripheral, without checking if it has already been"]
        #[doc = r" taken"]
        #[inline(always)]
        pub fn borrow_unchecked<T>(f: impl FnOnce(&Self) -> T) -> T {
            f(unsafe { &Self::new() })
        }
        #[doc = r" Seals the peripheral making it impossible to `take` it"]
        pub fn seal() {
            Self::taken().store(true, Ordering::Relaxed)
        }
        #[doc = r" Takes ownership of the peripheral"]
        #[doc = r""]
        #[doc = r" This constructor returns the `Some` variant only once"]
        pub fn take() -> Option<Self> {
            let taken = Self::taken();
            if taken
                .compare_exchange(false, true, Ordering::Relaxed, Ordering::Relaxed)
                .is_ok()
            {
                Some(unsafe { Self::new() })
            } else {
                None
            }
        }
    }
}
#[allow(non_camel_case_types)]
#[cfg(feature = "RADIO")]
#[doc = "2.4 GHz radio"]
pub type RADIO = radio::Registers;
#[cfg(feature = "RADIO")]
#[doc = "2.4 GHz radio"]
pub mod radio {
    #[allow(non_camel_case_types)]
    #[doc = "Enable RADIO in TX mode"]
    pub type TASKS_TXEN = tasks_txen::Register;
    #[doc = "Enable RADIO in TX mode"]
    pub mod tasks_txen {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                super::BASE_ADDRESS as *mut _
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 0) Enable RADIO in TX mode"]
            #[allow(non_snake_case)]
            pub fn TASKS_TXEN(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Enable RADIO in RX mode"]
    pub type TASKS_RXEN = tasks_rxen::Register;
    #[doc = "Enable RADIO in RX mode"]
    pub mod tasks_rxen {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x04) as *mut _
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 0) Enable RADIO in RX mode"]
            #[allow(non_snake_case)]
            pub fn TASKS_RXEN(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Start RADIO"]
    pub type TASKS_START = tasks_start::Register;
    #[doc = "Start RADIO"]
    pub mod tasks_start {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x08) as *mut _
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 0) Start RADIO"]
            #[allow(non_snake_case)]
            pub fn TASKS_START(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Stop RADIO"]
    pub type TASKS_STOP = tasks_stop::Register;
    #[doc = "Stop RADIO"]
    pub mod tasks_stop {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0c) as *mut _
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 0) Stop RADIO"]
            #[allow(non_snake_case)]
            pub fn TASKS_STOP(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Disable RADIO"]
    pub type TASKS_DISABLE = tasks_disable::Register;
    #[doc = "Disable RADIO"]
    pub mod tasks_disable {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x10) as *mut _
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 0) Disable RADIO"]
            #[allow(non_snake_case)]
            pub fn TASKS_DISABLE(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Start the RSSI and take one single sample of the receive signal strength"]
    pub type TASKS_RSSISTART = tasks_rssistart::Register;
    #[doc = "Start the RSSI and take one single sample of the receive signal strength"]
    pub mod tasks_rssistart {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x14) as *mut _
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 0) Start the RSSI and take one single sample of the receive signal strength"]
            #[allow(non_snake_case)]
            pub fn TASKS_RSSISTART(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Stop the RSSI measurement"]
    pub type TASKS_RSSISTOP = tasks_rssistop::Register;
    #[doc = "Stop the RSSI measurement"]
    pub mod tasks_rssistop {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x18) as *mut _
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 0) Stop the RSSI measurement"]
            #[allow(non_snake_case)]
            pub fn TASKS_RSSISTOP(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Start the bit counter"]
    pub type TASKS_BCSTART = tasks_bcstart::Register;
    #[doc = "Start the bit counter"]
    pub mod tasks_bcstart {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x1c) as *mut _
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 0) Start the bit counter"]
            #[allow(non_snake_case)]
            pub fn TASKS_BCSTART(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Stop the bit counter"]
    pub type TASKS_BCSTOP = tasks_bcstop::Register;
    #[doc = "Stop the bit counter"]
    pub mod tasks_bcstop {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x20) as *mut _
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 0) Stop the bit counter"]
            #[allow(non_snake_case)]
            pub fn TASKS_BCSTOP(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Start the energy detect measurement used in IEEE 802.15.4 mode"]
    pub type TASKS_EDSTART = tasks_edstart::Register;
    #[doc = "Start the energy detect measurement used in IEEE 802.15.4 mode"]
    pub mod tasks_edstart {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x24) as *mut _
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 0) Start the energy detect measurement used in IEEE 802.15.4 mode"]
            #[allow(non_snake_case)]
            pub fn TASKS_EDSTART(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Stop the energy detect measurement"]
    pub type TASKS_EDSTOP = tasks_edstop::Register;
    #[doc = "Stop the energy detect measurement"]
    pub mod tasks_edstop {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x28) as *mut _
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 0) Stop the energy detect measurement"]
            #[allow(non_snake_case)]
            pub fn TASKS_EDSTOP(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Start the clear channel assessment used in IEEE 802.15.4 mode"]
    pub type TASKS_CCASTART = tasks_ccastart::Register;
    #[doc = "Start the clear channel assessment used in IEEE 802.15.4 mode"]
    pub mod tasks_ccastart {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x2c) as *mut _
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 0) Start the clear channel assessment used in IEEE 802.15.4 mode"]
            #[allow(non_snake_case)]
            pub fn TASKS_CCASTART(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Stop the clear channel assessment"]
    pub type TASKS_CCASTOP = tasks_ccastop::Register;
    #[doc = "Stop the clear channel assessment"]
    pub mod tasks_ccastop {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x30) as *mut _
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 0) Stop the clear channel assessment"]
            #[allow(non_snake_case)]
            pub fn TASKS_CCASTOP(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "RADIO has ramped up and is ready to be started"]
    pub type EVENTS_READY = events_ready::Register;
    #[doc = "RADIO has ramped up and is ready to be started"]
    pub mod events_ready {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0100) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bit 0) RADIO has ramped up and is ready to be started"]
            pub fn EVENTS_READY(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u8 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "EVENTS_READY {{ EVENTS_READY: {0} }}@3318180191869537516"]
                #[link_section = ".binfmt.EVENTS_READY {{ EVENTS_READY: {0} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 0) RADIO has ramped up and is ready to be started"]
            #[allow(non_snake_case)]
            pub fn EVENTS_READY(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Address sent or received"]
    pub type EVENTS_ADDRESS = events_address::Register;
    #[doc = "Address sent or received"]
    pub mod events_address {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0104) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bit 0) Address sent or received"]
            pub fn EVENTS_ADDRESS(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u8 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "EVENTS_ADDRESS {{ EVENTS_ADDRESS: {0} }}@16603411560744168342"]
                #[link_section = ".binfmt.EVENTS_ADDRESS {{ EVENTS_ADDRESS: {0} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 0) Address sent or received"]
            #[allow(non_snake_case)]
            pub fn EVENTS_ADDRESS(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Packet payload sent or received"]
    pub type EVENTS_PAYLOAD = events_payload::Register;
    #[doc = "Packet payload sent or received"]
    pub mod events_payload {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0108) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bit 0) Packet payload sent or received"]
            pub fn EVENTS_PAYLOAD(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u8 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "EVENTS_PAYLOAD {{ EVENTS_PAYLOAD: {0} }}@9305156309298848405"]
                #[link_section = ".binfmt.EVENTS_PAYLOAD {{ EVENTS_PAYLOAD: {0} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 0) Packet payload sent or received"]
            #[allow(non_snake_case)]
            pub fn EVENTS_PAYLOAD(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Packet sent or received"]
    pub type EVENTS_END = events_end::Register;
    #[doc = "Packet sent or received"]
    pub mod events_end {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x010c) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bit 0) Packet sent or received"]
            pub fn EVENTS_END(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u8 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "EVENTS_END {{ EVENTS_END: {0} }}@11428252820900125813"]
                #[link_section = ".binfmt.EVENTS_END {{ EVENTS_END: {0} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 0) Packet sent or received"]
            #[allow(non_snake_case)]
            pub fn EVENTS_END(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "RADIO has been disabled"]
    pub type EVENTS_DISABLED = events_disabled::Register;
    #[doc = "RADIO has been disabled"]
    pub mod events_disabled {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0110) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bit 0) RADIO has been disabled"]
            pub fn EVENTS_DISABLED(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u8 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "EVENTS_DISABLED {{ EVENTS_DISABLED: {0} }}@3552449551581969576"]
                #[link_section = ".binfmt.EVENTS_DISABLED {{ EVENTS_DISABLED: {0} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 0) RADIO has been disabled"]
            #[allow(non_snake_case)]
            pub fn EVENTS_DISABLED(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "A device address match occurred on the last received packet"]
    pub type EVENTS_DEVMATCH = events_devmatch::Register;
    #[doc = "A device address match occurred on the last received packet"]
    pub mod events_devmatch {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0114) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bit 0) A device address match occurred on the last received packet"]
            pub fn EVENTS_DEVMATCH(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u8 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "EVENTS_DEVMATCH {{ EVENTS_DEVMATCH: {0} }}@11024680916202626147"]
                #[link_section = ".binfmt.EVENTS_DEVMATCH {{ EVENTS_DEVMATCH: {0} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 0) A device address match occurred on the last received packet"]
            #[allow(non_snake_case)]
            pub fn EVENTS_DEVMATCH(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "No device address match occurred on the last received packet"]
    pub type EVENTS_DEVMISS = events_devmiss::Register;
    #[doc = "No device address match occurred on the last received packet"]
    pub mod events_devmiss {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0118) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bit 0) No device address match occurred on the last received packet"]
            pub fn EVENTS_DEVMISS(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u8 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "EVENTS_DEVMISS {{ EVENTS_DEVMISS: {0} }}@2653525080528145386"]
                #[link_section = ".binfmt.EVENTS_DEVMISS {{ EVENTS_DEVMISS: {0} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 0) No device address match occurred on the last received packet"]
            #[allow(non_snake_case)]
            pub fn EVENTS_DEVMISS(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Sampling of receive signal strength complete"]
    pub type EVENTS_RSSIEND = events_rssiend::Register;
    #[doc = "Sampling of receive signal strength complete"]
    pub mod events_rssiend {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x011c) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bit 0) Sampling of receive signal strength complete"]
            pub fn EVENTS_RSSIEND(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u8 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "EVENTS_RSSIEND {{ EVENTS_RSSIEND: {0} }}@14132772284565134845"]
                #[link_section = ".binfmt.EVENTS_RSSIEND {{ EVENTS_RSSIEND: {0} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 0) Sampling of receive signal strength complete"]
            #[allow(non_snake_case)]
            pub fn EVENTS_RSSIEND(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Bit counter reached bit count value"]
    pub type EVENTS_BCMATCH = events_bcmatch::Register;
    #[doc = "Bit counter reached bit count value"]
    pub mod events_bcmatch {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0128) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bit 0) Bit counter reached bit count value"]
            pub fn EVENTS_BCMATCH(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u8 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "EVENTS_BCMATCH {{ EVENTS_BCMATCH: {0} }}@14439041196216522230"]
                #[link_section = ".binfmt.EVENTS_BCMATCH {{ EVENTS_BCMATCH: {0} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 0) Bit counter reached bit count value"]
            #[allow(non_snake_case)]
            pub fn EVENTS_BCMATCH(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Packet received with CRC ok"]
    pub type EVENTS_CRCOK = events_crcok::Register;
    #[doc = "Packet received with CRC ok"]
    pub mod events_crcok {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0130) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bit 0) Packet received with CRC ok"]
            pub fn EVENTS_CRCOK(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u8 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "EVENTS_CRCOK {{ EVENTS_CRCOK: {0} }}@5574239585258420723"]
                #[link_section = ".binfmt.EVENTS_CRCOK {{ EVENTS_CRCOK: {0} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 0) Packet received with CRC ok"]
            #[allow(non_snake_case)]
            pub fn EVENTS_CRCOK(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Packet received with CRC error"]
    pub type EVENTS_CRCERROR = events_crcerror::Register;
    #[doc = "Packet received with CRC error"]
    pub mod events_crcerror {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0134) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bit 0) Packet received with CRC error"]
            pub fn EVENTS_CRCERROR(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u8 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "EVENTS_CRCERROR {{ EVENTS_CRCERROR: {0} }}@4762183594553284902"]
                #[link_section = ".binfmt.EVENTS_CRCERROR {{ EVENTS_CRCERROR: {0} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 0) Packet received with CRC error"]
            #[allow(non_snake_case)]
            pub fn EVENTS_CRCERROR(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "IEEE 802.15.4 length field received"]
    pub type EVENTS_FRAMESTART = events_framestart::Register;
    #[doc = "IEEE 802.15.4 length field received"]
    pub mod events_framestart {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0138) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bit 0) IEEE 802.15.4 length field received"]
            pub fn EVENTS_FRAMESTART(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u8 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "EVENTS_FRAMESTART {{ EVENTS_FRAMESTART: {0} }}@12339333423412770095"]
                #[link_section = ".binfmt.EVENTS_FRAMESTART {{ EVENTS_FRAMESTART: {0} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 0) IEEE 802.15.4 length field received"]
            #[allow(non_snake_case)]
            pub fn EVENTS_FRAMESTART(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Sampling of energy detection complete. A new ED sample is ready for readout from the RADIO.EDSAMPLE register."]
    pub type EVENTS_EDEND = events_edend::Register;
    #[doc = "Sampling of energy detection complete. A new ED sample is ready for readout from the RADIO.EDSAMPLE register."]
    pub mod events_edend {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x013c) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bit 0) Sampling of energy detection complete. A new ED sample is ready for readout from the RADIO.EDSAMPLE register."]
            pub fn EVENTS_EDEND(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u8 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "EVENTS_EDEND {{ EVENTS_EDEND: {0} }}@10099824819360883127"]
                #[link_section = ".binfmt.EVENTS_EDEND {{ EVENTS_EDEND: {0} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 0) Sampling of energy detection complete. A new ED sample is ready for readout from the RADIO.EDSAMPLE register."]
            #[allow(non_snake_case)]
            pub fn EVENTS_EDEND(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "The sampling of energy detection has stopped"]
    pub type EVENTS_EDSTOPPED = events_edstopped::Register;
    #[doc = "The sampling of energy detection has stopped"]
    pub mod events_edstopped {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0140) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bit 0) The sampling of energy detection has stopped"]
            pub fn EVENTS_EDSTOPPED(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u8 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "EVENTS_EDSTOPPED {{ EVENTS_EDSTOPPED: {0} }}@1677802707452158862"]
                #[link_section = ".binfmt.EVENTS_EDSTOPPED {{ EVENTS_EDSTOPPED: {0} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 0) The sampling of energy detection has stopped"]
            #[allow(non_snake_case)]
            pub fn EVENTS_EDSTOPPED(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Wireless medium in idle - clear to send"]
    pub type EVENTS_CCAIDLE = events_ccaidle::Register;
    #[doc = "Wireless medium in idle - clear to send"]
    pub mod events_ccaidle {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0144) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bit 0) Wireless medium in idle - clear to send"]
            pub fn EVENTS_CCAIDLE(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u8 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "EVENTS_CCAIDLE {{ EVENTS_CCAIDLE: {0} }}@13933814523308555179"]
                #[link_section = ".binfmt.EVENTS_CCAIDLE {{ EVENTS_CCAIDLE: {0} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 0) Wireless medium in idle - clear to send"]
            #[allow(non_snake_case)]
            pub fn EVENTS_CCAIDLE(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Wireless medium busy - do not send"]
    pub type EVENTS_CCABUSY = events_ccabusy::Register;
    #[doc = "Wireless medium busy - do not send"]
    pub mod events_ccabusy {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0148) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bit 0) Wireless medium busy - do not send"]
            pub fn EVENTS_CCABUSY(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u8 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "EVENTS_CCABUSY {{ EVENTS_CCABUSY: {0} }}@2536213799777505866"]
                #[link_section = ".binfmt.EVENTS_CCABUSY {{ EVENTS_CCABUSY: {0} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 0) Wireless medium busy - do not send"]
            #[allow(non_snake_case)]
            pub fn EVENTS_CCABUSY(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "The CCA has stopped"]
    pub type EVENTS_CCASTOPPED = events_ccastopped::Register;
    #[doc = "The CCA has stopped"]
    pub mod events_ccastopped {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x014c) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bit 0) The CCA has stopped"]
            pub fn EVENTS_CCASTOPPED(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u8 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "EVENTS_CCASTOPPED {{ EVENTS_CCASTOPPED: {0} }}@17747446800432838573"]
                #[link_section = ".binfmt.EVENTS_CCASTOPPED {{ EVENTS_CCASTOPPED: {0} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 0) The CCA has stopped"]
            #[allow(non_snake_case)]
            pub fn EVENTS_CCASTOPPED(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Ble_LR CI field received, receive mode is changed from Ble_LR125Kbit to Ble_LR500Kbit."]
    pub type EVENTS_RATEBOOST = events_rateboost::Register;
    #[doc = "Ble_LR CI field received, receive mode is changed from Ble_LR125Kbit to Ble_LR500Kbit."]
    pub mod events_rateboost {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0150) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bit 0) Ble_LR CI field received, receive mode is changed from Ble_LR125Kbit to Ble_LR500Kbit."]
            pub fn EVENTS_RATEBOOST(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u8 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "EVENTS_RATEBOOST {{ EVENTS_RATEBOOST: {0} }}@4682395477813098644"]
                #[link_section = ".binfmt.EVENTS_RATEBOOST {{ EVENTS_RATEBOOST: {0} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 0) Ble_LR CI field received, receive mode is changed from Ble_LR125Kbit to Ble_LR500Kbit."]
            #[allow(non_snake_case)]
            pub fn EVENTS_RATEBOOST(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "RADIO has ramped up and is ready to be started TX path"]
    pub type EVENTS_TXREADY = events_txready::Register;
    #[doc = "RADIO has ramped up and is ready to be started TX path"]
    pub mod events_txready {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0154) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bit 0) RADIO has ramped up and is ready to be started TX path"]
            pub fn EVENTS_TXREADY(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u8 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "EVENTS_TXREADY {{ EVENTS_TXREADY: {0} }}@11734290418819345933"]
                #[link_section = ".binfmt.EVENTS_TXREADY {{ EVENTS_TXREADY: {0} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 0) RADIO has ramped up and is ready to be started TX path"]
            #[allow(non_snake_case)]
            pub fn EVENTS_TXREADY(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "RADIO has ramped up and is ready to be started RX path"]
    pub type EVENTS_RXREADY = events_rxready::Register;
    #[doc = "RADIO has ramped up and is ready to be started RX path"]
    pub mod events_rxready {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0158) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bit 0) RADIO has ramped up and is ready to be started RX path"]
            pub fn EVENTS_RXREADY(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u8 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "EVENTS_RXREADY {{ EVENTS_RXREADY: {0} }}@4926815980334803808"]
                #[link_section = ".binfmt.EVENTS_RXREADY {{ EVENTS_RXREADY: {0} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 0) RADIO has ramped up and is ready to be started RX path"]
            #[allow(non_snake_case)]
            pub fn EVENTS_RXREADY(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "MAC header match found"]
    pub type EVENTS_MHRMATCH = events_mhrmatch::Register;
    #[doc = "MAC header match found"]
    pub mod events_mhrmatch {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x015c) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bit 0) MAC header match found"]
            pub fn EVENTS_MHRMATCH(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u8 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "EVENTS_MHRMATCH {{ EVENTS_MHRMATCH: {0} }}@15206443443806097607"]
                #[link_section = ".binfmt.EVENTS_MHRMATCH {{ EVENTS_MHRMATCH: {0} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 0) MAC header match found"]
            #[allow(non_snake_case)]
            pub fn EVENTS_MHRMATCH(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Generated in Ble_LR125Kbit, Ble_LR500Kbit and Ieee802154_250Kbit modes when last bit is sent on air."]
    pub type EVENTS_PHYEND = events_phyend::Register;
    #[doc = "Generated in Ble_LR125Kbit, Ble_LR500Kbit and Ieee802154_250Kbit modes when last bit is sent on air."]
    pub mod events_phyend {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x016c) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bit 0) Generated in Ble_LR125Kbit, Ble_LR500Kbit and Ieee802154_250Kbit modes when last bit is sent on air."]
            pub fn EVENTS_PHYEND(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u8 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "EVENTS_PHYEND {{ EVENTS_PHYEND: {0} }}@2442207514768120660"]
                #[link_section = ".binfmt.EVENTS_PHYEND {{ EVENTS_PHYEND: {0} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 0) Generated in Ble_LR125Kbit, Ble_LR500Kbit and Ieee802154_250Kbit modes when last bit is sent on air."]
            #[allow(non_snake_case)]
            pub fn EVENTS_PHYEND(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Shortcuts between local events and tasks"]
    pub type SHORTS = shorts::Register;
    #[doc = "Shortcuts between local events and tasks"]
    pub mod shorts {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0200) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bit 0) Shortcut between event READY and task START"]
            pub fn READY_START(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 1) Shortcut between event END and task DISABLE"]
            pub fn END_DISABLE(self) -> u8 {
                const OFFSET: u8 = 1;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 2) Shortcut between event DISABLED and task TXEN"]
            pub fn DISABLED_TXEN(self) -> u8 {
                const OFFSET: u8 = 2;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 3) Shortcut between event DISABLED and task RXEN"]
            pub fn DISABLED_RXEN(self) -> u8 {
                const OFFSET: u8 = 3;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 4) Shortcut between event ADDRESS and task RSSISTART"]
            pub fn ADDRESS_RSSISTART(self) -> u8 {
                const OFFSET: u8 = 4;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 5) Shortcut between event END and task START"]
            pub fn END_START(self) -> u8 {
                const OFFSET: u8 = 5;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 6) Shortcut between event ADDRESS and task BCSTART"]
            pub fn ADDRESS_BCSTART(self) -> u8 {
                const OFFSET: u8 = 6;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 8) Shortcut between event DISABLED and task RSSISTOP"]
            pub fn DISABLED_RSSISTOP(self) -> u8 {
                const OFFSET: u8 = 8;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 11) Shortcut between event RXREADY and task CCASTART"]
            pub fn RXREADY_CCASTART(self) -> u8 {
                const OFFSET: u8 = 11;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 12) Shortcut between event CCAIDLE and task TXEN"]
            pub fn CCAIDLE_TXEN(self) -> u8 {
                const OFFSET: u8 = 12;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 13) Shortcut between event CCABUSY and task DISABLE"]
            pub fn CCABUSY_DISABLE(self) -> u8 {
                const OFFSET: u8 = 13;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 14) Shortcut between event FRAMESTART and task BCSTART"]
            pub fn FRAMESTART_BCSTART(self) -> u8 {
                const OFFSET: u8 = 14;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 15) Shortcut between event READY and task EDSTART"]
            pub fn READY_EDSTART(self) -> u8 {
                const OFFSET: u8 = 15;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 16) Shortcut between event EDEND and task DISABLE"]
            pub fn EDEND_DISABLE(self) -> u8 {
                const OFFSET: u8 = 16;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 17) Shortcut between event CCAIDLE and task STOP"]
            pub fn CCAIDLE_STOP(self) -> u8 {
                const OFFSET: u8 = 17;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 18) Shortcut between event TXREADY and task START"]
            pub fn TXREADY_START(self) -> u8 {
                const OFFSET: u8 = 18;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 19) Shortcut between event RXREADY and task START"]
            pub fn RXREADY_START(self) -> u8 {
                const OFFSET: u8 = 19;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 20) Shortcut between event PHYEND and task DISABLE"]
            pub fn PHYEND_DISABLE(self) -> u8 {
                const OFFSET: u8 = 20;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 21) Shortcut between event PHYEND and task START"]
            pub fn PHYEND_START(self) -> u8 {
                const OFFSET: u8 = 21;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u32 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "SHORTS {{ PHYEND_START: {21}, PHYEND_DISABLE: {20}, RXREADY_START: {19}, TXREADY_START: {18}, CCAIDLE_STOP: {17}, EDEND_DISABLE: {16}, READY_EDSTART: {15}, FRAMESTART_BCSTART: {14}, CCABUSY_DISABLE: {13}, CCAIDLE_TXEN: {12}, RXREADY_CCASTART: {11}, DISABLED_RSSISTOP: {8}, ADDRESS_BCSTART: {6}, END_START: {5}, ADDRESS_RSSISTART: {4}, DISABLED_RXEN: {3}, DISABLED_TXEN: {2}, END_DISABLE: {1}, READY_START: {0} }}@899427907489545560"]
                #[link_section = ".binfmt.SHORTS {{ PHYEND_START: {21}, PHYEND_DISABLE: {20}, RXREADY_START: {19}, TXREADY_START: {18}, CCAIDLE_STOP: {17}, EDEND_DISABLE: {16}, READY_EDSTART: {15}, FRAMESTART_BCSTART: {14}, CCABUSY_DISABLE: {13}, CCAIDLE_TXEN: {12}, RXREADY_CCASTART: {11}, DISABLED_RSSISTOP: {8}, ADDRESS_BCSTART: {6}, END_START: {5}, ADDRESS_RSSISTART: {4}, DISABLED_RXEN: {3}, DISABLED_TXEN: {2}, END_DISABLE: {1}, READY_START: {0} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 0) Shortcut between event READY and task START"]
            #[allow(non_snake_case)]
            pub fn READY_START(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 1) Shortcut between event END and task DISABLE"]
            #[allow(non_snake_case)]
            pub fn END_DISABLE(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 1;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 2) Shortcut between event DISABLED and task TXEN"]
            #[allow(non_snake_case)]
            pub fn DISABLED_TXEN(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 2;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 3) Shortcut between event DISABLED and task RXEN"]
            #[allow(non_snake_case)]
            pub fn DISABLED_RXEN(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 3;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 4) Shortcut between event ADDRESS and task RSSISTART"]
            #[allow(non_snake_case)]
            pub fn ADDRESS_RSSISTART(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 4;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 5) Shortcut between event END and task START"]
            #[allow(non_snake_case)]
            pub fn END_START(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 5;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 6) Shortcut between event ADDRESS and task BCSTART"]
            #[allow(non_snake_case)]
            pub fn ADDRESS_BCSTART(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 6;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 8) Shortcut between event DISABLED and task RSSISTOP"]
            #[allow(non_snake_case)]
            pub fn DISABLED_RSSISTOP(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 8;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 11) Shortcut between event RXREADY and task CCASTART"]
            #[allow(non_snake_case)]
            pub fn RXREADY_CCASTART(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 11;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 12) Shortcut between event CCAIDLE and task TXEN"]
            #[allow(non_snake_case)]
            pub fn CCAIDLE_TXEN(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 12;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 13) Shortcut between event CCABUSY and task DISABLE"]
            #[allow(non_snake_case)]
            pub fn CCABUSY_DISABLE(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 13;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 14) Shortcut between event FRAMESTART and task BCSTART"]
            #[allow(non_snake_case)]
            pub fn FRAMESTART_BCSTART(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 14;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 15) Shortcut between event READY and task EDSTART"]
            #[allow(non_snake_case)]
            pub fn READY_EDSTART(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 15;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 16) Shortcut between event EDEND and task DISABLE"]
            #[allow(non_snake_case)]
            pub fn EDEND_DISABLE(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 16;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 17) Shortcut between event CCAIDLE and task STOP"]
            #[allow(non_snake_case)]
            pub fn CCAIDLE_STOP(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 17;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 18) Shortcut between event TXREADY and task START"]
            #[allow(non_snake_case)]
            pub fn TXREADY_START(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 18;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 19) Shortcut between event RXREADY and task START"]
            #[allow(non_snake_case)]
            pub fn RXREADY_START(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 19;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 20) Shortcut between event PHYEND and task DISABLE"]
            #[allow(non_snake_case)]
            pub fn PHYEND_DISABLE(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 20;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 21) Shortcut between event PHYEND and task START"]
            #[allow(non_snake_case)]
            pub fn PHYEND_START(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 21;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Enable interrupt"]
    pub type INTENSET = intenset::Register;
    #[doc = "Enable interrupt"]
    pub mod intenset {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0304) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub unsafe fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub unsafe fn zero(&self) {
                {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub unsafe fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bit 0) Write '1' to enable interrupt for event READY"]
            pub fn READY(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 1) Write '1' to enable interrupt for event ADDRESS"]
            pub fn ADDRESS(self) -> u8 {
                const OFFSET: u8 = 1;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 2) Write '1' to enable interrupt for event PAYLOAD"]
            pub fn PAYLOAD(self) -> u8 {
                const OFFSET: u8 = 2;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 3) Write '1' to enable interrupt for event END"]
            pub fn END(self) -> u8 {
                const OFFSET: u8 = 3;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 4) Write '1' to enable interrupt for event DISABLED"]
            pub fn DISABLED(self) -> u8 {
                const OFFSET: u8 = 4;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 5) Write '1' to enable interrupt for event DEVMATCH"]
            pub fn DEVMATCH(self) -> u8 {
                const OFFSET: u8 = 5;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 6) Write '1' to enable interrupt for event DEVMISS"]
            pub fn DEVMISS(self) -> u8 {
                const OFFSET: u8 = 6;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 7) Write '1' to enable interrupt for event RSSIEND"]
            pub fn RSSIEND(self) -> u8 {
                const OFFSET: u8 = 7;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 10) Write '1' to enable interrupt for event BCMATCH"]
            pub fn BCMATCH(self) -> u8 {
                const OFFSET: u8 = 10;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 12) Write '1' to enable interrupt for event CRCOK"]
            pub fn CRCOK(self) -> u8 {
                const OFFSET: u8 = 12;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 13) Write '1' to enable interrupt for event CRCERROR"]
            pub fn CRCERROR(self) -> u8 {
                const OFFSET: u8 = 13;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 14) Write '1' to enable interrupt for event FRAMESTART"]
            pub fn FRAMESTART(self) -> u8 {
                const OFFSET: u8 = 14;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 15) Write '1' to enable interrupt for event EDEND"]
            pub fn EDEND(self) -> u8 {
                const OFFSET: u8 = 15;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 16) Write '1' to enable interrupt for event EDSTOPPED"]
            pub fn EDSTOPPED(self) -> u8 {
                const OFFSET: u8 = 16;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 17) Write '1' to enable interrupt for event CCAIDLE"]
            pub fn CCAIDLE(self) -> u8 {
                const OFFSET: u8 = 17;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 18) Write '1' to enable interrupt for event CCABUSY"]
            pub fn CCABUSY(self) -> u8 {
                const OFFSET: u8 = 18;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 19) Write '1' to enable interrupt for event CCASTOPPED"]
            pub fn CCASTOPPED(self) -> u8 {
                const OFFSET: u8 = 19;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 20) Write '1' to enable interrupt for event RATEBOOST"]
            pub fn RATEBOOST(self) -> u8 {
                const OFFSET: u8 = 20;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 21) Write '1' to enable interrupt for event TXREADY"]
            pub fn TXREADY(self) -> u8 {
                const OFFSET: u8 = 21;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 22) Write '1' to enable interrupt for event RXREADY"]
            pub fn RXREADY(self) -> u8 {
                const OFFSET: u8 = 22;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 23) Write '1' to enable interrupt for event MHRMATCH"]
            pub fn MHRMATCH(self) -> u8 {
                const OFFSET: u8 = 23;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 27) Write '1' to enable interrupt for event PHYEND"]
            pub fn PHYEND(self) -> u8 {
                const OFFSET: u8 = 27;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u32 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "INTENSET {{ PHYEND: {27}, MHRMATCH: {23}, RXREADY: {22}, TXREADY: {21}, RATEBOOST: {20}, CCASTOPPED: {19}, CCABUSY: {18}, CCAIDLE: {17}, EDSTOPPED: {16}, EDEND: {15}, FRAMESTART: {14}, CRCERROR: {13}, CRCOK: {12}, BCMATCH: {10}, RSSIEND: {7}, DEVMISS: {6}, DEVMATCH: {5}, DISABLED: {4}, END: {3}, PAYLOAD: {2}, ADDRESS: {1}, READY: {0} }}@14968811579568259978"]
                #[link_section = ".binfmt.INTENSET {{ PHYEND: {27}, MHRMATCH: {23}, RXREADY: {22}, TXREADY: {21}, RATEBOOST: {20}, CCASTOPPED: {19}, CCABUSY: {18}, CCAIDLE: {17}, EDSTOPPED: {16}, EDEND: {15}, FRAMESTART: {14}, CRCERROR: {13}, CRCOK: {12}, BCMATCH: {10}, RSSIEND: {7}, DEVMISS: {6}, DEVMATCH: {5}, DISABLED: {4}, END: {3}, PAYLOAD: {2}, ADDRESS: {1}, READY: {0} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 0) Write '1' to enable interrupt for event READY"]
            #[allow(non_snake_case)]
            pub fn READY(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 1) Write '1' to enable interrupt for event ADDRESS"]
            #[allow(non_snake_case)]
            pub fn ADDRESS(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 1;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 2) Write '1' to enable interrupt for event PAYLOAD"]
            #[allow(non_snake_case)]
            pub fn PAYLOAD(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 2;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 3) Write '1' to enable interrupt for event END"]
            #[allow(non_snake_case)]
            pub fn END(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 3;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 4) Write '1' to enable interrupt for event DISABLED"]
            #[allow(non_snake_case)]
            pub fn DISABLED(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 4;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 5) Write '1' to enable interrupt for event DEVMATCH"]
            #[allow(non_snake_case)]
            pub fn DEVMATCH(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 5;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 6) Write '1' to enable interrupt for event DEVMISS"]
            #[allow(non_snake_case)]
            pub fn DEVMISS(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 6;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 7) Write '1' to enable interrupt for event RSSIEND"]
            #[allow(non_snake_case)]
            pub fn RSSIEND(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 7;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 10) Write '1' to enable interrupt for event BCMATCH"]
            #[allow(non_snake_case)]
            pub fn BCMATCH(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 10;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 12) Write '1' to enable interrupt for event CRCOK"]
            #[allow(non_snake_case)]
            pub fn CRCOK(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 12;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 13) Write '1' to enable interrupt for event CRCERROR"]
            #[allow(non_snake_case)]
            pub fn CRCERROR(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 13;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 14) Write '1' to enable interrupt for event FRAMESTART"]
            #[allow(non_snake_case)]
            pub fn FRAMESTART(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 14;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 15) Write '1' to enable interrupt for event EDEND"]
            #[allow(non_snake_case)]
            pub fn EDEND(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 15;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 16) Write '1' to enable interrupt for event EDSTOPPED"]
            #[allow(non_snake_case)]
            pub fn EDSTOPPED(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 16;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 17) Write '1' to enable interrupt for event CCAIDLE"]
            #[allow(non_snake_case)]
            pub fn CCAIDLE(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 17;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 18) Write '1' to enable interrupt for event CCABUSY"]
            #[allow(non_snake_case)]
            pub fn CCABUSY(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 18;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 19) Write '1' to enable interrupt for event CCASTOPPED"]
            #[allow(non_snake_case)]
            pub fn CCASTOPPED(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 19;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 20) Write '1' to enable interrupt for event RATEBOOST"]
            #[allow(non_snake_case)]
            pub fn RATEBOOST(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 20;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 21) Write '1' to enable interrupt for event TXREADY"]
            #[allow(non_snake_case)]
            pub fn TXREADY(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 21;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 22) Write '1' to enable interrupt for event RXREADY"]
            #[allow(non_snake_case)]
            pub fn RXREADY(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 22;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 23) Write '1' to enable interrupt for event MHRMATCH"]
            #[allow(non_snake_case)]
            pub fn MHRMATCH(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 23;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 27) Write '1' to enable interrupt for event PHYEND"]
            #[allow(non_snake_case)]
            pub fn PHYEND(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 27;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Disable interrupt"]
    pub type INTENCLR = intenclr::Register;
    #[doc = "Disable interrupt"]
    pub mod intenclr {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0308) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bit 0) Write '1' to disable interrupt for event READY"]
            pub fn READY(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 1) Write '1' to disable interrupt for event ADDRESS"]
            pub fn ADDRESS(self) -> u8 {
                const OFFSET: u8 = 1;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 2) Write '1' to disable interrupt for event PAYLOAD"]
            pub fn PAYLOAD(self) -> u8 {
                const OFFSET: u8 = 2;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 3) Write '1' to disable interrupt for event END"]
            pub fn END(self) -> u8 {
                const OFFSET: u8 = 3;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 4) Write '1' to disable interrupt for event DISABLED"]
            pub fn DISABLED(self) -> u8 {
                const OFFSET: u8 = 4;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 5) Write '1' to disable interrupt for event DEVMATCH"]
            pub fn DEVMATCH(self) -> u8 {
                const OFFSET: u8 = 5;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 6) Write '1' to disable interrupt for event DEVMISS"]
            pub fn DEVMISS(self) -> u8 {
                const OFFSET: u8 = 6;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 7) Write '1' to disable interrupt for event RSSIEND"]
            pub fn RSSIEND(self) -> u8 {
                const OFFSET: u8 = 7;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 10) Write '1' to disable interrupt for event BCMATCH"]
            pub fn BCMATCH(self) -> u8 {
                const OFFSET: u8 = 10;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 12) Write '1' to disable interrupt for event CRCOK"]
            pub fn CRCOK(self) -> u8 {
                const OFFSET: u8 = 12;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 13) Write '1' to disable interrupt for event CRCERROR"]
            pub fn CRCERROR(self) -> u8 {
                const OFFSET: u8 = 13;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 14) Write '1' to disable interrupt for event FRAMESTART"]
            pub fn FRAMESTART(self) -> u8 {
                const OFFSET: u8 = 14;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 15) Write '1' to disable interrupt for event EDEND"]
            pub fn EDEND(self) -> u8 {
                const OFFSET: u8 = 15;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 16) Write '1' to disable interrupt for event EDSTOPPED"]
            pub fn EDSTOPPED(self) -> u8 {
                const OFFSET: u8 = 16;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 17) Write '1' to disable interrupt for event CCAIDLE"]
            pub fn CCAIDLE(self) -> u8 {
                const OFFSET: u8 = 17;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 18) Write '1' to disable interrupt for event CCABUSY"]
            pub fn CCABUSY(self) -> u8 {
                const OFFSET: u8 = 18;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 19) Write '1' to disable interrupt for event CCASTOPPED"]
            pub fn CCASTOPPED(self) -> u8 {
                const OFFSET: u8 = 19;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 20) Write '1' to disable interrupt for event RATEBOOST"]
            pub fn RATEBOOST(self) -> u8 {
                const OFFSET: u8 = 20;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 21) Write '1' to disable interrupt for event TXREADY"]
            pub fn TXREADY(self) -> u8 {
                const OFFSET: u8 = 21;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 22) Write '1' to disable interrupt for event RXREADY"]
            pub fn RXREADY(self) -> u8 {
                const OFFSET: u8 = 22;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 23) Write '1' to disable interrupt for event MHRMATCH"]
            pub fn MHRMATCH(self) -> u8 {
                const OFFSET: u8 = 23;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 27) Write '1' to disable interrupt for event PHYEND"]
            pub fn PHYEND(self) -> u8 {
                const OFFSET: u8 = 27;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u32 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "INTENCLR {{ PHYEND: {27}, MHRMATCH: {23}, RXREADY: {22}, TXREADY: {21}, RATEBOOST: {20}, CCASTOPPED: {19}, CCABUSY: {18}, CCAIDLE: {17}, EDSTOPPED: {16}, EDEND: {15}, FRAMESTART: {14}, CRCERROR: {13}, CRCOK: {12}, BCMATCH: {10}, RSSIEND: {7}, DEVMISS: {6}, DEVMATCH: {5}, DISABLED: {4}, END: {3}, PAYLOAD: {2}, ADDRESS: {1}, READY: {0} }}@7151019430163944448"]
                #[link_section = ".binfmt.INTENCLR {{ PHYEND: {27}, MHRMATCH: {23}, RXREADY: {22}, TXREADY: {21}, RATEBOOST: {20}, CCASTOPPED: {19}, CCABUSY: {18}, CCAIDLE: {17}, EDSTOPPED: {16}, EDEND: {15}, FRAMESTART: {14}, CRCERROR: {13}, CRCOK: {12}, BCMATCH: {10}, RSSIEND: {7}, DEVMISS: {6}, DEVMATCH: {5}, DISABLED: {4}, END: {3}, PAYLOAD: {2}, ADDRESS: {1}, READY: {0} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 0) Write '1' to disable interrupt for event READY"]
            #[allow(non_snake_case)]
            pub fn READY(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 1) Write '1' to disable interrupt for event ADDRESS"]
            #[allow(non_snake_case)]
            pub fn ADDRESS(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 1;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 2) Write '1' to disable interrupt for event PAYLOAD"]
            #[allow(non_snake_case)]
            pub fn PAYLOAD(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 2;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 3) Write '1' to disable interrupt for event END"]
            #[allow(non_snake_case)]
            pub fn END(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 3;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 4) Write '1' to disable interrupt for event DISABLED"]
            #[allow(non_snake_case)]
            pub fn DISABLED(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 4;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 5) Write '1' to disable interrupt for event DEVMATCH"]
            #[allow(non_snake_case)]
            pub fn DEVMATCH(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 5;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 6) Write '1' to disable interrupt for event DEVMISS"]
            #[allow(non_snake_case)]
            pub fn DEVMISS(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 6;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 7) Write '1' to disable interrupt for event RSSIEND"]
            #[allow(non_snake_case)]
            pub fn RSSIEND(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 7;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 10) Write '1' to disable interrupt for event BCMATCH"]
            #[allow(non_snake_case)]
            pub fn BCMATCH(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 10;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 12) Write '1' to disable interrupt for event CRCOK"]
            #[allow(non_snake_case)]
            pub fn CRCOK(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 12;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 13) Write '1' to disable interrupt for event CRCERROR"]
            #[allow(non_snake_case)]
            pub fn CRCERROR(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 13;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 14) Write '1' to disable interrupt for event FRAMESTART"]
            #[allow(non_snake_case)]
            pub fn FRAMESTART(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 14;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 15) Write '1' to disable interrupt for event EDEND"]
            #[allow(non_snake_case)]
            pub fn EDEND(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 15;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 16) Write '1' to disable interrupt for event EDSTOPPED"]
            #[allow(non_snake_case)]
            pub fn EDSTOPPED(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 16;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 17) Write '1' to disable interrupt for event CCAIDLE"]
            #[allow(non_snake_case)]
            pub fn CCAIDLE(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 17;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 18) Write '1' to disable interrupt for event CCABUSY"]
            #[allow(non_snake_case)]
            pub fn CCABUSY(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 18;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 19) Write '1' to disable interrupt for event CCASTOPPED"]
            #[allow(non_snake_case)]
            pub fn CCASTOPPED(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 19;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 20) Write '1' to disable interrupt for event RATEBOOST"]
            #[allow(non_snake_case)]
            pub fn RATEBOOST(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 20;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 21) Write '1' to disable interrupt for event TXREADY"]
            #[allow(non_snake_case)]
            pub fn TXREADY(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 21;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 22) Write '1' to disable interrupt for event RXREADY"]
            #[allow(non_snake_case)]
            pub fn RXREADY(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 22;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 23) Write '1' to disable interrupt for event MHRMATCH"]
            #[allow(non_snake_case)]
            pub fn MHRMATCH(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 23;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 27) Write '1' to disable interrupt for event PHYEND"]
            #[allow(non_snake_case)]
            pub fn PHYEND(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 27;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "CRC status"]
    pub type CRCSTATUS = crcstatus::Register;
    #[doc = "CRC status"]
    pub mod crcstatus {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *const u32 {
                (super::BASE_ADDRESS + 0x0400) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bit 0) CRC status of packet received"]
            pub fn CRCSTATUS(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u8 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "CRCSTATUS {{ CRCSTATUS: {0} }}@16340831422528597622"]
                #[link_section = ".binfmt.CRCSTATUS {{ CRCSTATUS: {0} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Received address"]
    pub type RXMATCH = rxmatch::Register;
    #[doc = "Received address"]
    pub mod rxmatch {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *const u32 {
                (super::BASE_ADDRESS + 0x0408) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bits 0..=3) Received address"]
            pub fn RXMATCH(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x07;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u8 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "RXMATCH {{ RXMATCH: {0:3} }}@7867894711526143317"]
                #[link_section = ".binfmt.RXMATCH {{ RXMATCH: {0:3} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "CRC field of previously received packet"]
    pub type RXCRC = rxcrc::Register;
    #[doc = "CRC field of previously received packet"]
    pub mod rxcrc {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *const u32 {
                (super::BASE_ADDRESS + 0x040c) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bits 0..=24) CRC field of previously received packet"]
            pub fn RXCRC(self) -> u32 {
                const OFFSET: u8 = 0;
                const MASK: u32 = 0x00ff_ffff;
                ((self.inner >> OFFSET) as u32) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u32 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "RXCRC {{ RXCRC: {0:24} }}@10555674599741676355"]
                #[link_section = ".binfmt.RXCRC {{ RXCRC: {0:24} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Device address match index"]
    pub type DAI = dai::Register;
    #[doc = "Device address match index"]
    pub mod dai {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *const u32 {
                (super::BASE_ADDRESS + 0x0410) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bits 0..=3) Device address match index"]
            pub fn DAI(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x07;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u8 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "DAI {{ DAI: {0:3} }}@2007054289003896600"]
                #[link_section = ".binfmt.DAI {{ DAI: {0:3} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Payload status"]
    pub type PDUSTAT = pdustat::Register;
    #[doc = "Payload status"]
    pub mod pdustat {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *const u32 {
                (super::BASE_ADDRESS + 0x0414) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bit 0) Status on payload length vs. PCNF1.MAXLEN"]
            pub fn PDUSTAT(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bits 1..=3) Status on what rate packet is received with in Long Range"]
            pub fn CISTAT(self) -> u8 {
                const OFFSET: u8 = 1;
                const MASK: u8 = 0x03;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u8 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "PDUSTAT {{ CISTAT: {1:3}, PDUSTAT: {0} }}@11212366112644649030"]
                #[link_section = ".binfmt.PDUSTAT {{ CISTAT: {1:3}, PDUSTAT: {0} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Packet pointer"]
    pub type PACKETPTR = packetptr::Register;
    #[doc = "Packet pointer"]
    pub mod packetptr {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0504) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bits 0..=32) Packet pointer"]
            pub fn PACKETPTR(self) -> u32 {
                const OFFSET: u8 = 0;
                const MASK: u32 = 0xffff_ffff;
                ((self.inner >> OFFSET) as u32) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u32 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "PACKETPTR {{ PACKETPTR: {0:32} }}@11848561998244947814"]
                #[link_section = ".binfmt.PACKETPTR {{ PACKETPTR: {0:32} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bits 0..=32) Packet pointer"]
            #[allow(non_snake_case)]
            pub fn PACKETPTR(&mut self, val: u32) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u32 = 0xffff_ffff;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Frequency"]
    pub type FREQUENCY = frequency::Register;
    #[doc = "Frequency"]
    pub mod frequency {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0508) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bits 0..=7) Radio channel frequency"]
            pub fn FREQUENCY(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x7f;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 8) Channel map selection."]
            pub fn MAP(self) -> u8 {
                const OFFSET: u8 = 8;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u16 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "FREQUENCY {{ MAP: {8}, FREQUENCY: {0:7} }}@8138557654990468471"]
                #[link_section = ".binfmt.FREQUENCY {{ MAP: {8}, FREQUENCY: {0:7} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bits 0..=7) Radio channel frequency"]
            #[allow(non_snake_case)]
            pub fn FREQUENCY(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x7f;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 8) Channel map selection."]
            #[allow(non_snake_case)]
            pub fn MAP(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 8;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Output power"]
    pub type TXPOWER = txpower::Register;
    #[doc = "Output power"]
    pub mod txpower {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x050c) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bits 0..=8) RADIO output power"]
            pub fn TXPOWER(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0xff;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u8 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "TXPOWER {{ TXPOWER: {0:8} }}@7297580709501878398"]
                #[link_section = ".binfmt.TXPOWER {{ TXPOWER: {0:8} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bits 0..=8) RADIO output power"]
            #[allow(non_snake_case)]
            pub fn TXPOWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0xff;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Data rate and modulation"]
    pub type MODE = mode::Register;
    #[doc = "Data rate and modulation"]
    pub mod mode {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0510) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bits 0..=4) Radio data rate and modulation setting. The radio supports frequency-shift keying (FSK) modulation."]
            pub fn MODE(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x0f;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u8 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "MODE {{ MODE: {0:4} }}@5921531414600983215"]
                #[link_section = ".binfmt.MODE {{ MODE: {0:4} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bits 0..=4) Radio data rate and modulation setting. The radio supports frequency-shift keying (FSK) modulation."]
            #[allow(non_snake_case)]
            pub fn MODE(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x0f;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Packet configuration register 0"]
    pub type PCNF0 = pcnf0::Register;
    #[doc = "Packet configuration register 0"]
    pub mod pcnf0 {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0514) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bits 0..=4) Length on air of LENGTH field in number of bits."]
            pub fn LFLEN(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x0f;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 8) Length on air of S0 field in number of bytes."]
            pub fn S0LEN(self) -> u8 {
                const OFFSET: u8 = 8;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bits 16..=20) Length on air of S1 field in number of bits."]
            pub fn S1LEN(self) -> u8 {
                const OFFSET: u8 = 16;
                const MASK: u8 = 0x0f;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 20) Include or exclude S1 field in RAM"]
            pub fn S1INCL(self) -> u8 {
                const OFFSET: u8 = 20;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bits 22..=24) Length of code indicator - long range"]
            pub fn CILEN(self) -> u8 {
                const OFFSET: u8 = 22;
                const MASK: u8 = 0x03;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bits 24..=26) Length of preamble on air. Decision point: TASKS_START task"]
            pub fn PLEN(self) -> u8 {
                const OFFSET: u8 = 24;
                const MASK: u8 = 0x03;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 26) Indicates if LENGTH field contains CRC or not"]
            pub fn CRCINC(self) -> u8 {
                const OFFSET: u8 = 26;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bits 29..=31) Length of TERM field in Long Range operation"]
            pub fn TERMLEN(self) -> u8 {
                const OFFSET: u8 = 29;
                const MASK: u8 = 0x03;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u32 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "PCNF0 {{ TERMLEN: {29:31}, CRCINC: {26}, PLEN: {24:26}, CILEN: {22:24}, S1INCL: {20}, S1LEN: {16:20}, S0LEN: {8}, LFLEN: {0:4} }}@7022953914267050745"]
                #[link_section = ".binfmt.PCNF0 {{ TERMLEN: {29:31}, CRCINC: {26}, PLEN: {24:26}, CILEN: {22:24}, S1INCL: {20}, S1LEN: {16:20}, S0LEN: {8}, LFLEN: {0:4} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bits 0..=4) Length on air of LENGTH field in number of bits."]
            #[allow(non_snake_case)]
            pub fn LFLEN(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x0f;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 8) Length on air of S0 field in number of bytes."]
            #[allow(non_snake_case)]
            pub fn S0LEN(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 8;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bits 16..=20) Length on air of S1 field in number of bits."]
            #[allow(non_snake_case)]
            pub fn S1LEN(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 16;
                const MASK: u8 = 0x0f;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 20) Include or exclude S1 field in RAM"]
            #[allow(non_snake_case)]
            pub fn S1INCL(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 20;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bits 22..=24) Length of code indicator - long range"]
            #[allow(non_snake_case)]
            pub fn CILEN(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 22;
                const MASK: u8 = 0x03;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bits 24..=26) Length of preamble on air. Decision point: TASKS_START task"]
            #[allow(non_snake_case)]
            pub fn PLEN(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 24;
                const MASK: u8 = 0x03;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 26) Indicates if LENGTH field contains CRC or not"]
            #[allow(non_snake_case)]
            pub fn CRCINC(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 26;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bits 29..=31) Length of TERM field in Long Range operation"]
            #[allow(non_snake_case)]
            pub fn TERMLEN(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 29;
                const MASK: u8 = 0x03;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Packet configuration register 1"]
    pub type PCNF1 = pcnf1::Register;
    #[doc = "Packet configuration register 1"]
    pub mod pcnf1 {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0518) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bits 0..=8) Maximum length of packet payload. If the packet payload is larger than MAXLEN, the radio will truncate the payload to MAXLEN."]
            pub fn MAXLEN(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0xff;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bits 8..=16) Static length in number of bytes"]
            pub fn STATLEN(self) -> u8 {
                const OFFSET: u8 = 8;
                const MASK: u8 = 0xff;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bits 16..=19) Base address length in number of bytes"]
            pub fn BALEN(self) -> u8 {
                const OFFSET: u8 = 16;
                const MASK: u8 = 0x07;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 24) On air endianness of packet, this applies to the S0, LENGTH, S1 and the PAYLOAD fields."]
            pub fn ENDIAN(self) -> u8 {
                const OFFSET: u8 = 24;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 25) Enable or disable packet whitening"]
            pub fn WHITEEN(self) -> u8 {
                const OFFSET: u8 = 25;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u32 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "PCNF1 {{ WHITEEN: {25}, ENDIAN: {24}, BALEN: {16:19}, STATLEN: {8:16}, MAXLEN: {0:8} }}@3427492655369081659"]
                #[link_section = ".binfmt.PCNF1 {{ WHITEEN: {25}, ENDIAN: {24}, BALEN: {16:19}, STATLEN: {8:16}, MAXLEN: {0:8} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bits 0..=8) Maximum length of packet payload. If the packet payload is larger than MAXLEN, the radio will truncate the payload to MAXLEN."]
            #[allow(non_snake_case)]
            pub fn MAXLEN(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0xff;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bits 8..=16) Static length in number of bytes"]
            #[allow(non_snake_case)]
            pub fn STATLEN(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 8;
                const MASK: u8 = 0xff;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bits 16..=19) Base address length in number of bytes"]
            #[allow(non_snake_case)]
            pub fn BALEN(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 16;
                const MASK: u8 = 0x07;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 24) On air endianness of packet, this applies to the S0, LENGTH, S1 and the PAYLOAD fields."]
            #[allow(non_snake_case)]
            pub fn ENDIAN(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 24;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 25) Enable or disable packet whitening"]
            #[allow(non_snake_case)]
            pub fn WHITEEN(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 25;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Base address 0"]
    pub type BASE0 = base0::Register;
    #[doc = "Base address 0"]
    pub mod base0 {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x051c) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bits 0..=32) Base address 0"]
            pub fn BASE0(self) -> u32 {
                const OFFSET: u8 = 0;
                const MASK: u32 = 0xffff_ffff;
                ((self.inner >> OFFSET) as u32) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u32 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "BASE0 {{ BASE0: {0:32} }}@5910124710976048392"]
                #[link_section = ".binfmt.BASE0 {{ BASE0: {0:32} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bits 0..=32) Base address 0"]
            #[allow(non_snake_case)]
            pub fn BASE0(&mut self, val: u32) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u32 = 0xffff_ffff;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Base address 1"]
    pub type BASE1 = base1::Register;
    #[doc = "Base address 1"]
    pub mod base1 {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0520) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bits 0..=32) Base address 1"]
            pub fn BASE1(self) -> u32 {
                const OFFSET: u8 = 0;
                const MASK: u32 = 0xffff_ffff;
                ((self.inner >> OFFSET) as u32) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u32 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "BASE1 {{ BASE1: {0:32} }}@12486764342508972908"]
                #[link_section = ".binfmt.BASE1 {{ BASE1: {0:32} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bits 0..=32) Base address 1"]
            #[allow(non_snake_case)]
            pub fn BASE1(&mut self, val: u32) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u32 = 0xffff_ffff;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Prefixes bytes for logical addresses 0-3"]
    pub type PREFIX0 = prefix0::Register;
    #[doc = "Prefixes bytes for logical addresses 0-3"]
    pub mod prefix0 {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0524) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bits 0..=8) Address prefix 0."]
            pub fn AP0(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0xff;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bits 8..=16) Address prefix 1."]
            pub fn AP1(self) -> u8 {
                const OFFSET: u8 = 8;
                const MASK: u8 = 0xff;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bits 16..=24) Address prefix 2."]
            pub fn AP2(self) -> u8 {
                const OFFSET: u8 = 16;
                const MASK: u8 = 0xff;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bits 24..=32) Address prefix 3."]
            pub fn AP3(self) -> u8 {
                const OFFSET: u8 = 24;
                const MASK: u8 = 0xff;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u32 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "PREFIX0 {{ AP3: {24:32}, AP2: {16:24}, AP1: {8:16}, AP0: {0:8} }}@13623869083571743407"]
                #[link_section = ".binfmt.PREFIX0 {{ AP3: {24:32}, AP2: {16:24}, AP1: {8:16}, AP0: {0:8} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bits 0..=8) Address prefix 0."]
            #[allow(non_snake_case)]
            pub fn AP0(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0xff;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bits 8..=16) Address prefix 1."]
            #[allow(non_snake_case)]
            pub fn AP1(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 8;
                const MASK: u8 = 0xff;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bits 16..=24) Address prefix 2."]
            #[allow(non_snake_case)]
            pub fn AP2(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 16;
                const MASK: u8 = 0xff;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bits 24..=32) Address prefix 3."]
            #[allow(non_snake_case)]
            pub fn AP3(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 24;
                const MASK: u8 = 0xff;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Prefixes bytes for logical addresses 4-7"]
    pub type PREFIX1 = prefix1::Register;
    #[doc = "Prefixes bytes for logical addresses 4-7"]
    pub mod prefix1 {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0528) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bits 0..=8) Address prefix 4."]
            pub fn AP4(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0xff;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bits 8..=16) Address prefix 5."]
            pub fn AP5(self) -> u8 {
                const OFFSET: u8 = 8;
                const MASK: u8 = 0xff;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bits 16..=24) Address prefix 6."]
            pub fn AP6(self) -> u8 {
                const OFFSET: u8 = 16;
                const MASK: u8 = 0xff;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bits 24..=32) Address prefix 7."]
            pub fn AP7(self) -> u8 {
                const OFFSET: u8 = 24;
                const MASK: u8 = 0xff;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u32 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "PREFIX1 {{ AP7: {24:32}, AP6: {16:24}, AP5: {8:16}, AP4: {0:8} }}@5584925215501726202"]
                #[link_section = ".binfmt.PREFIX1 {{ AP7: {24:32}, AP6: {16:24}, AP5: {8:16}, AP4: {0:8} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bits 0..=8) Address prefix 4."]
            #[allow(non_snake_case)]
            pub fn AP4(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0xff;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bits 8..=16) Address prefix 5."]
            #[allow(non_snake_case)]
            pub fn AP5(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 8;
                const MASK: u8 = 0xff;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bits 16..=24) Address prefix 6."]
            #[allow(non_snake_case)]
            pub fn AP6(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 16;
                const MASK: u8 = 0xff;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bits 24..=32) Address prefix 7."]
            #[allow(non_snake_case)]
            pub fn AP7(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 24;
                const MASK: u8 = 0xff;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Transmit address select"]
    pub type TXADDRESS = txaddress::Register;
    #[doc = "Transmit address select"]
    pub mod txaddress {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x052c) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bits 0..=3) Transmit address select"]
            pub fn TXADDRESS(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x07;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u8 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "TXADDRESS {{ TXADDRESS: {0:3} }}@8566873255911577065"]
                #[link_section = ".binfmt.TXADDRESS {{ TXADDRESS: {0:3} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bits 0..=3) Transmit address select"]
            #[allow(non_snake_case)]
            pub fn TXADDRESS(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x07;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Receive address select"]
    pub type RXADDRESSES = rxaddresses::Register;
    #[doc = "Receive address select"]
    pub mod rxaddresses {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0530) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bit 0) Enable or disable reception on logical address 0."]
            pub fn ADDR0(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 1) Enable or disable reception on logical address 1."]
            pub fn ADDR1(self) -> u8 {
                const OFFSET: u8 = 1;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 2) Enable or disable reception on logical address 2."]
            pub fn ADDR2(self) -> u8 {
                const OFFSET: u8 = 2;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 3) Enable or disable reception on logical address 3."]
            pub fn ADDR3(self) -> u8 {
                const OFFSET: u8 = 3;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 4) Enable or disable reception on logical address 4."]
            pub fn ADDR4(self) -> u8 {
                const OFFSET: u8 = 4;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 5) Enable or disable reception on logical address 5."]
            pub fn ADDR5(self) -> u8 {
                const OFFSET: u8 = 5;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 6) Enable or disable reception on logical address 6."]
            pub fn ADDR6(self) -> u8 {
                const OFFSET: u8 = 6;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 7) Enable or disable reception on logical address 7."]
            pub fn ADDR7(self) -> u8 {
                const OFFSET: u8 = 7;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u8 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "RXADDRESSES {{ ADDR7: {7}, ADDR6: {6}, ADDR5: {5}, ADDR4: {4}, ADDR3: {3}, ADDR2: {2}, ADDR1: {1}, ADDR0: {0} }}@5248597331750215441"]
                #[link_section = ".binfmt.RXADDRESSES {{ ADDR7: {7}, ADDR6: {6}, ADDR5: {5}, ADDR4: {4}, ADDR3: {3}, ADDR2: {2}, ADDR1: {1}, ADDR0: {0} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 0) Enable or disable reception on logical address 0."]
            #[allow(non_snake_case)]
            pub fn ADDR0(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 1) Enable or disable reception on logical address 1."]
            #[allow(non_snake_case)]
            pub fn ADDR1(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 1;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 2) Enable or disable reception on logical address 2."]
            #[allow(non_snake_case)]
            pub fn ADDR2(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 2;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 3) Enable or disable reception on logical address 3."]
            #[allow(non_snake_case)]
            pub fn ADDR3(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 3;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 4) Enable or disable reception on logical address 4."]
            #[allow(non_snake_case)]
            pub fn ADDR4(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 4;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 5) Enable or disable reception on logical address 5."]
            #[allow(non_snake_case)]
            pub fn ADDR5(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 5;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 6) Enable or disable reception on logical address 6."]
            #[allow(non_snake_case)]
            pub fn ADDR6(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 6;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 7) Enable or disable reception on logical address 7."]
            #[allow(non_snake_case)]
            pub fn ADDR7(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 7;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "CRC configuration"]
    pub type CRCCNF = crccnf::Register;
    #[doc = "CRC configuration"]
    pub mod crccnf {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0534) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bits 0..=2) CRC length in number of bytes."]
            pub fn LEN(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x03;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bits 8..=10) Include or exclude packet address field out of CRC calculation."]
            pub fn SKIPADDR(self) -> u8 {
                const OFFSET: u8 = 8;
                const MASK: u8 = 0x03;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u16 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "CRCCNF {{ SKIPADDR: {8:10}, LEN: {0:2} }}@6900853654784450457"]
                #[link_section = ".binfmt.CRCCNF {{ SKIPADDR: {8:10}, LEN: {0:2} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bits 0..=2) CRC length in number of bytes."]
            #[allow(non_snake_case)]
            pub fn LEN(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x03;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bits 8..=10) Include or exclude packet address field out of CRC calculation."]
            #[allow(non_snake_case)]
            pub fn SKIPADDR(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 8;
                const MASK: u8 = 0x03;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "CRC polynomial"]
    pub type CRCPOLY = crcpoly::Register;
    #[doc = "CRC polynomial"]
    pub mod crcpoly {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0538) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bits 0..=24) CRC polynomial"]
            pub fn CRCPOLY(self) -> u32 {
                const OFFSET: u8 = 0;
                const MASK: u32 = 0x00ff_ffff;
                ((self.inner >> OFFSET) as u32) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u32 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "CRCPOLY {{ CRCPOLY: {0:24} }}@17242551564803665256"]
                #[link_section = ".binfmt.CRCPOLY {{ CRCPOLY: {0:24} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bits 0..=24) CRC polynomial"]
            #[allow(non_snake_case)]
            pub fn CRCPOLY(&mut self, val: u32) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u32 = 0x00ff_ffff;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "CRC initial value"]
    pub type CRCINIT = crcinit::Register;
    #[doc = "CRC initial value"]
    pub mod crcinit {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x053c) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bits 0..=24) CRC initial value"]
            pub fn CRCINIT(self) -> u32 {
                const OFFSET: u8 = 0;
                const MASK: u32 = 0x00ff_ffff;
                ((self.inner >> OFFSET) as u32) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u32 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "CRCINIT {{ CRCINIT: {0:24} }}@12844318045362163180"]
                #[link_section = ".binfmt.CRCINIT {{ CRCINIT: {0:24} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bits 0..=24) CRC initial value"]
            #[allow(non_snake_case)]
            pub fn CRCINIT(&mut self, val: u32) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u32 = 0x00ff_ffff;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Interframe spacing in us"]
    pub type TIFS = tifs::Register;
    #[doc = "Interframe spacing in us"]
    pub mod tifs {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0544) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bits 0..=10) Interframe spacing in us"]
            pub fn TIFS(self) -> u16 {
                const OFFSET: u8 = 0;
                const MASK: u16 = 0x03ff;
                ((self.inner >> OFFSET) as u16) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u16 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "TIFS {{ TIFS: {0:10} }}@15109869084370732344"]
                #[link_section = ".binfmt.TIFS {{ TIFS: {0:10} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bits 0..=10) Interframe spacing in us"]
            #[allow(non_snake_case)]
            pub fn TIFS(&mut self, val: u16) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u16 = 0x03ff;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "RSSI sample"]
    pub type RSSISAMPLE = rssisample::Register;
    #[doc = "RSSI sample"]
    pub mod rssisample {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *const u32 {
                (super::BASE_ADDRESS + 0x0548) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bits 0..=7) RSSI sample"]
            pub fn RSSISAMPLE(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x7f;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u8 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "RSSISAMPLE {{ RSSISAMPLE: {0:7} }}@3886831511193412311"]
                #[link_section = ".binfmt.RSSISAMPLE {{ RSSISAMPLE: {0:7} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Current radio state"]
    pub type STATE = state::Register;
    #[doc = "Current radio state"]
    pub mod state {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *const u32 {
                (super::BASE_ADDRESS + 0x0550) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bits 0..=4) Current radio state"]
            pub fn STATE(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x0f;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u8 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "STATE {{ STATE: {0:4} }}@9513108421237454313"]
                #[link_section = ".binfmt.STATE {{ STATE: {0:4} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Data whitening initial value"]
    pub type DATAWHITEIV = datawhiteiv::Register;
    #[doc = "Data whitening initial value"]
    pub mod datawhiteiv {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0554) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bits 0..=7) Data whitening initial value. Bit 6 is hard-wired to '1', writing '0' to it has no effect, and it will always be read back and used by the device as '1'."]
            pub fn DATAWHITEIV(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x7f;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u8 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "DATAWHITEIV {{ DATAWHITEIV: {0:7} }}@7069222225164697401"]
                #[link_section = ".binfmt.DATAWHITEIV {{ DATAWHITEIV: {0:7} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bits 0..=7) Data whitening initial value. Bit 6 is hard-wired to '1', writing '0' to it has no effect, and it will always be read back and used by the device as '1'."]
            #[allow(non_snake_case)]
            pub fn DATAWHITEIV(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x7f;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Bit counter compare"]
    pub type BCC = bcc::Register;
    #[doc = "Bit counter compare"]
    pub mod bcc {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0560) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bits 0..=32) Bit counter compare"]
            pub fn BCC(self) -> u32 {
                const OFFSET: u8 = 0;
                const MASK: u32 = 0xffff_ffff;
                ((self.inner >> OFFSET) as u32) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u32 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "BCC {{ BCC: {0:32} }}@340360875286139007"]
                #[link_section = ".binfmt.BCC {{ BCC: {0:32} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bits 0..=32) Bit counter compare"]
            #[allow(non_snake_case)]
            pub fn BCC(&mut self, val: u32) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u32 = 0xffff_ffff;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Description collection: Device address base segment n"]
    pub type DAB0 = dab0::Register;
    #[doc = "Description collection: Device address base segment n"]
    pub mod dab0 {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0600) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bits 0..=32) Device address base segment n"]
            pub fn DAB(self) -> u32 {
                const OFFSET: u8 = 0;
                const MASK: u32 = 0xffff_ffff;
                ((self.inner >> OFFSET) as u32) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u32 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "DAB0 {{ DAB: {0:32} }}@9764955443650283248"]
                #[link_section = ".binfmt.DAB0 {{ DAB: {0:32} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bits 0..=32) Device address base segment n"]
            #[allow(non_snake_case)]
            pub fn DAB(&mut self, val: u32) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u32 = 0xffff_ffff;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Description collection: Device address base segment n"]
    pub type DAB1 = dab1::Register;
    #[doc = "Description collection: Device address base segment n"]
    pub mod dab1 {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0604) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bits 0..=32) Device address base segment n"]
            pub fn DAB(self) -> u32 {
                const OFFSET: u8 = 0;
                const MASK: u32 = 0xffff_ffff;
                ((self.inner >> OFFSET) as u32) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u32 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "DAB1 {{ DAB: {0:32} }}@1755788123155641178"]
                #[link_section = ".binfmt.DAB1 {{ DAB: {0:32} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bits 0..=32) Device address base segment n"]
            #[allow(non_snake_case)]
            pub fn DAB(&mut self, val: u32) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u32 = 0xffff_ffff;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Description collection: Device address base segment n"]
    pub type DAB2 = dab2::Register;
    #[doc = "Description collection: Device address base segment n"]
    pub mod dab2 {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0608) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bits 0..=32) Device address base segment n"]
            pub fn DAB(self) -> u32 {
                const OFFSET: u8 = 0;
                const MASK: u32 = 0xffff_ffff;
                ((self.inner >> OFFSET) as u32) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u32 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "DAB2 {{ DAB: {0:32} }}@15843164351549994819"]
                #[link_section = ".binfmt.DAB2 {{ DAB: {0:32} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bits 0..=32) Device address base segment n"]
            #[allow(non_snake_case)]
            pub fn DAB(&mut self, val: u32) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u32 = 0xffff_ffff;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Description collection: Device address base segment n"]
    pub type DAB3 = dab3::Register;
    #[doc = "Description collection: Device address base segment n"]
    pub mod dab3 {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x060c) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bits 0..=32) Device address base segment n"]
            pub fn DAB(self) -> u32 {
                const OFFSET: u8 = 0;
                const MASK: u32 = 0xffff_ffff;
                ((self.inner >> OFFSET) as u32) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u32 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "DAB3 {{ DAB: {0:32} }}@12509386658255098443"]
                #[link_section = ".binfmt.DAB3 {{ DAB: {0:32} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bits 0..=32) Device address base segment n"]
            #[allow(non_snake_case)]
            pub fn DAB(&mut self, val: u32) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u32 = 0xffff_ffff;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Description collection: Device address base segment n"]
    pub type DAB4 = dab4::Register;
    #[doc = "Description collection: Device address base segment n"]
    pub mod dab4 {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0610) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bits 0..=32) Device address base segment n"]
            pub fn DAB(self) -> u32 {
                const OFFSET: u8 = 0;
                const MASK: u32 = 0xffff_ffff;
                ((self.inner >> OFFSET) as u32) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u32 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "DAB4 {{ DAB: {0:32} }}@15860308175119925500"]
                #[link_section = ".binfmt.DAB4 {{ DAB: {0:32} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bits 0..=32) Device address base segment n"]
            #[allow(non_snake_case)]
            pub fn DAB(&mut self, val: u32) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u32 = 0xffff_ffff;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Description collection: Device address base segment n"]
    pub type DAB5 = dab5::Register;
    #[doc = "Description collection: Device address base segment n"]
    pub mod dab5 {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0614) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bits 0..=32) Device address base segment n"]
            pub fn DAB(self) -> u32 {
                const OFFSET: u8 = 0;
                const MASK: u32 = 0xffff_ffff;
                ((self.inner >> OFFSET) as u32) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u32 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "DAB5 {{ DAB: {0:32} }}@9956351022277259138"]
                #[link_section = ".binfmt.DAB5 {{ DAB: {0:32} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bits 0..=32) Device address base segment n"]
            #[allow(non_snake_case)]
            pub fn DAB(&mut self, val: u32) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u32 = 0xffff_ffff;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Description collection: Device address base segment n"]
    pub type DAB6 = dab6::Register;
    #[doc = "Description collection: Device address base segment n"]
    pub mod dab6 {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0618) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bits 0..=32) Device address base segment n"]
            pub fn DAB(self) -> u32 {
                const OFFSET: u8 = 0;
                const MASK: u32 = 0xffff_ffff;
                ((self.inner >> OFFSET) as u32) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u32 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "DAB6 {{ DAB: {0:32} }}@9445352682154400153"]
                #[link_section = ".binfmt.DAB6 {{ DAB: {0:32} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bits 0..=32) Device address base segment n"]
            #[allow(non_snake_case)]
            pub fn DAB(&mut self, val: u32) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u32 = 0xffff_ffff;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Description collection: Device address base segment n"]
    pub type DAB7 = dab7::Register;
    #[doc = "Description collection: Device address base segment n"]
    pub mod dab7 {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x061c) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bits 0..=32) Device address base segment n"]
            pub fn DAB(self) -> u32 {
                const OFFSET: u8 = 0;
                const MASK: u32 = 0xffff_ffff;
                ((self.inner >> OFFSET) as u32) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u32 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "DAB7 {{ DAB: {0:32} }}@16953351745537629991"]
                #[link_section = ".binfmt.DAB7 {{ DAB: {0:32} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bits 0..=32) Device address base segment n"]
            #[allow(non_snake_case)]
            pub fn DAB(&mut self, val: u32) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u32 = 0xffff_ffff;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Description collection: Device address prefix n"]
    pub type DAP0 = dap0::Register;
    #[doc = "Description collection: Device address prefix n"]
    pub mod dap0 {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0620) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bits 0..=16) Device address prefix n"]
            pub fn DAP(self) -> u16 {
                const OFFSET: u8 = 0;
                const MASK: u16 = 0xffff;
                ((self.inner >> OFFSET) as u16) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u16 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "DAP0 {{ DAP: {0:16} }}@10372789774415101751"]
                #[link_section = ".binfmt.DAP0 {{ DAP: {0:16} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bits 0..=16) Device address prefix n"]
            #[allow(non_snake_case)]
            pub fn DAP(&mut self, val: u16) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u16 = 0xffff;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Description collection: Device address prefix n"]
    pub type DAP1 = dap1::Register;
    #[doc = "Description collection: Device address prefix n"]
    pub mod dap1 {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0624) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bits 0..=16) Device address prefix n"]
            pub fn DAP(self) -> u16 {
                const OFFSET: u8 = 0;
                const MASK: u16 = 0xffff;
                ((self.inner >> OFFSET) as u16) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u16 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "DAP1 {{ DAP: {0:16} }}@8109635085078726249"]
                #[link_section = ".binfmt.DAP1 {{ DAP: {0:16} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bits 0..=16) Device address prefix n"]
            #[allow(non_snake_case)]
            pub fn DAP(&mut self, val: u16) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u16 = 0xffff;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Description collection: Device address prefix n"]
    pub type DAP2 = dap2::Register;
    #[doc = "Description collection: Device address prefix n"]
    pub mod dap2 {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0628) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bits 0..=16) Device address prefix n"]
            pub fn DAP(self) -> u16 {
                const OFFSET: u8 = 0;
                const MASK: u16 = 0xffff;
                ((self.inner >> OFFSET) as u16) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u16 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "DAP2 {{ DAP: {0:16} }}@5550389631231219269"]
                #[link_section = ".binfmt.DAP2 {{ DAP: {0:16} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bits 0..=16) Device address prefix n"]
            #[allow(non_snake_case)]
            pub fn DAP(&mut self, val: u16) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u16 = 0xffff;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Description collection: Device address prefix n"]
    pub type DAP3 = dap3::Register;
    #[doc = "Description collection: Device address prefix n"]
    pub mod dap3 {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x062c) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bits 0..=16) Device address prefix n"]
            pub fn DAP(self) -> u16 {
                const OFFSET: u8 = 0;
                const MASK: u16 = 0xffff;
                ((self.inner >> OFFSET) as u16) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u16 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "DAP3 {{ DAP: {0:16} }}@9289542831309335793"]
                #[link_section = ".binfmt.DAP3 {{ DAP: {0:16} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bits 0..=16) Device address prefix n"]
            #[allow(non_snake_case)]
            pub fn DAP(&mut self, val: u16) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u16 = 0xffff;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Description collection: Device address prefix n"]
    pub type DAP4 = dap4::Register;
    #[doc = "Description collection: Device address prefix n"]
    pub mod dap4 {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0630) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bits 0..=16) Device address prefix n"]
            pub fn DAP(self) -> u16 {
                const OFFSET: u8 = 0;
                const MASK: u16 = 0xffff;
                ((self.inner >> OFFSET) as u16) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u16 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "DAP4 {{ DAP: {0:16} }}@14274892327656441306"]
                #[link_section = ".binfmt.DAP4 {{ DAP: {0:16} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bits 0..=16) Device address prefix n"]
            #[allow(non_snake_case)]
            pub fn DAP(&mut self, val: u16) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u16 = 0xffff;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Description collection: Device address prefix n"]
    pub type DAP5 = dap5::Register;
    #[doc = "Description collection: Device address prefix n"]
    pub mod dap5 {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0634) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bits 0..=16) Device address prefix n"]
            pub fn DAP(self) -> u16 {
                const OFFSET: u8 = 0;
                const MASK: u16 = 0xffff;
                ((self.inner >> OFFSET) as u16) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u16 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "DAP5 {{ DAP: {0:16} }}@8534635422119999846"]
                #[link_section = ".binfmt.DAP5 {{ DAP: {0:16} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bits 0..=16) Device address prefix n"]
            #[allow(non_snake_case)]
            pub fn DAP(&mut self, val: u16) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u16 = 0xffff;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Description collection: Device address prefix n"]
    pub type DAP6 = dap6::Register;
    #[doc = "Description collection: Device address prefix n"]
    pub mod dap6 {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0638) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bits 0..=16) Device address prefix n"]
            pub fn DAP(self) -> u16 {
                const OFFSET: u8 = 0;
                const MASK: u16 = 0xffff;
                ((self.inner >> OFFSET) as u16) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u16 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "DAP6 {{ DAP: {0:16} }}@10565311485192454451"]
                #[link_section = ".binfmt.DAP6 {{ DAP: {0:16} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bits 0..=16) Device address prefix n"]
            #[allow(non_snake_case)]
            pub fn DAP(&mut self, val: u16) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u16 = 0xffff;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Description collection: Device address prefix n"]
    pub type DAP7 = dap7::Register;
    #[doc = "Description collection: Device address prefix n"]
    pub mod dap7 {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x063c) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bits 0..=16) Device address prefix n"]
            pub fn DAP(self) -> u16 {
                const OFFSET: u8 = 0;
                const MASK: u16 = 0xffff;
                ((self.inner >> OFFSET) as u16) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u16 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "DAP7 {{ DAP: {0:16} }}@12616870078688410477"]
                #[link_section = ".binfmt.DAP7 {{ DAP: {0:16} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bits 0..=16) Device address prefix n"]
            #[allow(non_snake_case)]
            pub fn DAP(&mut self, val: u16) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u16 = 0xffff;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Device address match configuration"]
    pub type DACNF = dacnf::Register;
    #[doc = "Device address match configuration"]
    pub mod dacnf {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0640) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bit 0) Enable or disable device address matching using device address 0"]
            pub fn ENA0(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 1) Enable or disable device address matching using device address 1"]
            pub fn ENA1(self) -> u8 {
                const OFFSET: u8 = 1;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 2) Enable or disable device address matching using device address 2"]
            pub fn ENA2(self) -> u8 {
                const OFFSET: u8 = 2;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 3) Enable or disable device address matching using device address 3"]
            pub fn ENA3(self) -> u8 {
                const OFFSET: u8 = 3;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 4) Enable or disable device address matching using device address 4"]
            pub fn ENA4(self) -> u8 {
                const OFFSET: u8 = 4;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 5) Enable or disable device address matching using device address 5"]
            pub fn ENA5(self) -> u8 {
                const OFFSET: u8 = 5;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 6) Enable or disable device address matching using device address 6"]
            pub fn ENA6(self) -> u8 {
                const OFFSET: u8 = 6;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 7) Enable or disable device address matching using device address 7"]
            pub fn ENA7(self) -> u8 {
                const OFFSET: u8 = 7;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 8) TxAdd for device address 0"]
            pub fn TXADD0(self) -> u8 {
                const OFFSET: u8 = 8;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 9) TxAdd for device address 1"]
            pub fn TXADD1(self) -> u8 {
                const OFFSET: u8 = 9;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 10) TxAdd for device address 2"]
            pub fn TXADD2(self) -> u8 {
                const OFFSET: u8 = 10;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 11) TxAdd for device address 3"]
            pub fn TXADD3(self) -> u8 {
                const OFFSET: u8 = 11;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 12) TxAdd for device address 4"]
            pub fn TXADD4(self) -> u8 {
                const OFFSET: u8 = 12;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 13) TxAdd for device address 5"]
            pub fn TXADD5(self) -> u8 {
                const OFFSET: u8 = 13;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 14) TxAdd for device address 6"]
            pub fn TXADD6(self) -> u8 {
                const OFFSET: u8 = 14;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 15) TxAdd for device address 7"]
            pub fn TXADD7(self) -> u8 {
                const OFFSET: u8 = 15;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u16 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "DACNF {{ TXADD7: {15}, TXADD6: {14}, TXADD5: {13}, TXADD4: {12}, TXADD3: {11}, TXADD2: {10}, TXADD1: {9}, TXADD0: {8}, ENA7: {7}, ENA6: {6}, ENA5: {5}, ENA4: {4}, ENA3: {3}, ENA2: {2}, ENA1: {1}, ENA0: {0} }}@4833496070440068468"]
                #[link_section = ".binfmt.DACNF {{ TXADD7: {15}, TXADD6: {14}, TXADD5: {13}, TXADD4: {12}, TXADD3: {11}, TXADD2: {10}, TXADD1: {9}, TXADD0: {8}, ENA7: {7}, ENA6: {6}, ENA5: {5}, ENA4: {4}, ENA3: {3}, ENA2: {2}, ENA1: {1}, ENA0: {0} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 0) Enable or disable device address matching using device address 0"]
            #[allow(non_snake_case)]
            pub fn ENA0(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 1) Enable or disable device address matching using device address 1"]
            #[allow(non_snake_case)]
            pub fn ENA1(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 1;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 2) Enable or disable device address matching using device address 2"]
            #[allow(non_snake_case)]
            pub fn ENA2(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 2;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 3) Enable or disable device address matching using device address 3"]
            #[allow(non_snake_case)]
            pub fn ENA3(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 3;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 4) Enable or disable device address matching using device address 4"]
            #[allow(non_snake_case)]
            pub fn ENA4(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 4;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 5) Enable or disable device address matching using device address 5"]
            #[allow(non_snake_case)]
            pub fn ENA5(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 5;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 6) Enable or disable device address matching using device address 6"]
            #[allow(non_snake_case)]
            pub fn ENA6(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 6;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 7) Enable or disable device address matching using device address 7"]
            #[allow(non_snake_case)]
            pub fn ENA7(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 7;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 8) TxAdd for device address 0"]
            #[allow(non_snake_case)]
            pub fn TXADD0(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 8;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 9) TxAdd for device address 1"]
            #[allow(non_snake_case)]
            pub fn TXADD1(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 9;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 10) TxAdd for device address 2"]
            #[allow(non_snake_case)]
            pub fn TXADD2(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 10;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 11) TxAdd for device address 3"]
            #[allow(non_snake_case)]
            pub fn TXADD3(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 11;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 12) TxAdd for device address 4"]
            #[allow(non_snake_case)]
            pub fn TXADD4(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 12;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 13) TxAdd for device address 5"]
            #[allow(non_snake_case)]
            pub fn TXADD5(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 13;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 14) TxAdd for device address 6"]
            #[allow(non_snake_case)]
            pub fn TXADD6(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 14;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 15) TxAdd for device address 7"]
            #[allow(non_snake_case)]
            pub fn TXADD7(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 15;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Search pattern configuration"]
    pub type MHRMATCHCONF = mhrmatchconf::Register;
    #[doc = "Search pattern configuration"]
    pub mod mhrmatchconf {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0644) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bits 0..=32) Search pattern configuration"]
            pub fn MHRMATCHCONF(self) -> u32 {
                const OFFSET: u8 = 0;
                const MASK: u32 = 0xffff_ffff;
                ((self.inner >> OFFSET) as u32) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u32 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "MHRMATCHCONF {{ MHRMATCHCONF: {0:32} }}@12484038222578842957"]
                #[link_section = ".binfmt.MHRMATCHCONF {{ MHRMATCHCONF: {0:32} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bits 0..=32) Search pattern configuration"]
            #[allow(non_snake_case)]
            pub fn MHRMATCHCONF(&mut self, val: u32) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u32 = 0xffff_ffff;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Pattern mask"]
    pub type MHRMATCHMAS = mhrmatchmas::Register;
    #[doc = "Pattern mask"]
    pub mod mhrmatchmas {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0648) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bits 0..=32) Pattern mask"]
            pub fn MHRMATCHMAS(self) -> u32 {
                const OFFSET: u8 = 0;
                const MASK: u32 = 0xffff_ffff;
                ((self.inner >> OFFSET) as u32) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u32 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "MHRMATCHMAS {{ MHRMATCHMAS: {0:32} }}@18358781460347412039"]
                #[link_section = ".binfmt.MHRMATCHMAS {{ MHRMATCHMAS: {0:32} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bits 0..=32) Pattern mask"]
            #[allow(non_snake_case)]
            pub fn MHRMATCHMAS(&mut self, val: u32) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u32 = 0xffff_ffff;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Radio mode configuration register 0"]
    pub type MODECNF0 = modecnf0::Register;
    #[doc = "Radio mode configuration register 0"]
    pub mod modecnf0 {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0650) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bit 0) Radio ramp-up time"]
            pub fn RU(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bits 8..=10) Default TX value"]
            pub fn DTX(self) -> u8 {
                const OFFSET: u8 = 8;
                const MASK: u8 = 0x03;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u16 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "MODECNF0 {{ DTX: {8:10}, RU: {0} }}@4479968298858195832"]
                #[link_section = ".binfmt.MODECNF0 {{ DTX: {8:10}, RU: {0} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 0) Radio ramp-up time"]
            #[allow(non_snake_case)]
            pub fn RU(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bits 8..=10) Default TX value"]
            #[allow(non_snake_case)]
            pub fn DTX(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 8;
                const MASK: u8 = 0x03;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "IEEE 802.15.4 start of frame delimiter"]
    pub type SFD = sfd::Register;
    #[doc = "IEEE 802.15.4 start of frame delimiter"]
    pub mod sfd {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0660) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bits 0..=8) IEEE 802.15.4 start of frame delimiter"]
            pub fn SFD(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0xff;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u8 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "SFD {{ SFD: {0:8} }}@11564283408499413002"]
                #[link_section = ".binfmt.SFD {{ SFD: {0:8} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bits 0..=8) IEEE 802.15.4 start of frame delimiter"]
            #[allow(non_snake_case)]
            pub fn SFD(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0xff;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "IEEE 802.15.4 energy detect loop count"]
    pub type EDCNT = edcnt::Register;
    #[doc = "IEEE 802.15.4 energy detect loop count"]
    pub mod edcnt {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0664) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bits 0..=21) IEEE 802.15.4 energy detect loop count"]
            pub fn EDCNT(self) -> u32 {
                const OFFSET: u8 = 0;
                const MASK: u32 = 0x001f_ffff;
                ((self.inner >> OFFSET) as u32) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u32 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "EDCNT {{ EDCNT: {0:21} }}@14792451863405938401"]
                #[link_section = ".binfmt.EDCNT {{ EDCNT: {0:21} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bits 0..=21) IEEE 802.15.4 energy detect loop count"]
            #[allow(non_snake_case)]
            pub fn EDCNT(&mut self, val: u32) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u32 = 0x001f_ffff;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "IEEE 802.15.4 energy detect level"]
    pub type EDSAMPLE = edsample::Register;
    #[doc = "IEEE 802.15.4 energy detect level"]
    pub mod edsample {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0668) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bits 0..=8) IEEE 802.15.4 energy detect level"]
            pub fn EDLVL(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0xff;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u8 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "EDSAMPLE {{ EDLVL: {0:8} }}@9566390466464255099"]
                #[link_section = ".binfmt.EDSAMPLE {{ EDLVL: {0:8} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bits 0..=8) IEEE 802.15.4 energy detect level"]
            #[allow(non_snake_case)]
            pub fn EDLVL(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0xff;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "IEEE 802.15.4 clear channel assessment control"]
    pub type CCACTRL = ccactrl::Register;
    #[doc = "IEEE 802.15.4 clear channel assessment control"]
    pub mod ccactrl {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x066c) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bits 0..=3) CCA mode of operation"]
            pub fn CCAMODE(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x07;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bits 8..=16) CCA energy busy threshold. Used in all the CCA modes except CarrierMode."]
            pub fn CCAEDTHRES(self) -> u8 {
                const OFFSET: u8 = 8;
                const MASK: u8 = 0xff;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bits 16..=24) CCA correlator busy threshold. Only relevant to CarrierMode, CarrierAndEdMode and CarrierOrEdMode."]
            pub fn CCACORRTHRES(self) -> u8 {
                const OFFSET: u8 = 16;
                const MASK: u8 = 0xff;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bits 24..=32) Limit for occurances above CCACORRTHRES. When not equal to zero the corrolator based signal detect is enabled."]
            pub fn CCACORRCNT(self) -> u8 {
                const OFFSET: u8 = 24;
                const MASK: u8 = 0xff;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u32 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "CCACTRL {{ CCACORRCNT: {24:32}, CCACORRTHRES: {16:24}, CCAEDTHRES: {8:16}, CCAMODE: {0:3} }}@10524555976080927814"]
                #[link_section = ".binfmt.CCACTRL {{ CCACORRCNT: {24:32}, CCACORRTHRES: {16:24}, CCAEDTHRES: {8:16}, CCAMODE: {0:3} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bits 0..=3) CCA mode of operation"]
            #[allow(non_snake_case)]
            pub fn CCAMODE(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x07;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bits 8..=16) CCA energy busy threshold. Used in all the CCA modes except CarrierMode."]
            #[allow(non_snake_case)]
            pub fn CCAEDTHRES(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 8;
                const MASK: u8 = 0xff;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bits 16..=24) CCA correlator busy threshold. Only relevant to CarrierMode, CarrierAndEdMode and CarrierOrEdMode."]
            #[allow(non_snake_case)]
            pub fn CCACORRTHRES(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 16;
                const MASK: u8 = 0xff;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bits 24..=32) Limit for occurances above CCACORRTHRES. When not equal to zero the corrolator based signal detect is enabled."]
            #[allow(non_snake_case)]
            pub fn CCACORRCNT(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 24;
                const MASK: u8 = 0xff;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Peripheral power control"]
    pub type POWER = power::Register;
    #[doc = "Peripheral power control"]
    pub mod power {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0ffc) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bit 0) Peripheral power control. The peripheral and its registers will be reset to its initial state by switching the peripheral off and then back on again."]
            pub fn POWER(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u8 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "POWER {{ POWER: {0} }}@10075836600751511304"]
                #[link_section = ".binfmt.POWER {{ POWER: {0} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 0) Peripheral power control. The peripheral and its registers will be reset to its initial state by switching the peripheral off and then back on again."]
            #[allow(non_snake_case)]
            pub fn POWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    use core::sync::atomic::{AtomicBool, Ordering};
    const BASE_ADDRESS: usize = 0x4000_1000;
    #[allow(non_snake_case)]
    #[doc = "Singleton handle to the RADIO registers"]
    pub struct Registers {
        #[doc = "Enable RADIO in TX mode"]
        pub TASKS_TXEN: TASKS_TXEN,
        #[doc = "Enable RADIO in RX mode"]
        pub TASKS_RXEN: TASKS_RXEN,
        #[doc = "Start RADIO"]
        pub TASKS_START: TASKS_START,
        #[doc = "Stop RADIO"]
        pub TASKS_STOP: TASKS_STOP,
        #[doc = "Disable RADIO"]
        pub TASKS_DISABLE: TASKS_DISABLE,
        #[doc = "Start the RSSI and take one single sample of the receive signal strength"]
        pub TASKS_RSSISTART: TASKS_RSSISTART,
        #[doc = "Stop the RSSI measurement"]
        pub TASKS_RSSISTOP: TASKS_RSSISTOP,
        #[doc = "Start the bit counter"]
        pub TASKS_BCSTART: TASKS_BCSTART,
        #[doc = "Stop the bit counter"]
        pub TASKS_BCSTOP: TASKS_BCSTOP,
        #[doc = "Start the energy detect measurement used in IEEE 802.15.4 mode"]
        pub TASKS_EDSTART: TASKS_EDSTART,
        #[doc = "Stop the energy detect measurement"]
        pub TASKS_EDSTOP: TASKS_EDSTOP,
        #[doc = "Start the clear channel assessment used in IEEE 802.15.4 mode"]
        pub TASKS_CCASTART: TASKS_CCASTART,
        #[doc = "Stop the clear channel assessment"]
        pub TASKS_CCASTOP: TASKS_CCASTOP,
        #[doc = "RADIO has ramped up and is ready to be started"]
        pub EVENTS_READY: EVENTS_READY,
        #[doc = "Address sent or received"]
        pub EVENTS_ADDRESS: EVENTS_ADDRESS,
        #[doc = "Packet payload sent or received"]
        pub EVENTS_PAYLOAD: EVENTS_PAYLOAD,
        #[doc = "Packet sent or received"]
        pub EVENTS_END: EVENTS_END,
        #[doc = "RADIO has been disabled"]
        pub EVENTS_DISABLED: EVENTS_DISABLED,
        #[doc = "A device address match occurred on the last received packet"]
        pub EVENTS_DEVMATCH: EVENTS_DEVMATCH,
        #[doc = "No device address match occurred on the last received packet"]
        pub EVENTS_DEVMISS: EVENTS_DEVMISS,
        #[doc = "Sampling of receive signal strength complete"]
        pub EVENTS_RSSIEND: EVENTS_RSSIEND,
        #[doc = "Bit counter reached bit count value"]
        pub EVENTS_BCMATCH: EVENTS_BCMATCH,
        #[doc = "Packet received with CRC ok"]
        pub EVENTS_CRCOK: EVENTS_CRCOK,
        #[doc = "Packet received with CRC error"]
        pub EVENTS_CRCERROR: EVENTS_CRCERROR,
        #[doc = "IEEE 802.15.4 length field received"]
        pub EVENTS_FRAMESTART: EVENTS_FRAMESTART,
        #[doc = "Sampling of energy detection complete. A new ED sample is ready for readout from the RADIO.EDSAMPLE register."]
        pub EVENTS_EDEND: EVENTS_EDEND,
        #[doc = "The sampling of energy detection has stopped"]
        pub EVENTS_EDSTOPPED: EVENTS_EDSTOPPED,
        #[doc = "Wireless medium in idle - clear to send"]
        pub EVENTS_CCAIDLE: EVENTS_CCAIDLE,
        #[doc = "Wireless medium busy - do not send"]
        pub EVENTS_CCABUSY: EVENTS_CCABUSY,
        #[doc = "The CCA has stopped"]
        pub EVENTS_CCASTOPPED: EVENTS_CCASTOPPED,
        #[doc = "Ble_LR CI field received, receive mode is changed from Ble_LR125Kbit to Ble_LR500Kbit."]
        pub EVENTS_RATEBOOST: EVENTS_RATEBOOST,
        #[doc = "RADIO has ramped up and is ready to be started TX path"]
        pub EVENTS_TXREADY: EVENTS_TXREADY,
        #[doc = "RADIO has ramped up and is ready to be started RX path"]
        pub EVENTS_RXREADY: EVENTS_RXREADY,
        #[doc = "MAC header match found"]
        pub EVENTS_MHRMATCH: EVENTS_MHRMATCH,
        #[doc = "Generated in Ble_LR125Kbit, Ble_LR500Kbit and Ieee802154_250Kbit modes when last bit is sent on air."]
        pub EVENTS_PHYEND: EVENTS_PHYEND,
        #[doc = "Shortcuts between local events and tasks"]
        pub SHORTS: SHORTS,
        #[doc = "Enable interrupt"]
        pub INTENSET: INTENSET,
        #[doc = "Disable interrupt"]
        pub INTENCLR: INTENCLR,
        #[doc = "CRC status"]
        pub CRCSTATUS: CRCSTATUS,
        #[doc = "Received address"]
        pub RXMATCH: RXMATCH,
        #[doc = "CRC field of previously received packet"]
        pub RXCRC: RXCRC,
        #[doc = "Device address match index"]
        pub DAI: DAI,
        #[doc = "Payload status"]
        pub PDUSTAT: PDUSTAT,
        #[doc = "Packet pointer"]
        pub PACKETPTR: PACKETPTR,
        #[doc = "Frequency"]
        pub FREQUENCY: FREQUENCY,
        #[doc = "Output power"]
        pub TXPOWER: TXPOWER,
        #[doc = "Data rate and modulation"]
        pub MODE: MODE,
        #[doc = "Packet configuration register 0"]
        pub PCNF0: PCNF0,
        #[doc = "Packet configuration register 1"]
        pub PCNF1: PCNF1,
        #[doc = "Base address 0"]
        pub BASE0: BASE0,
        #[doc = "Base address 1"]
        pub BASE1: BASE1,
        #[doc = "Prefixes bytes for logical addresses 0-3"]
        pub PREFIX0: PREFIX0,
        #[doc = "Prefixes bytes for logical addresses 4-7"]
        pub PREFIX1: PREFIX1,
        #[doc = "Transmit address select"]
        pub TXADDRESS: TXADDRESS,
        #[doc = "Receive address select"]
        pub RXADDRESSES: RXADDRESSES,
        #[doc = "CRC configuration"]
        pub CRCCNF: CRCCNF,
        #[doc = "CRC polynomial"]
        pub CRCPOLY: CRCPOLY,
        #[doc = "CRC initial value"]
        pub CRCINIT: CRCINIT,
        #[doc = "Interframe spacing in us"]
        pub TIFS: TIFS,
        #[doc = "RSSI sample"]
        pub RSSISAMPLE: RSSISAMPLE,
        #[doc = "Current radio state"]
        pub STATE: STATE,
        #[doc = "Data whitening initial value"]
        pub DATAWHITEIV: DATAWHITEIV,
        #[doc = "Bit counter compare"]
        pub BCC: BCC,
        #[doc = "Description collection: Device address base segment n"]
        pub DAB0: DAB0,
        #[doc = "Description collection: Device address base segment n"]
        pub DAB1: DAB1,
        #[doc = "Description collection: Device address base segment n"]
        pub DAB2: DAB2,
        #[doc = "Description collection: Device address base segment n"]
        pub DAB3: DAB3,
        #[doc = "Description collection: Device address base segment n"]
        pub DAB4: DAB4,
        #[doc = "Description collection: Device address base segment n"]
        pub DAB5: DAB5,
        #[doc = "Description collection: Device address base segment n"]
        pub DAB6: DAB6,
        #[doc = "Description collection: Device address base segment n"]
        pub DAB7: DAB7,
        #[doc = "Description collection: Device address prefix n"]
        pub DAP0: DAP0,
        #[doc = "Description collection: Device address prefix n"]
        pub DAP1: DAP1,
        #[doc = "Description collection: Device address prefix n"]
        pub DAP2: DAP2,
        #[doc = "Description collection: Device address prefix n"]
        pub DAP3: DAP3,
        #[doc = "Description collection: Device address prefix n"]
        pub DAP4: DAP4,
        #[doc = "Description collection: Device address prefix n"]
        pub DAP5: DAP5,
        #[doc = "Description collection: Device address prefix n"]
        pub DAP6: DAP6,
        #[doc = "Description collection: Device address prefix n"]
        pub DAP7: DAP7,
        #[doc = "Device address match configuration"]
        pub DACNF: DACNF,
        #[doc = "Search pattern configuration"]
        pub MHRMATCHCONF: MHRMATCHCONF,
        #[doc = "Pattern mask"]
        pub MHRMATCHMAS: MHRMATCHMAS,
        #[doc = "Radio mode configuration register 0"]
        pub MODECNF0: MODECNF0,
        #[doc = "IEEE 802.15.4 start of frame delimiter"]
        pub SFD: SFD,
        #[doc = "IEEE 802.15.4 energy detect loop count"]
        pub EDCNT: EDCNT,
        #[doc = "IEEE 802.15.4 energy detect level"]
        pub EDSAMPLE: EDSAMPLE,
        #[doc = "IEEE 802.15.4 clear channel assessment control"]
        pub CCACTRL: CCACTRL,
        #[doc = "Peripheral power control"]
        pub POWER: POWER,
    }
    unsafe impl Send for Registers {}
    impl Registers {
        #[doc = r" # Safety"]
        #[doc = r" Singleton"]
        unsafe fn new() -> Self {
            Self {
                TASKS_TXEN: TASKS_TXEN::new(),
                TASKS_RXEN: TASKS_RXEN::new(),
                TASKS_START: TASKS_START::new(),
                TASKS_STOP: TASKS_STOP::new(),
                TASKS_DISABLE: TASKS_DISABLE::new(),
                TASKS_RSSISTART: TASKS_RSSISTART::new(),
                TASKS_RSSISTOP: TASKS_RSSISTOP::new(),
                TASKS_BCSTART: TASKS_BCSTART::new(),
                TASKS_BCSTOP: TASKS_BCSTOP::new(),
                TASKS_EDSTART: TASKS_EDSTART::new(),
                TASKS_EDSTOP: TASKS_EDSTOP::new(),
                TASKS_CCASTART: TASKS_CCASTART::new(),
                TASKS_CCASTOP: TASKS_CCASTOP::new(),
                EVENTS_READY: EVENTS_READY::new(),
                EVENTS_ADDRESS: EVENTS_ADDRESS::new(),
                EVENTS_PAYLOAD: EVENTS_PAYLOAD::new(),
                EVENTS_END: EVENTS_END::new(),
                EVENTS_DISABLED: EVENTS_DISABLED::new(),
                EVENTS_DEVMATCH: EVENTS_DEVMATCH::new(),
                EVENTS_DEVMISS: EVENTS_DEVMISS::new(),
                EVENTS_RSSIEND: EVENTS_RSSIEND::new(),
                EVENTS_BCMATCH: EVENTS_BCMATCH::new(),
                EVENTS_CRCOK: EVENTS_CRCOK::new(),
                EVENTS_CRCERROR: EVENTS_CRCERROR::new(),
                EVENTS_FRAMESTART: EVENTS_FRAMESTART::new(),
                EVENTS_EDEND: EVENTS_EDEND::new(),
                EVENTS_EDSTOPPED: EVENTS_EDSTOPPED::new(),
                EVENTS_CCAIDLE: EVENTS_CCAIDLE::new(),
                EVENTS_CCABUSY: EVENTS_CCABUSY::new(),
                EVENTS_CCASTOPPED: EVENTS_CCASTOPPED::new(),
                EVENTS_RATEBOOST: EVENTS_RATEBOOST::new(),
                EVENTS_TXREADY: EVENTS_TXREADY::new(),
                EVENTS_RXREADY: EVENTS_RXREADY::new(),
                EVENTS_MHRMATCH: EVENTS_MHRMATCH::new(),
                EVENTS_PHYEND: EVENTS_PHYEND::new(),
                SHORTS: SHORTS::new(),
                INTENSET: INTENSET::new(),
                INTENCLR: INTENCLR::new(),
                CRCSTATUS: CRCSTATUS::new(),
                RXMATCH: RXMATCH::new(),
                RXCRC: RXCRC::new(),
                DAI: DAI::new(),
                PDUSTAT: PDUSTAT::new(),
                PACKETPTR: PACKETPTR::new(),
                FREQUENCY: FREQUENCY::new(),
                TXPOWER: TXPOWER::new(),
                MODE: MODE::new(),
                PCNF0: PCNF0::new(),
                PCNF1: PCNF1::new(),
                BASE0: BASE0::new(),
                BASE1: BASE1::new(),
                PREFIX0: PREFIX0::new(),
                PREFIX1: PREFIX1::new(),
                TXADDRESS: TXADDRESS::new(),
                RXADDRESSES: RXADDRESSES::new(),
                CRCCNF: CRCCNF::new(),
                CRCPOLY: CRCPOLY::new(),
                CRCINIT: CRCINIT::new(),
                TIFS: TIFS::new(),
                RSSISAMPLE: RSSISAMPLE::new(),
                STATE: STATE::new(),
                DATAWHITEIV: DATAWHITEIV::new(),
                BCC: BCC::new(),
                DAB0: DAB0::new(),
                DAB1: DAB1::new(),
                DAB2: DAB2::new(),
                DAB3: DAB3::new(),
                DAB4: DAB4::new(),
                DAB5: DAB5::new(),
                DAB6: DAB6::new(),
                DAB7: DAB7::new(),
                DAP0: DAP0::new(),
                DAP1: DAP1::new(),
                DAP2: DAP2::new(),
                DAP3: DAP3::new(),
                DAP4: DAP4::new(),
                DAP5: DAP5::new(),
                DAP6: DAP6::new(),
                DAP7: DAP7::new(),
                DACNF: DACNF::new(),
                MHRMATCHCONF: MHRMATCHCONF::new(),
                MHRMATCHMAS: MHRMATCHMAS::new(),
                MODECNF0: MODECNF0::new(),
                SFD: SFD::new(),
                EDCNT: EDCNT::new(),
                EDSAMPLE: EDSAMPLE::new(),
                CCACTRL: CCACTRL::new(),
                POWER: POWER::new(),
            }
        }
        fn taken() -> &'static AtomicBool {
            static TAKEN: AtomicBool = AtomicBool::new(false);
            &TAKEN
        }
        #[doc = r" Grants temporary access to the peripheral, without checking if it has already been"]
        #[doc = r" taken"]
        #[inline(always)]
        pub fn borrow_unchecked<T>(f: impl FnOnce(&Self) -> T) -> T {
            f(unsafe { &Self::new() })
        }
        #[doc = r" Seals the peripheral making it impossible to `take` it"]
        pub fn seal() {
            Self::taken().store(true, Ordering::Relaxed)
        }
        #[doc = r" Takes ownership of the peripheral"]
        #[doc = r""]
        #[doc = r" This constructor returns the `Some` variant only once"]
        pub fn take() -> Option<Self> {
            let taken = Self::taken();
            if taken
                .compare_exchange(false, true, Ordering::Relaxed, Ordering::Relaxed)
                .is_ok()
            {
                Some(unsafe { Self::new() })
            } else {
                None
            }
        }
    }
}
#[allow(non_camel_case_types)]
#[cfg(feature = "SPIM0")]
#[doc = "Serial Peripheral Interface Master with EasyDMA 0"]
pub type SPIM0 = spim0::Registers;
#[cfg(feature = "SPIM0")]
#[doc = "Serial Peripheral Interface Master with EasyDMA 0"]
pub mod spim0 {
    #[allow(non_camel_case_types)]
    #[doc = "Start SPI transaction"]
    pub type TASKS_START = tasks_start::Register;
    #[doc = "Start SPI transaction"]
    pub mod tasks_start {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x10) as *mut _
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 0) Start SPI transaction"]
            #[allow(non_snake_case)]
            pub fn TASKS_START(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Stop SPI transaction"]
    pub type TASKS_STOP = tasks_stop::Register;
    #[doc = "Stop SPI transaction"]
    pub mod tasks_stop {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x14) as *mut _
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 0) Stop SPI transaction"]
            #[allow(non_snake_case)]
            pub fn TASKS_STOP(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Suspend SPI transaction"]
    pub type TASKS_SUSPEND = tasks_suspend::Register;
    #[doc = "Suspend SPI transaction"]
    pub mod tasks_suspend {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x1c) as *mut _
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 0) Suspend SPI transaction"]
            #[allow(non_snake_case)]
            pub fn TASKS_SUSPEND(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Resume SPI transaction"]
    pub type TASKS_RESUME = tasks_resume::Register;
    #[doc = "Resume SPI transaction"]
    pub mod tasks_resume {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x20) as *mut _
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 0) Resume SPI transaction"]
            #[allow(non_snake_case)]
            pub fn TASKS_RESUME(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "SPI transaction has stopped"]
    pub type EVENTS_STOPPED = events_stopped::Register;
    #[doc = "SPI transaction has stopped"]
    pub mod events_stopped {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0104) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bit 0) SPI transaction has stopped"]
            pub fn EVENTS_STOPPED(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u8 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "EVENTS_STOPPED {{ EVENTS_STOPPED: {0} }}@6680024331524930465"]
                #[link_section = ".binfmt.EVENTS_STOPPED {{ EVENTS_STOPPED: {0} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 0) SPI transaction has stopped"]
            #[allow(non_snake_case)]
            pub fn EVENTS_STOPPED(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "End of RXD buffer reached"]
    pub type EVENTS_ENDRX = events_endrx::Register;
    #[doc = "End of RXD buffer reached"]
    pub mod events_endrx {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0110) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bit 0) End of RXD buffer reached"]
            pub fn EVENTS_ENDRX(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u8 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "EVENTS_ENDRX {{ EVENTS_ENDRX: {0} }}@838784672322829877"]
                #[link_section = ".binfmt.EVENTS_ENDRX {{ EVENTS_ENDRX: {0} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 0) End of RXD buffer reached"]
            #[allow(non_snake_case)]
            pub fn EVENTS_ENDRX(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "End of RXD buffer and TXD buffer reached"]
    pub type EVENTS_END = events_end::Register;
    #[doc = "End of RXD buffer and TXD buffer reached"]
    pub mod events_end {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0118) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bit 0) End of RXD buffer and TXD buffer reached"]
            pub fn EVENTS_END(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u8 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "EVENTS_END {{ EVENTS_END: {0} }}@6820728649442188177"]
                #[link_section = ".binfmt.EVENTS_END {{ EVENTS_END: {0} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 0) End of RXD buffer and TXD buffer reached"]
            #[allow(non_snake_case)]
            pub fn EVENTS_END(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "End of TXD buffer reached"]
    pub type EVENTS_ENDTX = events_endtx::Register;
    #[doc = "End of TXD buffer reached"]
    pub mod events_endtx {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0120) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bit 0) End of TXD buffer reached"]
            pub fn EVENTS_ENDTX(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u8 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "EVENTS_ENDTX {{ EVENTS_ENDTX: {0} }}@12637918534067072231"]
                #[link_section = ".binfmt.EVENTS_ENDTX {{ EVENTS_ENDTX: {0} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 0) End of TXD buffer reached"]
            #[allow(non_snake_case)]
            pub fn EVENTS_ENDTX(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Transaction started"]
    pub type EVENTS_STARTED = events_started::Register;
    #[doc = "Transaction started"]
    pub mod events_started {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x014c) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bit 0) Transaction started"]
            pub fn EVENTS_STARTED(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u8 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "EVENTS_STARTED {{ EVENTS_STARTED: {0} }}@13014770157026748892"]
                #[link_section = ".binfmt.EVENTS_STARTED {{ EVENTS_STARTED: {0} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 0) Transaction started"]
            #[allow(non_snake_case)]
            pub fn EVENTS_STARTED(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Shortcuts between local events and tasks"]
    pub type SHORTS = shorts::Register;
    #[doc = "Shortcuts between local events and tasks"]
    pub mod shorts {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0200) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bit 17) Shortcut between event END and task START"]
            pub fn END_START(self) -> u8 {
                const OFFSET: u8 = 17;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u32 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "SHORTS {{ END_START: {17} }}@10584988154857537888"]
                #[link_section = ".binfmt.SHORTS {{ END_START: {17} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 17) Shortcut between event END and task START"]
            #[allow(non_snake_case)]
            pub fn END_START(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 17;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Enable interrupt"]
    pub type INTENSET = intenset::Register;
    #[doc = "Enable interrupt"]
    pub mod intenset {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0304) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub unsafe fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub unsafe fn zero(&self) {
                {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub unsafe fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bit 1) Write '1' to enable interrupt for event STOPPED"]
            pub fn STOPPED(self) -> u8 {
                const OFFSET: u8 = 1;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 4) Write '1' to enable interrupt for event ENDRX"]
            pub fn ENDRX(self) -> u8 {
                const OFFSET: u8 = 4;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 6) Write '1' to enable interrupt for event END"]
            pub fn END(self) -> u8 {
                const OFFSET: u8 = 6;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 8) Write '1' to enable interrupt for event ENDTX"]
            pub fn ENDTX(self) -> u8 {
                const OFFSET: u8 = 8;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 19) Write '1' to enable interrupt for event STARTED"]
            pub fn STARTED(self) -> u8 {
                const OFFSET: u8 = 19;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u32 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "INTENSET {{ STARTED: {19}, ENDTX: {8}, END: {6}, ENDRX: {4}, STOPPED: {1} }}@1969275483075319020"]
                #[link_section = ".binfmt.INTENSET {{ STARTED: {19}, ENDTX: {8}, END: {6}, ENDRX: {4}, STOPPED: {1} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 1) Write '1' to enable interrupt for event STOPPED"]
            #[allow(non_snake_case)]
            pub fn STOPPED(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 1;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 4) Write '1' to enable interrupt for event ENDRX"]
            #[allow(non_snake_case)]
            pub fn ENDRX(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 4;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 6) Write '1' to enable interrupt for event END"]
            #[allow(non_snake_case)]
            pub fn END(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 6;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 8) Write '1' to enable interrupt for event ENDTX"]
            #[allow(non_snake_case)]
            pub fn ENDTX(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 8;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 19) Write '1' to enable interrupt for event STARTED"]
            #[allow(non_snake_case)]
            pub fn STARTED(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 19;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Disable interrupt"]
    pub type INTENCLR = intenclr::Register;
    #[doc = "Disable interrupt"]
    pub mod intenclr {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0308) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bit 1) Write '1' to disable interrupt for event STOPPED"]
            pub fn STOPPED(self) -> u8 {
                const OFFSET: u8 = 1;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 4) Write '1' to disable interrupt for event ENDRX"]
            pub fn ENDRX(self) -> u8 {
                const OFFSET: u8 = 4;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 6) Write '1' to disable interrupt for event END"]
            pub fn END(self) -> u8 {
                const OFFSET: u8 = 6;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 8) Write '1' to disable interrupt for event ENDTX"]
            pub fn ENDTX(self) -> u8 {
                const OFFSET: u8 = 8;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 19) Write '1' to disable interrupt for event STARTED"]
            pub fn STARTED(self) -> u8 {
                const OFFSET: u8 = 19;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u32 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "INTENCLR {{ STARTED: {19}, ENDTX: {8}, END: {6}, ENDRX: {4}, STOPPED: {1} }}@9970648896423529685"]
                #[link_section = ".binfmt.INTENCLR {{ STARTED: {19}, ENDTX: {8}, END: {6}, ENDRX: {4}, STOPPED: {1} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 1) Write '1' to disable interrupt for event STOPPED"]
            #[allow(non_snake_case)]
            pub fn STOPPED(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 1;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 4) Write '1' to disable interrupt for event ENDRX"]
            #[allow(non_snake_case)]
            pub fn ENDRX(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 4;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 6) Write '1' to disable interrupt for event END"]
            #[allow(non_snake_case)]
            pub fn END(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 6;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 8) Write '1' to disable interrupt for event ENDTX"]
            #[allow(non_snake_case)]
            pub fn ENDTX(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 8;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 19) Write '1' to disable interrupt for event STARTED"]
            #[allow(non_snake_case)]
            pub fn STARTED(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 19;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Stall status for EasyDMA RAM accesses. The fields in this register is set to STALL by hardware whenever a stall occurres and can be cleared (set to NOSTALL) by the CPU."]
    pub type STALLSTAT = stallstat::Register;
    #[doc = "Stall status for EasyDMA RAM accesses. The fields in this register is set to STALL by hardware whenever a stall occurres and can be cleared (set to NOSTALL) by the CPU."]
    pub mod stallstat {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0400) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bit 0) Stall status for EasyDMA RAM reads"]
            pub fn TX(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 1) Stall status for EasyDMA RAM writes"]
            pub fn RX(self) -> u8 {
                const OFFSET: u8 = 1;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u8 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "STALLSTAT {{ RX: {1}, TX: {0} }}@14579923111401458059"]
                #[link_section = ".binfmt.STALLSTAT {{ RX: {1}, TX: {0} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 0) Stall status for EasyDMA RAM reads"]
            #[allow(non_snake_case)]
            pub fn TX(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 1) Stall status for EasyDMA RAM writes"]
            #[allow(non_snake_case)]
            pub fn RX(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 1;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Enable SPIM"]
    pub type ENABLE = enable::Register;
    #[doc = "Enable SPIM"]
    pub mod enable {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0500) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bits 0..=4) Enable or disable SPIM"]
            pub fn ENABLE(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x0f;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u8 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "ENABLE {{ ENABLE: {0:4} }}@4398977334700205801"]
                #[link_section = ".binfmt.ENABLE {{ ENABLE: {0:4} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bits 0..=4) Enable or disable SPIM"]
            #[allow(non_snake_case)]
            pub fn ENABLE(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x0f;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Pin select for SCK"]
    pub type PSEL_SCK = psel_sck::Register;
    #[doc = "Pin select for SCK"]
    pub mod psel_sck {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0508) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bits 0..=5) Pin number"]
            pub fn PIN(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x1f;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 5) Port number"]
            pub fn PORT(self) -> u8 {
                const OFFSET: u8 = 5;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 31) Connection"]
            pub fn CONNECT(self) -> u8 {
                const OFFSET: u8 = 31;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u32 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "PSEL_SCK {{ CONNECT: {31}, PORT: {5}, PIN: {0:5} }}@9971118167748526959"]
                #[link_section = ".binfmt.PSEL_SCK {{ CONNECT: {31}, PORT: {5}, PIN: {0:5} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bits 0..=5) Pin number"]
            #[allow(non_snake_case)]
            pub fn PIN(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x1f;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 5) Port number"]
            #[allow(non_snake_case)]
            pub fn PORT(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 5;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 31) Connection"]
            #[allow(non_snake_case)]
            pub fn CONNECT(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 31;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Pin select for MOSI signal"]
    pub type PSEL_MOSI = psel_mosi::Register;
    #[doc = "Pin select for MOSI signal"]
    pub mod psel_mosi {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x050c) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bits 0..=5) Pin number"]
            pub fn PIN(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x1f;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 5) Port number"]
            pub fn PORT(self) -> u8 {
                const OFFSET: u8 = 5;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 31) Connection"]
            pub fn CONNECT(self) -> u8 {
                const OFFSET: u8 = 31;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u32 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "PSEL_MOSI {{ CONNECT: {31}, PORT: {5}, PIN: {0:5} }}@17553413702495879983"]
                #[link_section = ".binfmt.PSEL_MOSI {{ CONNECT: {31}, PORT: {5}, PIN: {0:5} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bits 0..=5) Pin number"]
            #[allow(non_snake_case)]
            pub fn PIN(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x1f;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 5) Port number"]
            #[allow(non_snake_case)]
            pub fn PORT(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 5;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 31) Connection"]
            #[allow(non_snake_case)]
            pub fn CONNECT(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 31;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Pin select for MISO signal"]
    pub type PSEL_MISO = psel_miso::Register;
    #[doc = "Pin select for MISO signal"]
    pub mod psel_miso {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0510) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bits 0..=5) Pin number"]
            pub fn PIN(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x1f;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 5) Port number"]
            pub fn PORT(self) -> u8 {
                const OFFSET: u8 = 5;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 31) Connection"]
            pub fn CONNECT(self) -> u8 {
                const OFFSET: u8 = 31;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u32 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "PSEL_MISO {{ CONNECT: {31}, PORT: {5}, PIN: {0:5} }}@5584041410361386725"]
                #[link_section = ".binfmt.PSEL_MISO {{ CONNECT: {31}, PORT: {5}, PIN: {0:5} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bits 0..=5) Pin number"]
            #[allow(non_snake_case)]
            pub fn PIN(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x1f;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 5) Port number"]
            #[allow(non_snake_case)]
            pub fn PORT(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 5;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 31) Connection"]
            #[allow(non_snake_case)]
            pub fn CONNECT(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 31;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Pin select for CSN"]
    pub type PSEL_CSN = psel_csn::Register;
    #[doc = "Pin select for CSN"]
    pub mod psel_csn {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0514) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bits 0..=5) Pin number"]
            pub fn PIN(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x1f;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 5) Port number"]
            pub fn PORT(self) -> u8 {
                const OFFSET: u8 = 5;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 31) Connection"]
            pub fn CONNECT(self) -> u8 {
                const OFFSET: u8 = 31;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u32 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "PSEL_CSN {{ CONNECT: {31}, PORT: {5}, PIN: {0:5} }}@3325164269235377704"]
                #[link_section = ".binfmt.PSEL_CSN {{ CONNECT: {31}, PORT: {5}, PIN: {0:5} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bits 0..=5) Pin number"]
            #[allow(non_snake_case)]
            pub fn PIN(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x1f;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 5) Port number"]
            #[allow(non_snake_case)]
            pub fn PORT(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 5;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 31) Connection"]
            #[allow(non_snake_case)]
            pub fn CONNECT(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 31;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "SPI frequency. Accuracy depends on the HFCLK source selected."]
    pub type FREQUENCY = frequency::Register;
    #[doc = "SPI frequency. Accuracy depends on the HFCLK source selected."]
    pub mod frequency {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0524) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bits 0..=32) SPI master data rate"]
            pub fn FREQUENCY(self) -> u32 {
                const OFFSET: u8 = 0;
                const MASK: u32 = 0xffff_ffff;
                ((self.inner >> OFFSET) as u32) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u32 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "FREQUENCY {{ FREQUENCY: {0:32} }}@2302743398529076774"]
                #[link_section = ".binfmt.FREQUENCY {{ FREQUENCY: {0:32} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bits 0..=32) SPI master data rate"]
            #[allow(non_snake_case)]
            pub fn FREQUENCY(&mut self, val: u32) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u32 = 0xffff_ffff;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Data pointer"]
    pub type RXD_PTR = rxd_ptr::Register;
    #[doc = "Data pointer"]
    pub mod rxd_ptr {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0534) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bits 0..=32) Data pointer"]
            pub fn PTR(self) -> u32 {
                const OFFSET: u8 = 0;
                const MASK: u32 = 0xffff_ffff;
                ((self.inner >> OFFSET) as u32) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u32 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "RXD_PTR {{ PTR: {0:32} }}@15054959831831412971"]
                #[link_section = ".binfmt.RXD_PTR {{ PTR: {0:32} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bits 0..=32) Data pointer"]
            #[allow(non_snake_case)]
            pub fn PTR(&mut self, val: u32) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u32 = 0xffff_ffff;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Maximum number of bytes in receive buffer"]
    pub type RXD_MAXCNT = rxd_maxcnt::Register;
    #[doc = "Maximum number of bytes in receive buffer"]
    pub mod rxd_maxcnt {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0538) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bits 0..=16) Maximum number of bytes in receive buffer"]
            pub fn MAXCNT(self) -> u16 {
                const OFFSET: u8 = 0;
                const MASK: u16 = 0xffff;
                ((self.inner >> OFFSET) as u16) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u16 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "RXD_MAXCNT {{ MAXCNT: {0:16} }}@5926379407203963062"]
                #[link_section = ".binfmt.RXD_MAXCNT {{ MAXCNT: {0:16} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bits 0..=16) Maximum number of bytes in receive buffer"]
            #[allow(non_snake_case)]
            pub fn MAXCNT(&mut self, val: u16) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u16 = 0xffff;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Number of bytes transferred in the last transaction"]
    pub type RXD_AMOUNT = rxd_amount::Register;
    #[doc = "Number of bytes transferred in the last transaction"]
    pub mod rxd_amount {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *const u32 {
                (super::BASE_ADDRESS + 0x053c) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bits 0..=16) Number of bytes transferred in the last transaction"]
            pub fn AMOUNT(self) -> u16 {
                const OFFSET: u8 = 0;
                const MASK: u16 = 0xffff;
                ((self.inner >> OFFSET) as u16) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u16 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "RXD_AMOUNT {{ AMOUNT: {0:16} }}@9919404451956521311"]
                #[link_section = ".binfmt.RXD_AMOUNT {{ AMOUNT: {0:16} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "EasyDMA list type"]
    pub type RXD_LIST = rxd_list::Register;
    #[doc = "EasyDMA list type"]
    pub mod rxd_list {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0540) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bits 0..=2) List type"]
            pub fn LIST(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x03;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u8 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "RXD_LIST {{ LIST: {0:2} }}@7833585898204327144"]
                #[link_section = ".binfmt.RXD_LIST {{ LIST: {0:2} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bits 0..=2) List type"]
            #[allow(non_snake_case)]
            pub fn LIST(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x03;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Data pointer"]
    pub type TXD_PTR = txd_ptr::Register;
    #[doc = "Data pointer"]
    pub mod txd_ptr {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0544) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bits 0..=32) Data pointer"]
            pub fn PTR(self) -> u32 {
                const OFFSET: u8 = 0;
                const MASK: u32 = 0xffff_ffff;
                ((self.inner >> OFFSET) as u32) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u32 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "TXD_PTR {{ PTR: {0:32} }}@14580301414566654230"]
                #[link_section = ".binfmt.TXD_PTR {{ PTR: {0:32} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bits 0..=32) Data pointer"]
            #[allow(non_snake_case)]
            pub fn PTR(&mut self, val: u32) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u32 = 0xffff_ffff;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Number of bytes in transmit buffer"]
    pub type TXD_MAXCNT = txd_maxcnt::Register;
    #[doc = "Number of bytes in transmit buffer"]
    pub mod txd_maxcnt {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0548) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bits 0..=16) Maximum number of bytes in transmit buffer"]
            pub fn MAXCNT(self) -> u16 {
                const OFFSET: u8 = 0;
                const MASK: u16 = 0xffff;
                ((self.inner >> OFFSET) as u16) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u16 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "TXD_MAXCNT {{ MAXCNT: {0:16} }}@963150633027897965"]
                #[link_section = ".binfmt.TXD_MAXCNT {{ MAXCNT: {0:16} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bits 0..=16) Maximum number of bytes in transmit buffer"]
            #[allow(non_snake_case)]
            pub fn MAXCNT(&mut self, val: u16) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u16 = 0xffff;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Number of bytes transferred in the last transaction"]
    pub type TXD_AMOUNT = txd_amount::Register;
    #[doc = "Number of bytes transferred in the last transaction"]
    pub mod txd_amount {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *const u32 {
                (super::BASE_ADDRESS + 0x054c) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bits 0..=16) Number of bytes transferred in the last transaction"]
            pub fn AMOUNT(self) -> u16 {
                const OFFSET: u8 = 0;
                const MASK: u16 = 0xffff;
                ((self.inner >> OFFSET) as u16) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u16 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "TXD_AMOUNT {{ AMOUNT: {0:16} }}@9821998050212141721"]
                #[link_section = ".binfmt.TXD_AMOUNT {{ AMOUNT: {0:16} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "EasyDMA list type"]
    pub type TXD_LIST = txd_list::Register;
    #[doc = "EasyDMA list type"]
    pub mod txd_list {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0550) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bits 0..=2) List type"]
            pub fn LIST(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x03;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u8 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "TXD_LIST {{ LIST: {0:2} }}@2977036557188156713"]
                #[link_section = ".binfmt.TXD_LIST {{ LIST: {0:2} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bits 0..=2) List type"]
            #[allow(non_snake_case)]
            pub fn LIST(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x03;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Configuration register"]
    pub type CONFIG = config::Register;
    #[doc = "Configuration register"]
    pub mod config {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0554) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bit 0) Bit order"]
            pub fn ORDER(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 1) Serial clock (SCK) phase"]
            pub fn CPHA(self) -> u8 {
                const OFFSET: u8 = 1;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 2) Serial clock (SCK) polarity"]
            pub fn CPOL(self) -> u8 {
                const OFFSET: u8 = 2;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u8 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "CONFIG {{ CPOL: {2}, CPHA: {1}, ORDER: {0} }}@16249769934652486872"]
                #[link_section = ".binfmt.CONFIG {{ CPOL: {2}, CPHA: {1}, ORDER: {0} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 0) Bit order"]
            #[allow(non_snake_case)]
            pub fn ORDER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 1) Serial clock (SCK) phase"]
            #[allow(non_snake_case)]
            pub fn CPHA(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 1;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 2) Serial clock (SCK) polarity"]
            #[allow(non_snake_case)]
            pub fn CPOL(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 2;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Sample delay for input serial data on MISO"]
    pub type IFTIMING_RXDELAY = iftiming_rxdelay::Register;
    #[doc = "Sample delay for input serial data on MISO"]
    pub mod iftiming_rxdelay {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0560) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bits 0..=3) Sample delay for input serial data on MISO. The value specifies the number of 64 MHz clock cycles (15.625 ns) delay from the the sampling edge of SCK (leading edge for CONFIG.CPHA = 0, trailing edge for CONFIG.CPHA = 1) until the input serial data is sampled. As en example, if RXDELAY = 0 and CONFIG.CPHA = 0, the input serial data is sampled on the rising edge of SCK."]
            pub fn RXDELAY(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x07;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u8 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "IFTIMING_RXDELAY {{ RXDELAY: {0:3} }}@17027075766497983157"]
                #[link_section = ".binfmt.IFTIMING_RXDELAY {{ RXDELAY: {0:3} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bits 0..=3) Sample delay for input serial data on MISO. The value specifies the number of 64 MHz clock cycles (15.625 ns) delay from the the sampling edge of SCK (leading edge for CONFIG.CPHA = 0, trailing edge for CONFIG.CPHA = 1) until the input serial data is sampled. As en example, if RXDELAY = 0 and CONFIG.CPHA = 0, the input serial data is sampled on the rising edge of SCK."]
            #[allow(non_snake_case)]
            pub fn RXDELAY(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x07;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Minimum duration between edge of CSN and edge of SCK and minimum duration CSN must stay high between transactions"]
    pub type IFTIMING_CSNDUR = iftiming_csndur::Register;
    #[doc = "Minimum duration between edge of CSN and edge of SCK and minimum duration CSN must stay high between transactions"]
    pub mod iftiming_csndur {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0564) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bits 0..=8) Minimum duration between edge of CSN and edge of SCK and minimum duration CSN must stay high between transactions. The value is specified in number of 64 MHz clock cycles (15.625 ns)."]
            pub fn CSNDUR(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0xff;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u8 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "IFTIMING_CSNDUR {{ CSNDUR: {0:8} }}@4770282456290645015"]
                #[link_section = ".binfmt.IFTIMING_CSNDUR {{ CSNDUR: {0:8} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bits 0..=8) Minimum duration between edge of CSN and edge of SCK and minimum duration CSN must stay high between transactions. The value is specified in number of 64 MHz clock cycles (15.625 ns)."]
            #[allow(non_snake_case)]
            pub fn CSNDUR(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0xff;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Polarity of CSN output"]
    pub type CSNPOL = csnpol::Register;
    #[doc = "Polarity of CSN output"]
    pub mod csnpol {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0568) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bit 0) Polarity of CSN output"]
            pub fn CSNPOL(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u8 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "CSNPOL {{ CSNPOL: {0} }}@13550182582008740863"]
                #[link_section = ".binfmt.CSNPOL {{ CSNPOL: {0} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 0) Polarity of CSN output"]
            #[allow(non_snake_case)]
            pub fn CSNPOL(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Pin select for DCX signal"]
    pub type PSELDCX = pseldcx::Register;
    #[doc = "Pin select for DCX signal"]
    pub mod pseldcx {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x056c) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bits 0..=5) Pin number"]
            pub fn PIN(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x1f;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 5) Port number"]
            pub fn PORT(self) -> u8 {
                const OFFSET: u8 = 5;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 31) Connection"]
            pub fn CONNECT(self) -> u8 {
                const OFFSET: u8 = 31;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u32 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "PSELDCX {{ CONNECT: {31}, PORT: {5}, PIN: {0:5} }}@775169260346395454"]
                #[link_section = ".binfmt.PSELDCX {{ CONNECT: {31}, PORT: {5}, PIN: {0:5} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bits 0..=5) Pin number"]
            #[allow(non_snake_case)]
            pub fn PIN(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x1f;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 5) Port number"]
            #[allow(non_snake_case)]
            pub fn PORT(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 5;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 31) Connection"]
            #[allow(non_snake_case)]
            pub fn CONNECT(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 31;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "DCX configuration"]
    pub type DCXCNT = dcxcnt::Register;
    #[doc = "DCX configuration"]
    pub mod dcxcnt {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0570) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bits 0..=4) This register specifies the number of command bytes preceding the data bytes. The PSEL.DCX line will be low during transmission of command bytes and high during transmission of data bytes. Value 0xF indicates that all bytes are command bytes."]
            pub fn DCXCNT(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x0f;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u8 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "DCXCNT {{ DCXCNT: {0:4} }}@6650115162898135537"]
                #[link_section = ".binfmt.DCXCNT {{ DCXCNT: {0:4} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bits 0..=4) This register specifies the number of command bytes preceding the data bytes. The PSEL.DCX line will be low during transmission of command bytes and high during transmission of data bytes. Value 0xF indicates that all bytes are command bytes."]
            #[allow(non_snake_case)]
            pub fn DCXCNT(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x0f;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Byte transmitted after TXD.MAXCNT bytes have been transmitted in the case when RXD.MAXCNT is greater than TXD.MAXCNT"]
    pub type ORC = orc::Register;
    #[doc = "Byte transmitted after TXD.MAXCNT bytes have been transmitted in the case when RXD.MAXCNT is greater than TXD.MAXCNT"]
    pub mod orc {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x05c0) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bits 0..=8) Byte transmitted after TXD.MAXCNT bytes have been transmitted in the case when RXD.MAXCNT is greater than TXD.MAXCNT."]
            pub fn ORC(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0xff;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u8 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "ORC {{ ORC: {0:8} }}@8422878319053251085"]
                #[link_section = ".binfmt.ORC {{ ORC: {0:8} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bits 0..=8) Byte transmitted after TXD.MAXCNT bytes have been transmitted in the case when RXD.MAXCNT is greater than TXD.MAXCNT."]
            #[allow(non_snake_case)]
            pub fn ORC(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0xff;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    use core::sync::atomic::{AtomicBool, Ordering};
    const BASE_ADDRESS: usize = 0x4000_3000;
    #[allow(non_snake_case)]
    #[doc = "Singleton handle to the SPIM0 registers"]
    pub struct Registers {
        #[doc = "Start SPI transaction"]
        pub TASKS_START: TASKS_START,
        #[doc = "Stop SPI transaction"]
        pub TASKS_STOP: TASKS_STOP,
        #[doc = "Suspend SPI transaction"]
        pub TASKS_SUSPEND: TASKS_SUSPEND,
        #[doc = "Resume SPI transaction"]
        pub TASKS_RESUME: TASKS_RESUME,
        #[doc = "SPI transaction has stopped"]
        pub EVENTS_STOPPED: EVENTS_STOPPED,
        #[doc = "End of RXD buffer reached"]
        pub EVENTS_ENDRX: EVENTS_ENDRX,
        #[doc = "End of RXD buffer and TXD buffer reached"]
        pub EVENTS_END: EVENTS_END,
        #[doc = "End of TXD buffer reached"]
        pub EVENTS_ENDTX: EVENTS_ENDTX,
        #[doc = "Transaction started"]
        pub EVENTS_STARTED: EVENTS_STARTED,
        #[doc = "Shortcuts between local events and tasks"]
        pub SHORTS: SHORTS,
        #[doc = "Enable interrupt"]
        pub INTENSET: INTENSET,
        #[doc = "Disable interrupt"]
        pub INTENCLR: INTENCLR,
        #[doc = "Stall status for EasyDMA RAM accesses. The fields in this register is set to STALL by hardware whenever a stall occurres and can be cleared (set to NOSTALL) by the CPU."]
        pub STALLSTAT: STALLSTAT,
        #[doc = "Enable SPIM"]
        pub ENABLE: ENABLE,
        #[doc = "Pin select for SCK"]
        pub PSEL_SCK: PSEL_SCK,
        #[doc = "Pin select for MOSI signal"]
        pub PSEL_MOSI: PSEL_MOSI,
        #[doc = "Pin select for MISO signal"]
        pub PSEL_MISO: PSEL_MISO,
        #[doc = "Pin select for CSN"]
        pub PSEL_CSN: PSEL_CSN,
        #[doc = "SPI frequency. Accuracy depends on the HFCLK source selected."]
        pub FREQUENCY: FREQUENCY,
        #[doc = "Data pointer"]
        pub RXD_PTR: RXD_PTR,
        #[doc = "Maximum number of bytes in receive buffer"]
        pub RXD_MAXCNT: RXD_MAXCNT,
        #[doc = "Number of bytes transferred in the last transaction"]
        pub RXD_AMOUNT: RXD_AMOUNT,
        #[doc = "EasyDMA list type"]
        pub RXD_LIST: RXD_LIST,
        #[doc = "Data pointer"]
        pub TXD_PTR: TXD_PTR,
        #[doc = "Number of bytes in transmit buffer"]
        pub TXD_MAXCNT: TXD_MAXCNT,
        #[doc = "Number of bytes transferred in the last transaction"]
        pub TXD_AMOUNT: TXD_AMOUNT,
        #[doc = "EasyDMA list type"]
        pub TXD_LIST: TXD_LIST,
        #[doc = "Configuration register"]
        pub CONFIG: CONFIG,
        #[doc = "Sample delay for input serial data on MISO"]
        pub IFTIMING_RXDELAY: IFTIMING_RXDELAY,
        #[doc = "Minimum duration between edge of CSN and edge of SCK and minimum duration CSN must stay high between transactions"]
        pub IFTIMING_CSNDUR: IFTIMING_CSNDUR,
        #[doc = "Polarity of CSN output"]
        pub CSNPOL: CSNPOL,
        #[doc = "Pin select for DCX signal"]
        pub PSELDCX: PSELDCX,
        #[doc = "DCX configuration"]
        pub DCXCNT: DCXCNT,
        #[doc = "Byte transmitted after TXD.MAXCNT bytes have been transmitted in the case when RXD.MAXCNT is greater than TXD.MAXCNT"]
        pub ORC: ORC,
    }
    unsafe impl Send for Registers {}
    impl Registers {
        #[doc = r" # Safety"]
        #[doc = r" Singleton"]
        unsafe fn new() -> Self {
            Self {
                TASKS_START: TASKS_START::new(),
                TASKS_STOP: TASKS_STOP::new(),
                TASKS_SUSPEND: TASKS_SUSPEND::new(),
                TASKS_RESUME: TASKS_RESUME::new(),
                EVENTS_STOPPED: EVENTS_STOPPED::new(),
                EVENTS_ENDRX: EVENTS_ENDRX::new(),
                EVENTS_END: EVENTS_END::new(),
                EVENTS_ENDTX: EVENTS_ENDTX::new(),
                EVENTS_STARTED: EVENTS_STARTED::new(),
                SHORTS: SHORTS::new(),
                INTENSET: INTENSET::new(),
                INTENCLR: INTENCLR::new(),
                STALLSTAT: STALLSTAT::new(),
                ENABLE: ENABLE::new(),
                PSEL_SCK: PSEL_SCK::new(),
                PSEL_MOSI: PSEL_MOSI::new(),
                PSEL_MISO: PSEL_MISO::new(),
                PSEL_CSN: PSEL_CSN::new(),
                FREQUENCY: FREQUENCY::new(),
                RXD_PTR: RXD_PTR::new(),
                RXD_MAXCNT: RXD_MAXCNT::new(),
                RXD_AMOUNT: RXD_AMOUNT::new(),
                RXD_LIST: RXD_LIST::new(),
                TXD_PTR: TXD_PTR::new(),
                TXD_MAXCNT: TXD_MAXCNT::new(),
                TXD_AMOUNT: TXD_AMOUNT::new(),
                TXD_LIST: TXD_LIST::new(),
                CONFIG: CONFIG::new(),
                IFTIMING_RXDELAY: IFTIMING_RXDELAY::new(),
                IFTIMING_CSNDUR: IFTIMING_CSNDUR::new(),
                CSNPOL: CSNPOL::new(),
                PSELDCX: PSELDCX::new(),
                DCXCNT: DCXCNT::new(),
                ORC: ORC::new(),
            }
        }
        fn taken() -> &'static AtomicBool {
            static TAKEN: AtomicBool = AtomicBool::new(false);
            &TAKEN
        }
        #[doc = r" Grants temporary access to the peripheral, without checking if it has already been"]
        #[doc = r" taken"]
        #[inline(always)]
        pub fn borrow_unchecked<T>(f: impl FnOnce(&Self) -> T) -> T {
            f(unsafe { &Self::new() })
        }
        #[doc = r" Seals the peripheral making it impossible to `take` it"]
        pub fn seal() {
            Self::taken().store(true, Ordering::Relaxed)
        }
        #[doc = r" Takes ownership of the peripheral"]
        #[doc = r""]
        #[doc = r" This constructor returns the `Some` variant only once"]
        pub fn take() -> Option<Self> {
            let taken = Self::taken();
            if taken
                .compare_exchange(false, true, Ordering::Relaxed, Ordering::Relaxed)
                .is_ok()
            {
                Some(unsafe { Self::new() })
            } else {
                None
            }
        }
    }
}
#[allow(non_camel_case_types)]
#[cfg(feature = "TWIM0")]
#[doc = "I2C compatible Two-Wire Master Interface with EasyDMA 0"]
pub type TWIM0 = twim0::Registers;
#[cfg(feature = "TWIM0")]
#[doc = "I2C compatible Two-Wire Master Interface with EasyDMA 0"]
pub mod twim0 {
    #[allow(non_camel_case_types)]
    #[doc = "Start TWI receive sequence"]
    pub type TASKS_STARTRX = tasks_startrx::Register;
    #[doc = "Start TWI receive sequence"]
    pub mod tasks_startrx {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                super::BASE_ADDRESS as *mut _
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub unsafe fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub unsafe fn zero(&self) {
                {
                    Self::address().write_volatile(0);
                }
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 0) Start TWI receive sequence"]
            #[allow(non_snake_case)]
            pub fn TASKS_STARTRX(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Start TWI transmit sequence"]
    pub type TASKS_STARTTX = tasks_starttx::Register;
    #[doc = "Start TWI transmit sequence"]
    pub mod tasks_starttx {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x08) as *mut _
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub unsafe fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub unsafe fn zero(&self) {
                {
                    Self::address().write_volatile(0);
                }
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 0) Start TWI transmit sequence"]
            #[allow(non_snake_case)]
            pub fn TASKS_STARTTX(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Stop TWI transaction. Must be issued while the TWI master is not suspended."]
    pub type TASKS_STOP = tasks_stop::Register;
    #[doc = "Stop TWI transaction. Must be issued while the TWI master is not suspended."]
    pub mod tasks_stop {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x14) as *mut _
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 0) Stop TWI transaction. Must be issued while the TWI master is not suspended."]
            #[allow(non_snake_case)]
            pub fn TASKS_STOP(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Suspend TWI transaction"]
    pub type TASKS_SUSPEND = tasks_suspend::Register;
    #[doc = "Suspend TWI transaction"]
    pub mod tasks_suspend {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x1c) as *mut _
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 0) Suspend TWI transaction"]
            #[allow(non_snake_case)]
            pub fn TASKS_SUSPEND(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Resume TWI transaction"]
    pub type TASKS_RESUME = tasks_resume::Register;
    #[doc = "Resume TWI transaction"]
    pub mod tasks_resume {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x20) as *mut _
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 0) Resume TWI transaction"]
            #[allow(non_snake_case)]
            pub fn TASKS_RESUME(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "TWI stopped"]
    pub type EVENTS_STOPPED = events_stopped::Register;
    #[doc = "TWI stopped"]
    pub mod events_stopped {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0104) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bit 0) TWI stopped"]
            pub fn EVENTS_STOPPED(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u8 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "EVENTS_STOPPED {{ EVENTS_STOPPED: {0} }}@237225969049721000"]
                #[link_section = ".binfmt.EVENTS_STOPPED {{ EVENTS_STOPPED: {0} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 0) TWI stopped"]
            #[allow(non_snake_case)]
            pub fn EVENTS_STOPPED(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "TWI error"]
    pub type EVENTS_ERROR = events_error::Register;
    #[doc = "TWI error"]
    pub mod events_error {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0124) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bit 0) TWI error"]
            pub fn EVENTS_ERROR(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u8 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "EVENTS_ERROR {{ EVENTS_ERROR: {0} }}@4004211467866346477"]
                #[link_section = ".binfmt.EVENTS_ERROR {{ EVENTS_ERROR: {0} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 0) TWI error"]
            #[allow(non_snake_case)]
            pub fn EVENTS_ERROR(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Last byte has been sent out after the SUSPEND task has been issued, TWI traffic is now suspended."]
    pub type EVENTS_SUSPENDED = events_suspended::Register;
    #[doc = "Last byte has been sent out after the SUSPEND task has been issued, TWI traffic is now suspended."]
    pub mod events_suspended {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0148) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bit 0) Last byte has been sent out after the SUSPEND task has been issued, TWI traffic is now suspended."]
            pub fn EVENTS_SUSPENDED(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u8 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "EVENTS_SUSPENDED {{ EVENTS_SUSPENDED: {0} }}@15282941032431763167"]
                #[link_section = ".binfmt.EVENTS_SUSPENDED {{ EVENTS_SUSPENDED: {0} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 0) Last byte has been sent out after the SUSPEND task has been issued, TWI traffic is now suspended."]
            #[allow(non_snake_case)]
            pub fn EVENTS_SUSPENDED(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Receive sequence started"]
    pub type EVENTS_RXSTARTED = events_rxstarted::Register;
    #[doc = "Receive sequence started"]
    pub mod events_rxstarted {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x014c) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bit 0) Receive sequence started"]
            pub fn EVENTS_RXSTARTED(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u8 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "EVENTS_RXSTARTED {{ EVENTS_RXSTARTED: {0} }}@14858361602135273457"]
                #[link_section = ".binfmt.EVENTS_RXSTARTED {{ EVENTS_RXSTARTED: {0} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 0) Receive sequence started"]
            #[allow(non_snake_case)]
            pub fn EVENTS_RXSTARTED(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Transmit sequence started"]
    pub type EVENTS_TXSTARTED = events_txstarted::Register;
    #[doc = "Transmit sequence started"]
    pub mod events_txstarted {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0150) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bit 0) Transmit sequence started"]
            pub fn EVENTS_TXSTARTED(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u8 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "EVENTS_TXSTARTED {{ EVENTS_TXSTARTED: {0} }}@10777245888324828920"]
                #[link_section = ".binfmt.EVENTS_TXSTARTED {{ EVENTS_TXSTARTED: {0} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 0) Transmit sequence started"]
            #[allow(non_snake_case)]
            pub fn EVENTS_TXSTARTED(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Byte boundary, starting to receive the last byte"]
    pub type EVENTS_LASTRX = events_lastrx::Register;
    #[doc = "Byte boundary, starting to receive the last byte"]
    pub mod events_lastrx {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x015c) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bit 0) Byte boundary, starting to receive the last byte"]
            pub fn EVENTS_LASTRX(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u8 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "EVENTS_LASTRX {{ EVENTS_LASTRX: {0} }}@3314135855955091820"]
                #[link_section = ".binfmt.EVENTS_LASTRX {{ EVENTS_LASTRX: {0} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 0) Byte boundary, starting to receive the last byte"]
            #[allow(non_snake_case)]
            pub fn EVENTS_LASTRX(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Byte boundary, starting to transmit the last byte"]
    pub type EVENTS_LASTTX = events_lasttx::Register;
    #[doc = "Byte boundary, starting to transmit the last byte"]
    pub mod events_lasttx {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0160) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bit 0) Byte boundary, starting to transmit the last byte"]
            pub fn EVENTS_LASTTX(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u8 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "EVENTS_LASTTX {{ EVENTS_LASTTX: {0} }}@15712271578119750265"]
                #[link_section = ".binfmt.EVENTS_LASTTX {{ EVENTS_LASTTX: {0} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 0) Byte boundary, starting to transmit the last byte"]
            #[allow(non_snake_case)]
            pub fn EVENTS_LASTTX(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Shortcuts between local events and tasks"]
    pub type SHORTS = shorts::Register;
    #[doc = "Shortcuts between local events and tasks"]
    pub mod shorts {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0200) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bit 7) Shortcut between event LASTTX and task STARTRX"]
            pub fn LASTTX_STARTRX(self) -> u8 {
                const OFFSET: u8 = 7;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 8) Shortcut between event LASTTX and task SUSPEND"]
            pub fn LASTTX_SUSPEND(self) -> u8 {
                const OFFSET: u8 = 8;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 9) Shortcut between event LASTTX and task STOP"]
            pub fn LASTTX_STOP(self) -> u8 {
                const OFFSET: u8 = 9;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 10) Shortcut between event LASTRX and task STARTTX"]
            pub fn LASTRX_STARTTX(self) -> u8 {
                const OFFSET: u8 = 10;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 11) Shortcut between event LASTRX and task SUSPEND"]
            pub fn LASTRX_SUSPEND(self) -> u8 {
                const OFFSET: u8 = 11;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 12) Shortcut between event LASTRX and task STOP"]
            pub fn LASTRX_STOP(self) -> u8 {
                const OFFSET: u8 = 12;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u16 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "SHORTS {{ LASTRX_STOP: {12}, LASTRX_SUSPEND: {11}, LASTRX_STARTTX: {10}, LASTTX_STOP: {9}, LASTTX_SUSPEND: {8}, LASTTX_STARTRX: {7} }}@14704478226472399916"]
                #[link_section = ".binfmt.SHORTS {{ LASTRX_STOP: {12}, LASTRX_SUSPEND: {11}, LASTRX_STARTTX: {10}, LASTTX_STOP: {9}, LASTTX_SUSPEND: {8}, LASTTX_STARTRX: {7} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 7) Shortcut between event LASTTX and task STARTRX"]
            #[allow(non_snake_case)]
            pub fn LASTTX_STARTRX(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 7;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 8) Shortcut between event LASTTX and task SUSPEND"]
            #[allow(non_snake_case)]
            pub fn LASTTX_SUSPEND(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 8;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 9) Shortcut between event LASTTX and task STOP"]
            #[allow(non_snake_case)]
            pub fn LASTTX_STOP(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 9;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 10) Shortcut between event LASTRX and task STARTTX"]
            #[allow(non_snake_case)]
            pub fn LASTRX_STARTTX(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 10;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 11) Shortcut between event LASTRX and task SUSPEND"]
            #[allow(non_snake_case)]
            pub fn LASTRX_SUSPEND(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 11;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 12) Shortcut between event LASTRX and task STOP"]
            #[allow(non_snake_case)]
            pub fn LASTRX_STOP(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 12;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Enable or disable interrupt"]
    pub type INTEN = inten::Register;
    #[doc = "Enable or disable interrupt"]
    pub mod inten {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0300) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub unsafe fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub unsafe fn zero(&self) {
                {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub unsafe fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bit 1) Enable or disable interrupt for event STOPPED"]
            pub fn STOPPED(self) -> u8 {
                const OFFSET: u8 = 1;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 9) Enable or disable interrupt for event ERROR"]
            pub fn ERROR(self) -> u8 {
                const OFFSET: u8 = 9;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 18) Enable or disable interrupt for event SUSPENDED"]
            pub fn SUSPENDED(self) -> u8 {
                const OFFSET: u8 = 18;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 19) Enable or disable interrupt for event RXSTARTED"]
            pub fn RXSTARTED(self) -> u8 {
                const OFFSET: u8 = 19;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 20) Enable or disable interrupt for event TXSTARTED"]
            pub fn TXSTARTED(self) -> u8 {
                const OFFSET: u8 = 20;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 23) Enable or disable interrupt for event LASTRX"]
            pub fn LASTRX(self) -> u8 {
                const OFFSET: u8 = 23;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 24) Enable or disable interrupt for event LASTTX"]
            pub fn LASTTX(self) -> u8 {
                const OFFSET: u8 = 24;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u32 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "INTEN {{ LASTTX: {24}, LASTRX: {23}, TXSTARTED: {20}, RXSTARTED: {19}, SUSPENDED: {18}, ERROR: {9}, STOPPED: {1} }}@16861105178195920507"]
                #[link_section = ".binfmt.INTEN {{ LASTTX: {24}, LASTRX: {23}, TXSTARTED: {20}, RXSTARTED: {19}, SUSPENDED: {18}, ERROR: {9}, STOPPED: {1} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 1) Enable or disable interrupt for event STOPPED"]
            #[allow(non_snake_case)]
            pub fn STOPPED(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 1;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 9) Enable or disable interrupt for event ERROR"]
            #[allow(non_snake_case)]
            pub fn ERROR(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 9;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 18) Enable or disable interrupt for event SUSPENDED"]
            #[allow(non_snake_case)]
            pub fn SUSPENDED(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 18;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 19) Enable or disable interrupt for event RXSTARTED"]
            #[allow(non_snake_case)]
            pub fn RXSTARTED(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 19;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 20) Enable or disable interrupt for event TXSTARTED"]
            #[allow(non_snake_case)]
            pub fn TXSTARTED(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 20;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 23) Enable or disable interrupt for event LASTRX"]
            #[allow(non_snake_case)]
            pub fn LASTRX(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 23;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 24) Enable or disable interrupt for event LASTTX"]
            #[allow(non_snake_case)]
            pub fn LASTTX(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 24;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Enable interrupt"]
    pub type INTENSET = intenset::Register;
    #[doc = "Enable interrupt"]
    pub mod intenset {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0304) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub unsafe fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub unsafe fn zero(&self) {
                {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub unsafe fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bit 1) Write '1' to enable interrupt for event STOPPED"]
            pub fn STOPPED(self) -> u8 {
                const OFFSET: u8 = 1;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 9) Write '1' to enable interrupt for event ERROR"]
            pub fn ERROR(self) -> u8 {
                const OFFSET: u8 = 9;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 18) Write '1' to enable interrupt for event SUSPENDED"]
            pub fn SUSPENDED(self) -> u8 {
                const OFFSET: u8 = 18;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 19) Write '1' to enable interrupt for event RXSTARTED"]
            pub fn RXSTARTED(self) -> u8 {
                const OFFSET: u8 = 19;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 20) Write '1' to enable interrupt for event TXSTARTED"]
            pub fn TXSTARTED(self) -> u8 {
                const OFFSET: u8 = 20;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 23) Write '1' to enable interrupt for event LASTRX"]
            pub fn LASTRX(self) -> u8 {
                const OFFSET: u8 = 23;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 24) Write '1' to enable interrupt for event LASTTX"]
            pub fn LASTTX(self) -> u8 {
                const OFFSET: u8 = 24;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u32 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "INTENSET {{ LASTTX: {24}, LASTRX: {23}, TXSTARTED: {20}, RXSTARTED: {19}, SUSPENDED: {18}, ERROR: {9}, STOPPED: {1} }}@6986419045361147860"]
                #[link_section = ".binfmt.INTENSET {{ LASTTX: {24}, LASTRX: {23}, TXSTARTED: {20}, RXSTARTED: {19}, SUSPENDED: {18}, ERROR: {9}, STOPPED: {1} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 1) Write '1' to enable interrupt for event STOPPED"]
            #[allow(non_snake_case)]
            pub fn STOPPED(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 1;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 9) Write '1' to enable interrupt for event ERROR"]
            #[allow(non_snake_case)]
            pub fn ERROR(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 9;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 18) Write '1' to enable interrupt for event SUSPENDED"]
            #[allow(non_snake_case)]
            pub fn SUSPENDED(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 18;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 19) Write '1' to enable interrupt for event RXSTARTED"]
            #[allow(non_snake_case)]
            pub fn RXSTARTED(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 19;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 20) Write '1' to enable interrupt for event TXSTARTED"]
            #[allow(non_snake_case)]
            pub fn TXSTARTED(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 20;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 23) Write '1' to enable interrupt for event LASTRX"]
            #[allow(non_snake_case)]
            pub fn LASTRX(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 23;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 24) Write '1' to enable interrupt for event LASTTX"]
            #[allow(non_snake_case)]
            pub fn LASTTX(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 24;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Disable interrupt"]
    pub type INTENCLR = intenclr::Register;
    #[doc = "Disable interrupt"]
    pub mod intenclr {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0308) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bit 1) Write '1' to disable interrupt for event STOPPED"]
            pub fn STOPPED(self) -> u8 {
                const OFFSET: u8 = 1;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 9) Write '1' to disable interrupt for event ERROR"]
            pub fn ERROR(self) -> u8 {
                const OFFSET: u8 = 9;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 18) Write '1' to disable interrupt for event SUSPENDED"]
            pub fn SUSPENDED(self) -> u8 {
                const OFFSET: u8 = 18;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 19) Write '1' to disable interrupt for event RXSTARTED"]
            pub fn RXSTARTED(self) -> u8 {
                const OFFSET: u8 = 19;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 20) Write '1' to disable interrupt for event TXSTARTED"]
            pub fn TXSTARTED(self) -> u8 {
                const OFFSET: u8 = 20;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 23) Write '1' to disable interrupt for event LASTRX"]
            pub fn LASTRX(self) -> u8 {
                const OFFSET: u8 = 23;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 24) Write '1' to disable interrupt for event LASTTX"]
            pub fn LASTTX(self) -> u8 {
                const OFFSET: u8 = 24;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u32 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "INTENCLR {{ LASTTX: {24}, LASTRX: {23}, TXSTARTED: {20}, RXSTARTED: {19}, SUSPENDED: {18}, ERROR: {9}, STOPPED: {1} }}@15438124090467254432"]
                #[link_section = ".binfmt.INTENCLR {{ LASTTX: {24}, LASTRX: {23}, TXSTARTED: {20}, RXSTARTED: {19}, SUSPENDED: {18}, ERROR: {9}, STOPPED: {1} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 1) Write '1' to disable interrupt for event STOPPED"]
            #[allow(non_snake_case)]
            pub fn STOPPED(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 1;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 9) Write '1' to disable interrupt for event ERROR"]
            #[allow(non_snake_case)]
            pub fn ERROR(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 9;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 18) Write '1' to disable interrupt for event SUSPENDED"]
            #[allow(non_snake_case)]
            pub fn SUSPENDED(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 18;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 19) Write '1' to disable interrupt for event RXSTARTED"]
            #[allow(non_snake_case)]
            pub fn RXSTARTED(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 19;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 20) Write '1' to disable interrupt for event TXSTARTED"]
            #[allow(non_snake_case)]
            pub fn TXSTARTED(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 20;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 23) Write '1' to disable interrupt for event LASTRX"]
            #[allow(non_snake_case)]
            pub fn LASTRX(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 23;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 24) Write '1' to disable interrupt for event LASTTX"]
            #[allow(non_snake_case)]
            pub fn LASTTX(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 24;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Error source"]
    pub type ERRORSRC = errorsrc::Register;
    #[doc = "Error source"]
    pub mod errorsrc {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x04c4) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bit 0) Overrun error"]
            pub fn OVERRUN(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 1) NACK received after sending the address (write '1' to clear)"]
            pub fn ANACK(self) -> u8 {
                const OFFSET: u8 = 1;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 2) NACK received after sending a data byte (write '1' to clear)"]
            pub fn DNACK(self) -> u8 {
                const OFFSET: u8 = 2;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u8 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "ERRORSRC {{ DNACK: {2}, ANACK: {1}, OVERRUN: {0} }}@853031098863575548"]
                #[link_section = ".binfmt.ERRORSRC {{ DNACK: {2}, ANACK: {1}, OVERRUN: {0} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 0) Overrun error"]
            #[allow(non_snake_case)]
            pub fn OVERRUN(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 1) NACK received after sending the address (write '1' to clear)"]
            #[allow(non_snake_case)]
            pub fn ANACK(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 1;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 2) NACK received after sending a data byte (write '1' to clear)"]
            #[allow(non_snake_case)]
            pub fn DNACK(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 2;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Enable TWIM"]
    pub type ENABLE = enable::Register;
    #[doc = "Enable TWIM"]
    pub mod enable {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0500) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bits 0..=4) Enable or disable TWIM"]
            pub fn ENABLE(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x0f;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u8 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "ENABLE {{ ENABLE: {0:4} }}@8270522149252801561"]
                #[link_section = ".binfmt.ENABLE {{ ENABLE: {0:4} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bits 0..=4) Enable or disable TWIM"]
            #[allow(non_snake_case)]
            pub fn ENABLE(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x0f;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Pin select for SCL signal"]
    pub type PSEL_SCL = psel_scl::Register;
    #[doc = "Pin select for SCL signal"]
    pub mod psel_scl {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0508) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bits 0..=5) Pin number"]
            pub fn PIN(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x1f;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 5) Port number"]
            pub fn PORT(self) -> u8 {
                const OFFSET: u8 = 5;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 31) Connection"]
            pub fn CONNECT(self) -> u8 {
                const OFFSET: u8 = 31;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u32 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "PSEL_SCL {{ CONNECT: {31}, PORT: {5}, PIN: {0:5} }}@18164173993146831798"]
                #[link_section = ".binfmt.PSEL_SCL {{ CONNECT: {31}, PORT: {5}, PIN: {0:5} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bits 0..=5) Pin number"]
            #[allow(non_snake_case)]
            pub fn PIN(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x1f;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 5) Port number"]
            #[allow(non_snake_case)]
            pub fn PORT(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 5;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 31) Connection"]
            #[allow(non_snake_case)]
            pub fn CONNECT(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 31;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Pin select for SDA signal"]
    pub type PSEL_SDA = psel_sda::Register;
    #[doc = "Pin select for SDA signal"]
    pub mod psel_sda {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x050c) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bits 0..=5) Pin number"]
            pub fn PIN(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x1f;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 5) Port number"]
            pub fn PORT(self) -> u8 {
                const OFFSET: u8 = 5;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 31) Connection"]
            pub fn CONNECT(self) -> u8 {
                const OFFSET: u8 = 31;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u32 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "PSEL_SDA {{ CONNECT: {31}, PORT: {5}, PIN: {0:5} }}@5767010158155299317"]
                #[link_section = ".binfmt.PSEL_SDA {{ CONNECT: {31}, PORT: {5}, PIN: {0:5} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bits 0..=5) Pin number"]
            #[allow(non_snake_case)]
            pub fn PIN(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x1f;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 5) Port number"]
            #[allow(non_snake_case)]
            pub fn PORT(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 5;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 31) Connection"]
            #[allow(non_snake_case)]
            pub fn CONNECT(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 31;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "TWI frequency. Accuracy depends on the HFCLK source selected."]
    pub type FREQUENCY = frequency::Register;
    #[doc = "TWI frequency. Accuracy depends on the HFCLK source selected."]
    pub mod frequency {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0524) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bits 0..=32) TWI master clock frequency"]
            pub fn FREQUENCY(self) -> u32 {
                const OFFSET: u8 = 0;
                const MASK: u32 = 0xffff_ffff;
                ((self.inner >> OFFSET) as u32) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u32 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "FREQUENCY {{ FREQUENCY: {0:32} }}@8189628058627447547"]
                #[link_section = ".binfmt.FREQUENCY {{ FREQUENCY: {0:32} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bits 0..=32) TWI master clock frequency"]
            #[allow(non_snake_case)]
            pub fn FREQUENCY(&mut self, val: u32) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u32 = 0xffff_ffff;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Data pointer"]
    pub type RXD_PTR = rxd_ptr::Register;
    #[doc = "Data pointer"]
    pub mod rxd_ptr {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0534) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub unsafe fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub unsafe fn zero(&self) {
                {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub unsafe fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bits 0..=32) Data pointer"]
            pub fn PTR(self) -> u32 {
                const OFFSET: u8 = 0;
                const MASK: u32 = 0xffff_ffff;
                ((self.inner >> OFFSET) as u32) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u32 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "RXD_PTR {{ PTR: {0:32} }}@2490538157322640708"]
                #[link_section = ".binfmt.RXD_PTR {{ PTR: {0:32} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bits 0..=32) Data pointer"]
            #[allow(non_snake_case)]
            pub fn PTR(&mut self, val: u32) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u32 = 0xffff_ffff;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Maximum number of bytes in receive buffer"]
    pub type RXD_MAXCNT = rxd_maxcnt::Register;
    #[doc = "Maximum number of bytes in receive buffer"]
    pub mod rxd_maxcnt {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0538) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub unsafe fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub unsafe fn zero(&self) {
                {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub unsafe fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bits 0..=8) Maximum number of bytes in receive buffer"]
            pub fn MAXCNT(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0xff;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u8 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "RXD_MAXCNT {{ MAXCNT: {0:8} }}@4165514479663691177"]
                #[link_section = ".binfmt.RXD_MAXCNT {{ MAXCNT: {0:8} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bits 0..=8) Maximum number of bytes in receive buffer"]
            #[allow(non_snake_case)]
            pub fn MAXCNT(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0xff;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Number of bytes transferred in the last transaction"]
    pub type RXD_AMOUNT = rxd_amount::Register;
    #[doc = "Number of bytes transferred in the last transaction"]
    pub mod rxd_amount {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *const u32 {
                (super::BASE_ADDRESS + 0x053c) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bits 0..=8) Number of bytes transferred in the last transaction. In case of NACK error, includes the NACK'ed byte."]
            pub fn AMOUNT(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0xff;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u8 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "RXD_AMOUNT {{ AMOUNT: {0:8} }}@9264609903957996697"]
                #[link_section = ".binfmt.RXD_AMOUNT {{ AMOUNT: {0:8} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "EasyDMA list type"]
    pub type RXD_LIST = rxd_list::Register;
    #[doc = "EasyDMA list type"]
    pub mod rxd_list {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0540) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bits 0..=3) List type"]
            pub fn LIST(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x07;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u8 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "RXD_LIST {{ LIST: {0:3} }}@8075572582446323929"]
                #[link_section = ".binfmt.RXD_LIST {{ LIST: {0:3} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bits 0..=3) List type"]
            #[allow(non_snake_case)]
            pub fn LIST(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x07;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Data pointer"]
    pub type TXD_PTR = txd_ptr::Register;
    #[doc = "Data pointer"]
    pub mod txd_ptr {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0544) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub unsafe fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub unsafe fn zero(&self) {
                {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub unsafe fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bits 0..=32) Data pointer"]
            pub fn PTR(self) -> u32 {
                const OFFSET: u8 = 0;
                const MASK: u32 = 0xffff_ffff;
                ((self.inner >> OFFSET) as u32) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u32 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "TXD_PTR {{ PTR: {0:32} }}@11258763418749230941"]
                #[link_section = ".binfmt.TXD_PTR {{ PTR: {0:32} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bits 0..=32) Data pointer"]
            #[allow(non_snake_case)]
            pub fn PTR(&mut self, val: u32) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u32 = 0xffff_ffff;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Maximum number of bytes in transmit buffer"]
    pub type TXD_MAXCNT = txd_maxcnt::Register;
    #[doc = "Maximum number of bytes in transmit buffer"]
    pub mod txd_maxcnt {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0548) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub unsafe fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub unsafe fn zero(&self) {
                {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub unsafe fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bits 0..=8) Maximum number of bytes in transmit buffer"]
            pub fn MAXCNT(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0xff;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u8 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "TXD_MAXCNT {{ MAXCNT: {0:8} }}@9653777961179509987"]
                #[link_section = ".binfmt.TXD_MAXCNT {{ MAXCNT: {0:8} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bits 0..=8) Maximum number of bytes in transmit buffer"]
            #[allow(non_snake_case)]
            pub fn MAXCNT(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0xff;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Number of bytes transferred in the last transaction"]
    pub type TXD_AMOUNT = txd_amount::Register;
    #[doc = "Number of bytes transferred in the last transaction"]
    pub mod txd_amount {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *const u32 {
                (super::BASE_ADDRESS + 0x054c) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bits 0..=8) Number of bytes transferred in the last transaction. In case of NACK error, includes the NACK'ed byte."]
            pub fn AMOUNT(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0xff;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u8 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "TXD_AMOUNT {{ AMOUNT: {0:8} }}@14305495803166225213"]
                #[link_section = ".binfmt.TXD_AMOUNT {{ AMOUNT: {0:8} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "EasyDMA list type"]
    pub type TXD_LIST = txd_list::Register;
    #[doc = "EasyDMA list type"]
    pub mod txd_list {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0550) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bits 0..=3) List type"]
            pub fn LIST(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x07;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u8 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "TXD_LIST {{ LIST: {0:3} }}@2629379173647785724"]
                #[link_section = ".binfmt.TXD_LIST {{ LIST: {0:3} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bits 0..=3) List type"]
            #[allow(non_snake_case)]
            pub fn LIST(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x07;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Address used in the TWI transfer"]
    pub type ADDRESS = address::Register;
    #[doc = "Address used in the TWI transfer"]
    pub mod address {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0588) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bits 0..=7) Address used in the TWI transfer"]
            pub fn ADDRESS(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x7f;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u8 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "ADDRESS {{ ADDRESS: {0:7} }}@17909291936742963268"]
                #[link_section = ".binfmt.ADDRESS {{ ADDRESS: {0:7} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bits 0..=7) Address used in the TWI transfer"]
            #[allow(non_snake_case)]
            pub fn ADDRESS(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x7f;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    use core::sync::atomic::{AtomicBool, Ordering};
    const BASE_ADDRESS: usize = 0x4000_3000;
    #[allow(non_snake_case)]
    #[doc = "Singleton handle to the TWIM0 registers"]
    pub struct Registers {
        #[doc = "Start TWI receive sequence"]
        pub TASKS_STARTRX: TASKS_STARTRX,
        #[doc = "Start TWI transmit sequence"]
        pub TASKS_STARTTX: TASKS_STARTTX,
        #[doc = "Stop TWI transaction. Must be issued while the TWI master is not suspended."]
        pub TASKS_STOP: TASKS_STOP,
        #[doc = "Suspend TWI transaction"]
        pub TASKS_SUSPEND: TASKS_SUSPEND,
        #[doc = "Resume TWI transaction"]
        pub TASKS_RESUME: TASKS_RESUME,
        #[doc = "TWI stopped"]
        pub EVENTS_STOPPED: EVENTS_STOPPED,
        #[doc = "TWI error"]
        pub EVENTS_ERROR: EVENTS_ERROR,
        #[doc = "Last byte has been sent out after the SUSPEND task has been issued, TWI traffic is now suspended."]
        pub EVENTS_SUSPENDED: EVENTS_SUSPENDED,
        #[doc = "Receive sequence started"]
        pub EVENTS_RXSTARTED: EVENTS_RXSTARTED,
        #[doc = "Transmit sequence started"]
        pub EVENTS_TXSTARTED: EVENTS_TXSTARTED,
        #[doc = "Byte boundary, starting to receive the last byte"]
        pub EVENTS_LASTRX: EVENTS_LASTRX,
        #[doc = "Byte boundary, starting to transmit the last byte"]
        pub EVENTS_LASTTX: EVENTS_LASTTX,
        #[doc = "Shortcuts between local events and tasks"]
        pub SHORTS: SHORTS,
        #[doc = "Enable or disable interrupt"]
        pub INTEN: INTEN,
        #[doc = "Enable interrupt"]
        pub INTENSET: INTENSET,
        #[doc = "Disable interrupt"]
        pub INTENCLR: INTENCLR,
        #[doc = "Error source"]
        pub ERRORSRC: ERRORSRC,
        #[doc = "Enable TWIM"]
        pub ENABLE: ENABLE,
        #[doc = "Pin select for SCL signal"]
        pub PSEL_SCL: PSEL_SCL,
        #[doc = "Pin select for SDA signal"]
        pub PSEL_SDA: PSEL_SDA,
        #[doc = "TWI frequency. Accuracy depends on the HFCLK source selected."]
        pub FREQUENCY: FREQUENCY,
        #[doc = "Data pointer"]
        pub RXD_PTR: RXD_PTR,
        #[doc = "Maximum number of bytes in receive buffer"]
        pub RXD_MAXCNT: RXD_MAXCNT,
        #[doc = "Number of bytes transferred in the last transaction"]
        pub RXD_AMOUNT: RXD_AMOUNT,
        #[doc = "EasyDMA list type"]
        pub RXD_LIST: RXD_LIST,
        #[doc = "Data pointer"]
        pub TXD_PTR: TXD_PTR,
        #[doc = "Maximum number of bytes in transmit buffer"]
        pub TXD_MAXCNT: TXD_MAXCNT,
        #[doc = "Number of bytes transferred in the last transaction"]
        pub TXD_AMOUNT: TXD_AMOUNT,
        #[doc = "EasyDMA list type"]
        pub TXD_LIST: TXD_LIST,
        #[doc = "Address used in the TWI transfer"]
        pub ADDRESS: ADDRESS,
    }
    unsafe impl Send for Registers {}
    impl Registers {
        #[doc = r" # Safety"]
        #[doc = r" Singleton"]
        unsafe fn new() -> Self {
            Self {
                TASKS_STARTRX: TASKS_STARTRX::new(),
                TASKS_STARTTX: TASKS_STARTTX::new(),
                TASKS_STOP: TASKS_STOP::new(),
                TASKS_SUSPEND: TASKS_SUSPEND::new(),
                TASKS_RESUME: TASKS_RESUME::new(),
                EVENTS_STOPPED: EVENTS_STOPPED::new(),
                EVENTS_ERROR: EVENTS_ERROR::new(),
                EVENTS_SUSPENDED: EVENTS_SUSPENDED::new(),
                EVENTS_RXSTARTED: EVENTS_RXSTARTED::new(),
                EVENTS_TXSTARTED: EVENTS_TXSTARTED::new(),
                EVENTS_LASTRX: EVENTS_LASTRX::new(),
                EVENTS_LASTTX: EVENTS_LASTTX::new(),
                SHORTS: SHORTS::new(),
                INTEN: INTEN::new(),
                INTENSET: INTENSET::new(),
                INTENCLR: INTENCLR::new(),
                ERRORSRC: ERRORSRC::new(),
                ENABLE: ENABLE::new(),
                PSEL_SCL: PSEL_SCL::new(),
                PSEL_SDA: PSEL_SDA::new(),
                FREQUENCY: FREQUENCY::new(),
                RXD_PTR: RXD_PTR::new(),
                RXD_MAXCNT: RXD_MAXCNT::new(),
                RXD_AMOUNT: RXD_AMOUNT::new(),
                RXD_LIST: RXD_LIST::new(),
                TXD_PTR: TXD_PTR::new(),
                TXD_MAXCNT: TXD_MAXCNT::new(),
                TXD_AMOUNT: TXD_AMOUNT::new(),
                TXD_LIST: TXD_LIST::new(),
                ADDRESS: ADDRESS::new(),
            }
        }
        fn taken() -> &'static AtomicBool {
            static TAKEN: AtomicBool = AtomicBool::new(false);
            &TAKEN
        }
        #[doc = r" Grants temporary access to the peripheral, without checking if it has already been"]
        #[doc = r" taken"]
        #[inline(always)]
        pub fn borrow_unchecked<T>(f: impl FnOnce(&Self) -> T) -> T {
            f(unsafe { &Self::new() })
        }
        #[doc = r" Seals the peripheral making it impossible to `take` it"]
        pub fn seal() {
            Self::taken().store(true, Ordering::Relaxed)
        }
        #[doc = r" Takes ownership of the peripheral"]
        #[doc = r""]
        #[doc = r" This constructor returns the `Some` variant only once"]
        pub fn take() -> Option<Self> {
            let taken = Self::taken();
            if taken
                .compare_exchange(false, true, Ordering::Relaxed, Ordering::Relaxed)
                .is_ok()
            {
                Some(unsafe { Self::new() })
            } else {
                None
            }
        }
    }
}
#[allow(non_camel_case_types)]
#[cfg(feature = "RTC0")]
#[doc = "Real time counter 0"]
pub type RTC0 = rtc0::Registers;
#[cfg(feature = "RTC0")]
#[doc = "Real time counter 0"]
pub mod rtc0 {
    #[allow(non_camel_case_types)]
    #[doc = "Start RTC COUNTER"]
    pub type TASKS_START = tasks_start::Register;
    #[doc = "Start RTC COUNTER"]
    pub mod tasks_start {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                super::BASE_ADDRESS as *mut _
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 0) Start RTC COUNTER"]
            #[allow(non_snake_case)]
            pub fn TASKS_START(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Stop RTC COUNTER"]
    pub type TASKS_STOP = tasks_stop::Register;
    #[doc = "Stop RTC COUNTER"]
    pub mod tasks_stop {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x04) as *mut _
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 0) Stop RTC COUNTER"]
            #[allow(non_snake_case)]
            pub fn TASKS_STOP(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Clear RTC COUNTER"]
    pub type TASKS_CLEAR = tasks_clear::Register;
    #[doc = "Clear RTC COUNTER"]
    pub mod tasks_clear {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x08) as *mut _
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 0) Clear RTC COUNTER"]
            #[allow(non_snake_case)]
            pub fn TASKS_CLEAR(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Set COUNTER to 0xFFFFF0"]
    pub type TASKS_TRIGOVRFLW = tasks_trigovrflw::Register;
    #[doc = "Set COUNTER to 0xFFFFF0"]
    pub mod tasks_trigovrflw {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0c) as *mut _
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 0) Set COUNTER to 0xFFFFF0"]
            #[allow(non_snake_case)]
            pub fn TASKS_TRIGOVRFLW(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Event on COUNTER increment"]
    pub type EVENTS_TICK = events_tick::Register;
    #[doc = "Event on COUNTER increment"]
    pub mod events_tick {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0100) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bit 0) Event on COUNTER increment"]
            pub fn EVENTS_TICK(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u8 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "EVENTS_TICK {{ EVENTS_TICK: {0} }}@17182246805445973554"]
                #[link_section = ".binfmt.EVENTS_TICK {{ EVENTS_TICK: {0} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 0) Event on COUNTER increment"]
            #[allow(non_snake_case)]
            pub fn EVENTS_TICK(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Event on COUNTER overflow"]
    pub type EVENTS_OVRFLW = events_ovrflw::Register;
    #[doc = "Event on COUNTER overflow"]
    pub mod events_ovrflw {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0104) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bit 0) Event on COUNTER overflow"]
            pub fn EVENTS_OVRFLW(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u8 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "EVENTS_OVRFLW {{ EVENTS_OVRFLW: {0} }}@16271898161025829181"]
                #[link_section = ".binfmt.EVENTS_OVRFLW {{ EVENTS_OVRFLW: {0} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 0) Event on COUNTER overflow"]
            #[allow(non_snake_case)]
            pub fn EVENTS_OVRFLW(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Description collection: Compare event on CC[n] match"]
    pub type EVENTS_COMPARE0 = events_compare0::Register;
    #[doc = "Description collection: Compare event on CC[n] match"]
    pub mod events_compare0 {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0140) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bit 0) Compare event on CC[n] match"]
            pub fn EVENTS_COMPARE(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u8 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "EVENTS_COMPARE0 {{ EVENTS_COMPARE: {0} }}@2789192879160392740"]
                #[link_section = ".binfmt.EVENTS_COMPARE0 {{ EVENTS_COMPARE: {0} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 0) Compare event on CC[n] match"]
            #[allow(non_snake_case)]
            pub fn EVENTS_COMPARE(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Description collection: Compare event on CC[n] match"]
    pub type EVENTS_COMPARE1 = events_compare1::Register;
    #[doc = "Description collection: Compare event on CC[n] match"]
    pub mod events_compare1 {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0144) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bit 0) Compare event on CC[n] match"]
            pub fn EVENTS_COMPARE(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u8 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "EVENTS_COMPARE1 {{ EVENTS_COMPARE: {0} }}@3986767900475203311"]
                #[link_section = ".binfmt.EVENTS_COMPARE1 {{ EVENTS_COMPARE: {0} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 0) Compare event on CC[n] match"]
            #[allow(non_snake_case)]
            pub fn EVENTS_COMPARE(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Description collection: Compare event on CC[n] match"]
    pub type EVENTS_COMPARE2 = events_compare2::Register;
    #[doc = "Description collection: Compare event on CC[n] match"]
    pub mod events_compare2 {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0148) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bit 0) Compare event on CC[n] match"]
            pub fn EVENTS_COMPARE(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u8 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "EVENTS_COMPARE2 {{ EVENTS_COMPARE: {0} }}@15501680138427958490"]
                #[link_section = ".binfmt.EVENTS_COMPARE2 {{ EVENTS_COMPARE: {0} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 0) Compare event on CC[n] match"]
            #[allow(non_snake_case)]
            pub fn EVENTS_COMPARE(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Description collection: Compare event on CC[n] match"]
    pub type EVENTS_COMPARE3 = events_compare3::Register;
    #[doc = "Description collection: Compare event on CC[n] match"]
    pub mod events_compare3 {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x014c) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bit 0) Compare event on CC[n] match"]
            pub fn EVENTS_COMPARE(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u8 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "EVENTS_COMPARE3 {{ EVENTS_COMPARE: {0} }}@3132908856246685081"]
                #[link_section = ".binfmt.EVENTS_COMPARE3 {{ EVENTS_COMPARE: {0} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 0) Compare event on CC[n] match"]
            #[allow(non_snake_case)]
            pub fn EVENTS_COMPARE(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Enable interrupt"]
    pub type INTENSET = intenset::Register;
    #[doc = "Enable interrupt"]
    pub mod intenset {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0304) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub unsafe fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub unsafe fn zero(&self) {
                {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub unsafe fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bit 0) Write '1' to enable interrupt for event TICK"]
            pub fn TICK(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 1) Write '1' to enable interrupt for event OVRFLW"]
            pub fn OVRFLW(self) -> u8 {
                const OFFSET: u8 = 1;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 16) Write '1' to enable interrupt for event COMPARE[0]"]
            pub fn COMPARE0(self) -> u8 {
                const OFFSET: u8 = 16;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 17) Write '1' to enable interrupt for event COMPARE[1]"]
            pub fn COMPARE1(self) -> u8 {
                const OFFSET: u8 = 17;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 18) Write '1' to enable interrupt for event COMPARE[2]"]
            pub fn COMPARE2(self) -> u8 {
                const OFFSET: u8 = 18;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 19) Write '1' to enable interrupt for event COMPARE[3]"]
            pub fn COMPARE3(self) -> u8 {
                const OFFSET: u8 = 19;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u32 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "INTENSET {{ COMPARE3: {19}, COMPARE2: {18}, COMPARE1: {17}, COMPARE0: {16}, OVRFLW: {1}, TICK: {0} }}@8984598100189256032"]
                #[link_section = ".binfmt.INTENSET {{ COMPARE3: {19}, COMPARE2: {18}, COMPARE1: {17}, COMPARE0: {16}, OVRFLW: {1}, TICK: {0} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 0) Write '1' to enable interrupt for event TICK"]
            #[allow(non_snake_case)]
            pub fn TICK(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 1) Write '1' to enable interrupt for event OVRFLW"]
            #[allow(non_snake_case)]
            pub fn OVRFLW(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 1;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 16) Write '1' to enable interrupt for event COMPARE[0]"]
            #[allow(non_snake_case)]
            pub fn COMPARE0(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 16;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 17) Write '1' to enable interrupt for event COMPARE[1]"]
            #[allow(non_snake_case)]
            pub fn COMPARE1(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 17;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 18) Write '1' to enable interrupt for event COMPARE[2]"]
            #[allow(non_snake_case)]
            pub fn COMPARE2(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 18;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 19) Write '1' to enable interrupt for event COMPARE[3]"]
            #[allow(non_snake_case)]
            pub fn COMPARE3(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 19;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Disable interrupt"]
    pub type INTENCLR = intenclr::Register;
    #[doc = "Disable interrupt"]
    pub mod intenclr {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0308) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bit 0) Write '1' to disable interrupt for event TICK"]
            pub fn TICK(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 1) Write '1' to disable interrupt for event OVRFLW"]
            pub fn OVRFLW(self) -> u8 {
                const OFFSET: u8 = 1;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 16) Write '1' to disable interrupt for event COMPARE[0]"]
            pub fn COMPARE0(self) -> u8 {
                const OFFSET: u8 = 16;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 17) Write '1' to disable interrupt for event COMPARE[1]"]
            pub fn COMPARE1(self) -> u8 {
                const OFFSET: u8 = 17;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 18) Write '1' to disable interrupt for event COMPARE[2]"]
            pub fn COMPARE2(self) -> u8 {
                const OFFSET: u8 = 18;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 19) Write '1' to disable interrupt for event COMPARE[3]"]
            pub fn COMPARE3(self) -> u8 {
                const OFFSET: u8 = 19;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u32 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "INTENCLR {{ COMPARE3: {19}, COMPARE2: {18}, COMPARE1: {17}, COMPARE0: {16}, OVRFLW: {1}, TICK: {0} }}@1527436094068560087"]
                #[link_section = ".binfmt.INTENCLR {{ COMPARE3: {19}, COMPARE2: {18}, COMPARE1: {17}, COMPARE0: {16}, OVRFLW: {1}, TICK: {0} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 0) Write '1' to disable interrupt for event TICK"]
            #[allow(non_snake_case)]
            pub fn TICK(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 1) Write '1' to disable interrupt for event OVRFLW"]
            #[allow(non_snake_case)]
            pub fn OVRFLW(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 1;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 16) Write '1' to disable interrupt for event COMPARE[0]"]
            #[allow(non_snake_case)]
            pub fn COMPARE0(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 16;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 17) Write '1' to disable interrupt for event COMPARE[1]"]
            #[allow(non_snake_case)]
            pub fn COMPARE1(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 17;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 18) Write '1' to disable interrupt for event COMPARE[2]"]
            #[allow(non_snake_case)]
            pub fn COMPARE2(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 18;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 19) Write '1' to disable interrupt for event COMPARE[3]"]
            #[allow(non_snake_case)]
            pub fn COMPARE3(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 19;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Enable or disable event routing"]
    pub type EVTEN = evten::Register;
    #[doc = "Enable or disable event routing"]
    pub mod evten {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0340) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bit 0) Enable or disable event routing for event TICK"]
            pub fn TICK(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 1) Enable or disable event routing for event OVRFLW"]
            pub fn OVRFLW(self) -> u8 {
                const OFFSET: u8 = 1;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 16) Enable or disable event routing for event COMPARE[0]"]
            pub fn COMPARE0(self) -> u8 {
                const OFFSET: u8 = 16;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 17) Enable or disable event routing for event COMPARE[1]"]
            pub fn COMPARE1(self) -> u8 {
                const OFFSET: u8 = 17;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 18) Enable or disable event routing for event COMPARE[2]"]
            pub fn COMPARE2(self) -> u8 {
                const OFFSET: u8 = 18;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 19) Enable or disable event routing for event COMPARE[3]"]
            pub fn COMPARE3(self) -> u8 {
                const OFFSET: u8 = 19;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u32 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "EVTEN {{ COMPARE3: {19}, COMPARE2: {18}, COMPARE1: {17}, COMPARE0: {16}, OVRFLW: {1}, TICK: {0} }}@14359837387834799575"]
                #[link_section = ".binfmt.EVTEN {{ COMPARE3: {19}, COMPARE2: {18}, COMPARE1: {17}, COMPARE0: {16}, OVRFLW: {1}, TICK: {0} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 0) Enable or disable event routing for event TICK"]
            #[allow(non_snake_case)]
            pub fn TICK(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 1) Enable or disable event routing for event OVRFLW"]
            #[allow(non_snake_case)]
            pub fn OVRFLW(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 1;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 16) Enable or disable event routing for event COMPARE[0]"]
            #[allow(non_snake_case)]
            pub fn COMPARE0(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 16;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 17) Enable or disable event routing for event COMPARE[1]"]
            #[allow(non_snake_case)]
            pub fn COMPARE1(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 17;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 18) Enable or disable event routing for event COMPARE[2]"]
            #[allow(non_snake_case)]
            pub fn COMPARE2(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 18;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 19) Enable or disable event routing for event COMPARE[3]"]
            #[allow(non_snake_case)]
            pub fn COMPARE3(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 19;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Enable event routing"]
    pub type EVTENSET = evtenset::Register;
    #[doc = "Enable event routing"]
    pub mod evtenset {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0344) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bit 0) Write '1' to enable event routing for event TICK"]
            pub fn TICK(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 1) Write '1' to enable event routing for event OVRFLW"]
            pub fn OVRFLW(self) -> u8 {
                const OFFSET: u8 = 1;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 16) Write '1' to enable event routing for event COMPARE[0]"]
            pub fn COMPARE0(self) -> u8 {
                const OFFSET: u8 = 16;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 17) Write '1' to enable event routing for event COMPARE[1]"]
            pub fn COMPARE1(self) -> u8 {
                const OFFSET: u8 = 17;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 18) Write '1' to enable event routing for event COMPARE[2]"]
            pub fn COMPARE2(self) -> u8 {
                const OFFSET: u8 = 18;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 19) Write '1' to enable event routing for event COMPARE[3]"]
            pub fn COMPARE3(self) -> u8 {
                const OFFSET: u8 = 19;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u32 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "EVTENSET {{ COMPARE3: {19}, COMPARE2: {18}, COMPARE1: {17}, COMPARE0: {16}, OVRFLW: {1}, TICK: {0} }}@2472746845537518483"]
                #[link_section = ".binfmt.EVTENSET {{ COMPARE3: {19}, COMPARE2: {18}, COMPARE1: {17}, COMPARE0: {16}, OVRFLW: {1}, TICK: {0} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 0) Write '1' to enable event routing for event TICK"]
            #[allow(non_snake_case)]
            pub fn TICK(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 1) Write '1' to enable event routing for event OVRFLW"]
            #[allow(non_snake_case)]
            pub fn OVRFLW(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 1;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 16) Write '1' to enable event routing for event COMPARE[0]"]
            #[allow(non_snake_case)]
            pub fn COMPARE0(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 16;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 17) Write '1' to enable event routing for event COMPARE[1]"]
            #[allow(non_snake_case)]
            pub fn COMPARE1(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 17;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 18) Write '1' to enable event routing for event COMPARE[2]"]
            #[allow(non_snake_case)]
            pub fn COMPARE2(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 18;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 19) Write '1' to enable event routing for event COMPARE[3]"]
            #[allow(non_snake_case)]
            pub fn COMPARE3(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 19;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Disable event routing"]
    pub type EVTENCLR = evtenclr::Register;
    #[doc = "Disable event routing"]
    pub mod evtenclr {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0348) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bit 0) Write '1' to disable event routing for event TICK"]
            pub fn TICK(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 1) Write '1' to disable event routing for event OVRFLW"]
            pub fn OVRFLW(self) -> u8 {
                const OFFSET: u8 = 1;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 16) Write '1' to disable event routing for event COMPARE[0]"]
            pub fn COMPARE0(self) -> u8 {
                const OFFSET: u8 = 16;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 17) Write '1' to disable event routing for event COMPARE[1]"]
            pub fn COMPARE1(self) -> u8 {
                const OFFSET: u8 = 17;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 18) Write '1' to disable event routing for event COMPARE[2]"]
            pub fn COMPARE2(self) -> u8 {
                const OFFSET: u8 = 18;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 19) Write '1' to disable event routing for event COMPARE[3]"]
            pub fn COMPARE3(self) -> u8 {
                const OFFSET: u8 = 19;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u32 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "EVTENCLR {{ COMPARE3: {19}, COMPARE2: {18}, COMPARE1: {17}, COMPARE0: {16}, OVRFLW: {1}, TICK: {0} }}@4733751418947474743"]
                #[link_section = ".binfmt.EVTENCLR {{ COMPARE3: {19}, COMPARE2: {18}, COMPARE1: {17}, COMPARE0: {16}, OVRFLW: {1}, TICK: {0} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 0) Write '1' to disable event routing for event TICK"]
            #[allow(non_snake_case)]
            pub fn TICK(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 1) Write '1' to disable event routing for event OVRFLW"]
            #[allow(non_snake_case)]
            pub fn OVRFLW(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 1;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 16) Write '1' to disable event routing for event COMPARE[0]"]
            #[allow(non_snake_case)]
            pub fn COMPARE0(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 16;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 17) Write '1' to disable event routing for event COMPARE[1]"]
            #[allow(non_snake_case)]
            pub fn COMPARE1(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 17;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 18) Write '1' to disable event routing for event COMPARE[2]"]
            #[allow(non_snake_case)]
            pub fn COMPARE2(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 18;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 19) Write '1' to disable event routing for event COMPARE[3]"]
            #[allow(non_snake_case)]
            pub fn COMPARE3(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 19;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Current COUNTER value"]
    pub type COUNTER = counter::Register;
    #[doc = "Current COUNTER value"]
    pub mod counter {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *const u32 {
                (super::BASE_ADDRESS + 0x0504) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bits 0..=24) Counter value"]
            pub fn COUNTER(self) -> u32 {
                const OFFSET: u8 = 0;
                const MASK: u32 = 0x00ff_ffff;
                ((self.inner >> OFFSET) as u32) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u32 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "COUNTER {{ COUNTER: {0:24} }}@11325415408551321003"]
                #[link_section = ".binfmt.COUNTER {{ COUNTER: {0:24} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "12 bit prescaler for COUNTER frequency (32768/(PRESCALER+1)).Must be written when RTC is stopped"]
    pub type PRESCALER = prescaler::Register;
    #[doc = "12 bit prescaler for COUNTER frequency (32768/(PRESCALER+1)).Must be written when RTC is stopped"]
    pub mod prescaler {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0508) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bits 0..=12) Prescaler value"]
            pub fn PRESCALER(self) -> u16 {
                const OFFSET: u8 = 0;
                const MASK: u16 = 0x0fff;
                ((self.inner >> OFFSET) as u16) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u16 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "PRESCALER {{ PRESCALER: {0:12} }}@8702599051863277552"]
                #[link_section = ".binfmt.PRESCALER {{ PRESCALER: {0:12} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bits 0..=12) Prescaler value"]
            #[allow(non_snake_case)]
            pub fn PRESCALER(&mut self, val: u16) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u16 = 0x0fff;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Description collection: Compare register n"]
    pub type CC0 = cc0::Register;
    #[doc = "Description collection: Compare register n"]
    pub mod cc0 {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0540) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bits 0..=24) Compare value"]
            pub fn COMPARE(self) -> u32 {
                const OFFSET: u8 = 0;
                const MASK: u32 = 0x00ff_ffff;
                ((self.inner >> OFFSET) as u32) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u32 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "CC0 {{ COMPARE: {0:24} }}@18177324753411497868"]
                #[link_section = ".binfmt.CC0 {{ COMPARE: {0:24} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bits 0..=24) Compare value"]
            #[allow(non_snake_case)]
            pub fn COMPARE(&mut self, val: u32) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u32 = 0x00ff_ffff;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Description collection: Compare register n"]
    pub type CC1 = cc1::Register;
    #[doc = "Description collection: Compare register n"]
    pub mod cc1 {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0544) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bits 0..=24) Compare value"]
            pub fn COMPARE(self) -> u32 {
                const OFFSET: u8 = 0;
                const MASK: u32 = 0x00ff_ffff;
                ((self.inner >> OFFSET) as u32) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u32 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "CC1 {{ COMPARE: {0:24} }}@12637133393609260361"]
                #[link_section = ".binfmt.CC1 {{ COMPARE: {0:24} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bits 0..=24) Compare value"]
            #[allow(non_snake_case)]
            pub fn COMPARE(&mut self, val: u32) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u32 = 0x00ff_ffff;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Description collection: Compare register n"]
    pub type CC2 = cc2::Register;
    #[doc = "Description collection: Compare register n"]
    pub mod cc2 {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0548) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bits 0..=24) Compare value"]
            pub fn COMPARE(self) -> u32 {
                const OFFSET: u8 = 0;
                const MASK: u32 = 0x00ff_ffff;
                ((self.inner >> OFFSET) as u32) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u32 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "CC2 {{ COMPARE: {0:24} }}@8476086612368640514"]
                #[link_section = ".binfmt.CC2 {{ COMPARE: {0:24} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bits 0..=24) Compare value"]
            #[allow(non_snake_case)]
            pub fn COMPARE(&mut self, val: u32) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u32 = 0x00ff_ffff;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Description collection: Compare register n"]
    pub type CC3 = cc3::Register;
    #[doc = "Description collection: Compare register n"]
    pub mod cc3 {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x054c) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bits 0..=24) Compare value"]
            pub fn COMPARE(self) -> u32 {
                const OFFSET: u8 = 0;
                const MASK: u32 = 0x00ff_ffff;
                ((self.inner >> OFFSET) as u32) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u32 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "CC3 {{ COMPARE: {0:24} }}@5813831340047434773"]
                #[link_section = ".binfmt.CC3 {{ COMPARE: {0:24} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bits 0..=24) Compare value"]
            #[allow(non_snake_case)]
            pub fn COMPARE(&mut self, val: u32) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u32 = 0x00ff_ffff;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    use core::sync::atomic::{AtomicBool, Ordering};
    const BASE_ADDRESS: usize = 0x4000_b000;
    #[allow(non_snake_case)]
    #[doc = "Singleton handle to the RTC0 registers"]
    pub struct Registers {
        #[doc = "Start RTC COUNTER"]
        pub TASKS_START: TASKS_START,
        #[doc = "Stop RTC COUNTER"]
        pub TASKS_STOP: TASKS_STOP,
        #[doc = "Clear RTC COUNTER"]
        pub TASKS_CLEAR: TASKS_CLEAR,
        #[doc = "Set COUNTER to 0xFFFFF0"]
        pub TASKS_TRIGOVRFLW: TASKS_TRIGOVRFLW,
        #[doc = "Event on COUNTER increment"]
        pub EVENTS_TICK: EVENTS_TICK,
        #[doc = "Event on COUNTER overflow"]
        pub EVENTS_OVRFLW: EVENTS_OVRFLW,
        #[doc = "Description collection: Compare event on CC[n] match"]
        pub EVENTS_COMPARE0: EVENTS_COMPARE0,
        #[doc = "Description collection: Compare event on CC[n] match"]
        pub EVENTS_COMPARE1: EVENTS_COMPARE1,
        #[doc = "Description collection: Compare event on CC[n] match"]
        pub EVENTS_COMPARE2: EVENTS_COMPARE2,
        #[doc = "Description collection: Compare event on CC[n] match"]
        pub EVENTS_COMPARE3: EVENTS_COMPARE3,
        #[doc = "Enable interrupt"]
        pub INTENSET: INTENSET,
        #[doc = "Disable interrupt"]
        pub INTENCLR: INTENCLR,
        #[doc = "Enable or disable event routing"]
        pub EVTEN: EVTEN,
        #[doc = "Enable event routing"]
        pub EVTENSET: EVTENSET,
        #[doc = "Disable event routing"]
        pub EVTENCLR: EVTENCLR,
        #[doc = "Current COUNTER value"]
        pub COUNTER: COUNTER,
        #[doc = "12 bit prescaler for COUNTER frequency (32768/(PRESCALER+1)).Must be written when RTC is stopped"]
        pub PRESCALER: PRESCALER,
        #[doc = "Description collection: Compare register n"]
        pub CC0: CC0,
        #[doc = "Description collection: Compare register n"]
        pub CC1: CC1,
        #[doc = "Description collection: Compare register n"]
        pub CC2: CC2,
        #[doc = "Description collection: Compare register n"]
        pub CC3: CC3,
    }
    unsafe impl Send for Registers {}
    impl Registers {
        #[doc = r" # Safety"]
        #[doc = r" Singleton"]
        unsafe fn new() -> Self {
            Self {
                TASKS_START: TASKS_START::new(),
                TASKS_STOP: TASKS_STOP::new(),
                TASKS_CLEAR: TASKS_CLEAR::new(),
                TASKS_TRIGOVRFLW: TASKS_TRIGOVRFLW::new(),
                EVENTS_TICK: EVENTS_TICK::new(),
                EVENTS_OVRFLW: EVENTS_OVRFLW::new(),
                EVENTS_COMPARE0: EVENTS_COMPARE0::new(),
                EVENTS_COMPARE1: EVENTS_COMPARE1::new(),
                EVENTS_COMPARE2: EVENTS_COMPARE2::new(),
                EVENTS_COMPARE3: EVENTS_COMPARE3::new(),
                INTENSET: INTENSET::new(),
                INTENCLR: INTENCLR::new(),
                EVTEN: EVTEN::new(),
                EVTENSET: EVTENSET::new(),
                EVTENCLR: EVTENCLR::new(),
                COUNTER: COUNTER::new(),
                PRESCALER: PRESCALER::new(),
                CC0: CC0::new(),
                CC1: CC1::new(),
                CC2: CC2::new(),
                CC3: CC3::new(),
            }
        }
        fn taken() -> &'static AtomicBool {
            static TAKEN: AtomicBool = AtomicBool::new(false);
            &TAKEN
        }
        #[doc = r" Grants temporary access to the peripheral, without checking if it has already been"]
        #[doc = r" taken"]
        #[inline(always)]
        pub fn borrow_unchecked<T>(f: impl FnOnce(&Self) -> T) -> T {
            f(unsafe { &Self::new() })
        }
        #[doc = r" Seals the peripheral making it impossible to `take` it"]
        pub fn seal() {
            Self::taken().store(true, Ordering::Relaxed)
        }
        #[doc = r" Takes ownership of the peripheral"]
        #[doc = r""]
        #[doc = r" This constructor returns the `Some` variant only once"]
        pub fn take() -> Option<Self> {
            let taken = Self::taken();
            if taken
                .compare_exchange(false, true, Ordering::Relaxed, Ordering::Relaxed)
                .is_ok()
            {
                Some(unsafe { Self::new() })
            } else {
                None
            }
        }
    }
}
#[allow(non_camel_case_types)]
#[cfg(feature = "USBD")]
#[doc = "Universal serial bus device"]
pub type USBD = usbd::Registers;
#[cfg(feature = "USBD")]
#[doc = "Universal serial bus device"]
pub mod usbd {
    #[allow(non_camel_case_types)]
    #[doc = "Description collection: Captures the EPIN[n].PTR and EPIN[n].MAXCNT registers values, and enables endpoint IN n to respond to traffic from host"]
    pub type TASKS_STARTEPIN0 = tasks_startepin0::Register;
    #[doc = "Description collection: Captures the EPIN[n].PTR and EPIN[n].MAXCNT registers values, and enables endpoint IN n to respond to traffic from host"]
    pub mod tasks_startepin0 {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x04) as *mut _
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 0) Captures the EPIN[n].PTR and EPIN[n].MAXCNT registers values, and enables endpoint IN n to respond to traffic from host"]
            #[allow(non_snake_case)]
            pub fn TASKS_STARTEPIN(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Description collection: Captures the EPIN[n].PTR and EPIN[n].MAXCNT registers values, and enables endpoint IN n to respond to traffic from host"]
    pub type TASKS_STARTEPIN1 = tasks_startepin1::Register;
    #[doc = "Description collection: Captures the EPIN[n].PTR and EPIN[n].MAXCNT registers values, and enables endpoint IN n to respond to traffic from host"]
    pub mod tasks_startepin1 {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x08) as *mut _
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 0) Captures the EPIN[n].PTR and EPIN[n].MAXCNT registers values, and enables endpoint IN n to respond to traffic from host"]
            #[allow(non_snake_case)]
            pub fn TASKS_STARTEPIN(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Description collection: Captures the EPIN[n].PTR and EPIN[n].MAXCNT registers values, and enables endpoint IN n to respond to traffic from host"]
    pub type TASKS_STARTEPIN2 = tasks_startepin2::Register;
    #[doc = "Description collection: Captures the EPIN[n].PTR and EPIN[n].MAXCNT registers values, and enables endpoint IN n to respond to traffic from host"]
    pub mod tasks_startepin2 {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0c) as *mut _
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 0) Captures the EPIN[n].PTR and EPIN[n].MAXCNT registers values, and enables endpoint IN n to respond to traffic from host"]
            #[allow(non_snake_case)]
            pub fn TASKS_STARTEPIN(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Description collection: Captures the EPIN[n].PTR and EPIN[n].MAXCNT registers values, and enables endpoint IN n to respond to traffic from host"]
    pub type TASKS_STARTEPIN3 = tasks_startepin3::Register;
    #[doc = "Description collection: Captures the EPIN[n].PTR and EPIN[n].MAXCNT registers values, and enables endpoint IN n to respond to traffic from host"]
    pub mod tasks_startepin3 {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x10) as *mut _
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 0) Captures the EPIN[n].PTR and EPIN[n].MAXCNT registers values, and enables endpoint IN n to respond to traffic from host"]
            #[allow(non_snake_case)]
            pub fn TASKS_STARTEPIN(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Description collection: Captures the EPIN[n].PTR and EPIN[n].MAXCNT registers values, and enables endpoint IN n to respond to traffic from host"]
    pub type TASKS_STARTEPIN4 = tasks_startepin4::Register;
    #[doc = "Description collection: Captures the EPIN[n].PTR and EPIN[n].MAXCNT registers values, and enables endpoint IN n to respond to traffic from host"]
    pub mod tasks_startepin4 {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x14) as *mut _
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 0) Captures the EPIN[n].PTR and EPIN[n].MAXCNT registers values, and enables endpoint IN n to respond to traffic from host"]
            #[allow(non_snake_case)]
            pub fn TASKS_STARTEPIN(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Description collection: Captures the EPIN[n].PTR and EPIN[n].MAXCNT registers values, and enables endpoint IN n to respond to traffic from host"]
    pub type TASKS_STARTEPIN5 = tasks_startepin5::Register;
    #[doc = "Description collection: Captures the EPIN[n].PTR and EPIN[n].MAXCNT registers values, and enables endpoint IN n to respond to traffic from host"]
    pub mod tasks_startepin5 {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x18) as *mut _
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 0) Captures the EPIN[n].PTR and EPIN[n].MAXCNT registers values, and enables endpoint IN n to respond to traffic from host"]
            #[allow(non_snake_case)]
            pub fn TASKS_STARTEPIN(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Description collection: Captures the EPIN[n].PTR and EPIN[n].MAXCNT registers values, and enables endpoint IN n to respond to traffic from host"]
    pub type TASKS_STARTEPIN6 = tasks_startepin6::Register;
    #[doc = "Description collection: Captures the EPIN[n].PTR and EPIN[n].MAXCNT registers values, and enables endpoint IN n to respond to traffic from host"]
    pub mod tasks_startepin6 {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x1c) as *mut _
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 0) Captures the EPIN[n].PTR and EPIN[n].MAXCNT registers values, and enables endpoint IN n to respond to traffic from host"]
            #[allow(non_snake_case)]
            pub fn TASKS_STARTEPIN(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Description collection: Captures the EPIN[n].PTR and EPIN[n].MAXCNT registers values, and enables endpoint IN n to respond to traffic from host"]
    pub type TASKS_STARTEPIN7 = tasks_startepin7::Register;
    #[doc = "Description collection: Captures the EPIN[n].PTR and EPIN[n].MAXCNT registers values, and enables endpoint IN n to respond to traffic from host"]
    pub mod tasks_startepin7 {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x20) as *mut _
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 0) Captures the EPIN[n].PTR and EPIN[n].MAXCNT registers values, and enables endpoint IN n to respond to traffic from host"]
            #[allow(non_snake_case)]
            pub fn TASKS_STARTEPIN(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Captures the ISOIN.PTR and ISOIN.MAXCNT registers values, and enables sending data on ISO endpoint"]
    pub type TASKS_STARTISOIN = tasks_startisoin::Register;
    #[doc = "Captures the ISOIN.PTR and ISOIN.MAXCNT registers values, and enables sending data on ISO endpoint"]
    pub mod tasks_startisoin {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x24) as *mut _
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 0) Captures the ISOIN.PTR and ISOIN.MAXCNT registers values, and enables sending data on ISO endpoint"]
            #[allow(non_snake_case)]
            pub fn TASKS_STARTISOIN(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Description collection: Captures the EPOUT[n].PTR and EPOUT[n].MAXCNT registers values, and enables endpoint n to respond to traffic from host"]
    pub type TASKS_STARTEPOUT0 = tasks_startepout0::Register;
    #[doc = "Description collection: Captures the EPOUT[n].PTR and EPOUT[n].MAXCNT registers values, and enables endpoint n to respond to traffic from host"]
    pub mod tasks_startepout0 {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x28) as *mut _
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 0) Captures the EPOUT[n].PTR and EPOUT[n].MAXCNT registers values, and enables endpoint n to respond to traffic from host"]
            #[allow(non_snake_case)]
            pub fn TASKS_STARTEPOUT(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Description collection: Captures the EPOUT[n].PTR and EPOUT[n].MAXCNT registers values, and enables endpoint n to respond to traffic from host"]
    pub type TASKS_STARTEPOUT1 = tasks_startepout1::Register;
    #[doc = "Description collection: Captures the EPOUT[n].PTR and EPOUT[n].MAXCNT registers values, and enables endpoint n to respond to traffic from host"]
    pub mod tasks_startepout1 {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x2c) as *mut _
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 0) Captures the EPOUT[n].PTR and EPOUT[n].MAXCNT registers values, and enables endpoint n to respond to traffic from host"]
            #[allow(non_snake_case)]
            pub fn TASKS_STARTEPOUT(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Description collection: Captures the EPOUT[n].PTR and EPOUT[n].MAXCNT registers values, and enables endpoint n to respond to traffic from host"]
    pub type TASKS_STARTEPOUT2 = tasks_startepout2::Register;
    #[doc = "Description collection: Captures the EPOUT[n].PTR and EPOUT[n].MAXCNT registers values, and enables endpoint n to respond to traffic from host"]
    pub mod tasks_startepout2 {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x30) as *mut _
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 0) Captures the EPOUT[n].PTR and EPOUT[n].MAXCNT registers values, and enables endpoint n to respond to traffic from host"]
            #[allow(non_snake_case)]
            pub fn TASKS_STARTEPOUT(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Description collection: Captures the EPOUT[n].PTR and EPOUT[n].MAXCNT registers values, and enables endpoint n to respond to traffic from host"]
    pub type TASKS_STARTEPOUT3 = tasks_startepout3::Register;
    #[doc = "Description collection: Captures the EPOUT[n].PTR and EPOUT[n].MAXCNT registers values, and enables endpoint n to respond to traffic from host"]
    pub mod tasks_startepout3 {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x34) as *mut _
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 0) Captures the EPOUT[n].PTR and EPOUT[n].MAXCNT registers values, and enables endpoint n to respond to traffic from host"]
            #[allow(non_snake_case)]
            pub fn TASKS_STARTEPOUT(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Description collection: Captures the EPOUT[n].PTR and EPOUT[n].MAXCNT registers values, and enables endpoint n to respond to traffic from host"]
    pub type TASKS_STARTEPOUT4 = tasks_startepout4::Register;
    #[doc = "Description collection: Captures the EPOUT[n].PTR and EPOUT[n].MAXCNT registers values, and enables endpoint n to respond to traffic from host"]
    pub mod tasks_startepout4 {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x38) as *mut _
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 0) Captures the EPOUT[n].PTR and EPOUT[n].MAXCNT registers values, and enables endpoint n to respond to traffic from host"]
            #[allow(non_snake_case)]
            pub fn TASKS_STARTEPOUT(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Description collection: Captures the EPOUT[n].PTR and EPOUT[n].MAXCNT registers values, and enables endpoint n to respond to traffic from host"]
    pub type TASKS_STARTEPOUT5 = tasks_startepout5::Register;
    #[doc = "Description collection: Captures the EPOUT[n].PTR and EPOUT[n].MAXCNT registers values, and enables endpoint n to respond to traffic from host"]
    pub mod tasks_startepout5 {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x3c) as *mut _
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 0) Captures the EPOUT[n].PTR and EPOUT[n].MAXCNT registers values, and enables endpoint n to respond to traffic from host"]
            #[allow(non_snake_case)]
            pub fn TASKS_STARTEPOUT(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Description collection: Captures the EPOUT[n].PTR and EPOUT[n].MAXCNT registers values, and enables endpoint n to respond to traffic from host"]
    pub type TASKS_STARTEPOUT6 = tasks_startepout6::Register;
    #[doc = "Description collection: Captures the EPOUT[n].PTR and EPOUT[n].MAXCNT registers values, and enables endpoint n to respond to traffic from host"]
    pub mod tasks_startepout6 {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x40) as *mut _
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 0) Captures the EPOUT[n].PTR and EPOUT[n].MAXCNT registers values, and enables endpoint n to respond to traffic from host"]
            #[allow(non_snake_case)]
            pub fn TASKS_STARTEPOUT(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Description collection: Captures the EPOUT[n].PTR and EPOUT[n].MAXCNT registers values, and enables endpoint n to respond to traffic from host"]
    pub type TASKS_STARTEPOUT7 = tasks_startepout7::Register;
    #[doc = "Description collection: Captures the EPOUT[n].PTR and EPOUT[n].MAXCNT registers values, and enables endpoint n to respond to traffic from host"]
    pub mod tasks_startepout7 {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x44) as *mut _
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 0) Captures the EPOUT[n].PTR and EPOUT[n].MAXCNT registers values, and enables endpoint n to respond to traffic from host"]
            #[allow(non_snake_case)]
            pub fn TASKS_STARTEPOUT(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Captures the ISOOUT.PTR and ISOOUT.MAXCNT registers values, and enables receiving of data on ISO endpoint"]
    pub type TASKS_STARTISOOUT = tasks_startisoout::Register;
    #[doc = "Captures the ISOOUT.PTR and ISOOUT.MAXCNT registers values, and enables receiving of data on ISO endpoint"]
    pub mod tasks_startisoout {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x48) as *mut _
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 0) Captures the ISOOUT.PTR and ISOOUT.MAXCNT registers values, and enables receiving of data on ISO endpoint"]
            #[allow(non_snake_case)]
            pub fn TASKS_STARTISOOUT(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Allows OUT data stage on control endpoint 0"]
    pub type TASKS_EP0RCVOUT = tasks_ep0rcvout::Register;
    #[doc = "Allows OUT data stage on control endpoint 0"]
    pub mod tasks_ep0rcvout {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x4c) as *mut _
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 0) Allows OUT data stage on control endpoint 0"]
            #[allow(non_snake_case)]
            pub fn TASKS_EP0RCVOUT(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Allows status stage on control endpoint 0"]
    pub type TASKS_EP0STATUS = tasks_ep0status::Register;
    #[doc = "Allows status stage on control endpoint 0"]
    pub mod tasks_ep0status {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x50) as *mut _
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 0) Allows status stage on control endpoint 0"]
            #[allow(non_snake_case)]
            pub fn TASKS_EP0STATUS(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Stalls data and status stage on control endpoint 0"]
    pub type TASKS_EP0STALL = tasks_ep0stall::Register;
    #[doc = "Stalls data and status stage on control endpoint 0"]
    pub mod tasks_ep0stall {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x54) as *mut _
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 0) Stalls data and status stage on control endpoint 0"]
            #[allow(non_snake_case)]
            pub fn TASKS_EP0STALL(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Forces D+ and D- lines into the state defined in the DPDMVALUE register"]
    pub type TASKS_DPDMDRIVE = tasks_dpdmdrive::Register;
    #[doc = "Forces D+ and D- lines into the state defined in the DPDMVALUE register"]
    pub mod tasks_dpdmdrive {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x58) as *mut _
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 0) Forces D+ and D- lines into the state defined in the DPDMVALUE register"]
            #[allow(non_snake_case)]
            pub fn TASKS_DPDMDRIVE(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Stops forcing D+ and D- lines into any state (USB engine takes control)"]
    pub type TASKS_DPDMNODRIVE = tasks_dpdmnodrive::Register;
    #[doc = "Stops forcing D+ and D- lines into any state (USB engine takes control)"]
    pub mod tasks_dpdmnodrive {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x5c) as *mut _
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 0) Stops forcing D+ and D- lines into any state (USB engine takes control)"]
            #[allow(non_snake_case)]
            pub fn TASKS_DPDMNODRIVE(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Signals that a USB reset condition has been detected on USB lines"]
    pub type EVENTS_USBRESET = events_usbreset::Register;
    #[doc = "Signals that a USB reset condition has been detected on USB lines"]
    pub mod events_usbreset {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0100) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bit 0) Signals that a USB reset condition has been detected on USB lines"]
            pub fn EVENTS_USBRESET(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u8 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "EVENTS_USBRESET {{ EVENTS_USBRESET: {0} }}@15610836523092954497"]
                #[link_section = ".binfmt.EVENTS_USBRESET {{ EVENTS_USBRESET: {0} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 0) Signals that a USB reset condition has been detected on USB lines"]
            #[allow(non_snake_case)]
            pub fn EVENTS_USBRESET(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Confirms that the EPIN[n].PTR and EPIN[n].MAXCNT, or EPOUT[n].PTR and EPOUT[n].MAXCNT registers have been captured on all endpoints reported in the EPSTATUS register"]
    pub type EVENTS_STARTED = events_started::Register;
    #[doc = "Confirms that the EPIN[n].PTR and EPIN[n].MAXCNT, or EPOUT[n].PTR and EPOUT[n].MAXCNT registers have been captured on all endpoints reported in the EPSTATUS register"]
    pub mod events_started {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0104) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bit 0) Confirms that the EPIN[n].PTR and EPIN[n].MAXCNT, or EPOUT[n].PTR and EPOUT[n].MAXCNT registers have been captured on all endpoints reported in the EPSTATUS register"]
            pub fn EVENTS_STARTED(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u8 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "EVENTS_STARTED {{ EVENTS_STARTED: {0} }}@8937232980599393590"]
                #[link_section = ".binfmt.EVENTS_STARTED {{ EVENTS_STARTED: {0} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 0) Confirms that the EPIN[n].PTR and EPIN[n].MAXCNT, or EPOUT[n].PTR and EPOUT[n].MAXCNT registers have been captured on all endpoints reported in the EPSTATUS register"]
            #[allow(non_snake_case)]
            pub fn EVENTS_STARTED(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Description collection: The whole EPIN[n] buffer has been consumed. The buffer can be accessed safely by software."]
    pub type EVENTS_ENDEPIN0 = events_endepin0::Register;
    #[doc = "Description collection: The whole EPIN[n] buffer has been consumed. The buffer can be accessed safely by software."]
    pub mod events_endepin0 {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0108) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bit 0) The whole EPIN[n] buffer has been consumed. The buffer can be accessed safely by software."]
            pub fn EVENTS_ENDEPIN(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u8 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "EVENTS_ENDEPIN0 {{ EVENTS_ENDEPIN: {0} }}@1560763571394768463"]
                #[link_section = ".binfmt.EVENTS_ENDEPIN0 {{ EVENTS_ENDEPIN: {0} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 0) The whole EPIN[n] buffer has been consumed. The buffer can be accessed safely by software."]
            #[allow(non_snake_case)]
            pub fn EVENTS_ENDEPIN(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Description collection: The whole EPIN[n] buffer has been consumed. The buffer can be accessed safely by software."]
    pub type EVENTS_ENDEPIN1 = events_endepin1::Register;
    #[doc = "Description collection: The whole EPIN[n] buffer has been consumed. The buffer can be accessed safely by software."]
    pub mod events_endepin1 {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x010c) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bit 0) The whole EPIN[n] buffer has been consumed. The buffer can be accessed safely by software."]
            pub fn EVENTS_ENDEPIN(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u8 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "EVENTS_ENDEPIN1 {{ EVENTS_ENDEPIN: {0} }}@5431531344852216908"]
                #[link_section = ".binfmt.EVENTS_ENDEPIN1 {{ EVENTS_ENDEPIN: {0} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 0) The whole EPIN[n] buffer has been consumed. The buffer can be accessed safely by software."]
            #[allow(non_snake_case)]
            pub fn EVENTS_ENDEPIN(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Description collection: The whole EPIN[n] buffer has been consumed. The buffer can be accessed safely by software."]
    pub type EVENTS_ENDEPIN2 = events_endepin2::Register;
    #[doc = "Description collection: The whole EPIN[n] buffer has been consumed. The buffer can be accessed safely by software."]
    pub mod events_endepin2 {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0110) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bit 0) The whole EPIN[n] buffer has been consumed. The buffer can be accessed safely by software."]
            pub fn EVENTS_ENDEPIN(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u8 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "EVENTS_ENDEPIN2 {{ EVENTS_ENDEPIN: {0} }}@2674943498384579406"]
                #[link_section = ".binfmt.EVENTS_ENDEPIN2 {{ EVENTS_ENDEPIN: {0} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 0) The whole EPIN[n] buffer has been consumed. The buffer can be accessed safely by software."]
            #[allow(non_snake_case)]
            pub fn EVENTS_ENDEPIN(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Description collection: The whole EPIN[n] buffer has been consumed. The buffer can be accessed safely by software."]
    pub type EVENTS_ENDEPIN3 = events_endepin3::Register;
    #[doc = "Description collection: The whole EPIN[n] buffer has been consumed. The buffer can be accessed safely by software."]
    pub mod events_endepin3 {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0114) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bit 0) The whole EPIN[n] buffer has been consumed. The buffer can be accessed safely by software."]
            pub fn EVENTS_ENDEPIN(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u8 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "EVENTS_ENDEPIN3 {{ EVENTS_ENDEPIN: {0} }}@16208334974550996115"]
                #[link_section = ".binfmt.EVENTS_ENDEPIN3 {{ EVENTS_ENDEPIN: {0} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 0) The whole EPIN[n] buffer has been consumed. The buffer can be accessed safely by software."]
            #[allow(non_snake_case)]
            pub fn EVENTS_ENDEPIN(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Description collection: The whole EPIN[n] buffer has been consumed. The buffer can be accessed safely by software."]
    pub type EVENTS_ENDEPIN4 = events_endepin4::Register;
    #[doc = "Description collection: The whole EPIN[n] buffer has been consumed. The buffer can be accessed safely by software."]
    pub mod events_endepin4 {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0118) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bit 0) The whole EPIN[n] buffer has been consumed. The buffer can be accessed safely by software."]
            pub fn EVENTS_ENDEPIN(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u8 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "EVENTS_ENDEPIN4 {{ EVENTS_ENDEPIN: {0} }}@16726909134893894640"]
                #[link_section = ".binfmt.EVENTS_ENDEPIN4 {{ EVENTS_ENDEPIN: {0} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 0) The whole EPIN[n] buffer has been consumed. The buffer can be accessed safely by software."]
            #[allow(non_snake_case)]
            pub fn EVENTS_ENDEPIN(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Description collection: The whole EPIN[n] buffer has been consumed. The buffer can be accessed safely by software."]
    pub type EVENTS_ENDEPIN5 = events_endepin5::Register;
    #[doc = "Description collection: The whole EPIN[n] buffer has been consumed. The buffer can be accessed safely by software."]
    pub mod events_endepin5 {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x011c) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bit 0) The whole EPIN[n] buffer has been consumed. The buffer can be accessed safely by software."]
            pub fn EVENTS_ENDEPIN(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u8 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "EVENTS_ENDEPIN5 {{ EVENTS_ENDEPIN: {0} }}@17104457986916128967"]
                #[link_section = ".binfmt.EVENTS_ENDEPIN5 {{ EVENTS_ENDEPIN: {0} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 0) The whole EPIN[n] buffer has been consumed. The buffer can be accessed safely by software."]
            #[allow(non_snake_case)]
            pub fn EVENTS_ENDEPIN(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Description collection: The whole EPIN[n] buffer has been consumed. The buffer can be accessed safely by software."]
    pub type EVENTS_ENDEPIN6 = events_endepin6::Register;
    #[doc = "Description collection: The whole EPIN[n] buffer has been consumed. The buffer can be accessed safely by software."]
    pub mod events_endepin6 {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0120) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bit 0) The whole EPIN[n] buffer has been consumed. The buffer can be accessed safely by software."]
            pub fn EVENTS_ENDEPIN(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u8 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "EVENTS_ENDEPIN6 {{ EVENTS_ENDEPIN: {0} }}@10343743940281442938"]
                #[link_section = ".binfmt.EVENTS_ENDEPIN6 {{ EVENTS_ENDEPIN: {0} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 0) The whole EPIN[n] buffer has been consumed. The buffer can be accessed safely by software."]
            #[allow(non_snake_case)]
            pub fn EVENTS_ENDEPIN(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Description collection: The whole EPIN[n] buffer has been consumed. The buffer can be accessed safely by software."]
    pub type EVENTS_ENDEPIN7 = events_endepin7::Register;
    #[doc = "Description collection: The whole EPIN[n] buffer has been consumed. The buffer can be accessed safely by software."]
    pub mod events_endepin7 {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0124) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bit 0) The whole EPIN[n] buffer has been consumed. The buffer can be accessed safely by software."]
            pub fn EVENTS_ENDEPIN(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u8 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "EVENTS_ENDEPIN7 {{ EVENTS_ENDEPIN: {0} }}@4535486650697224665"]
                #[link_section = ".binfmt.EVENTS_ENDEPIN7 {{ EVENTS_ENDEPIN: {0} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 0) The whole EPIN[n] buffer has been consumed. The buffer can be accessed safely by software."]
            #[allow(non_snake_case)]
            pub fn EVENTS_ENDEPIN(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "An acknowledged data transfer has taken place on the control endpoint"]
    pub type EVENTS_EP0DATADONE = events_ep0datadone::Register;
    #[doc = "An acknowledged data transfer has taken place on the control endpoint"]
    pub mod events_ep0datadone {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0128) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bit 0) An acknowledged data transfer has taken place on the control endpoint"]
            pub fn EVENTS_EP0DATADONE(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u8 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "EVENTS_EP0DATADONE {{ EVENTS_EP0DATADONE: {0} }}@2487095069279042626"]
                #[link_section = ".binfmt.EVENTS_EP0DATADONE {{ EVENTS_EP0DATADONE: {0} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 0) An acknowledged data transfer has taken place on the control endpoint"]
            #[allow(non_snake_case)]
            pub fn EVENTS_EP0DATADONE(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "The whole ISOIN buffer has been consumed. The buffer can be accessed safely by software."]
    pub type EVENTS_ENDISOIN = events_endisoin::Register;
    #[doc = "The whole ISOIN buffer has been consumed. The buffer can be accessed safely by software."]
    pub mod events_endisoin {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x012c) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bit 0) The whole ISOIN buffer has been consumed. The buffer can be accessed safely by software."]
            pub fn EVENTS_ENDISOIN(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u8 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "EVENTS_ENDISOIN {{ EVENTS_ENDISOIN: {0} }}@1212362750942931225"]
                #[link_section = ".binfmt.EVENTS_ENDISOIN {{ EVENTS_ENDISOIN: {0} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 0) The whole ISOIN buffer has been consumed. The buffer can be accessed safely by software."]
            #[allow(non_snake_case)]
            pub fn EVENTS_ENDISOIN(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Description collection: The whole EPOUT[n] buffer has been consumed. The buffer can be accessed safely by software."]
    pub type EVENTS_ENDEPOUT0 = events_endepout0::Register;
    #[doc = "Description collection: The whole EPOUT[n] buffer has been consumed. The buffer can be accessed safely by software."]
    pub mod events_endepout0 {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0130) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bit 0) The whole EPOUT[n] buffer has been consumed. The buffer can be accessed safely by software."]
            pub fn EVENTS_ENDEPOUT(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u8 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "EVENTS_ENDEPOUT0 {{ EVENTS_ENDEPOUT: {0} }}@16661947233297195403"]
                #[link_section = ".binfmt.EVENTS_ENDEPOUT0 {{ EVENTS_ENDEPOUT: {0} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 0) The whole EPOUT[n] buffer has been consumed. The buffer can be accessed safely by software."]
            #[allow(non_snake_case)]
            pub fn EVENTS_ENDEPOUT(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Description collection: The whole EPOUT[n] buffer has been consumed. The buffer can be accessed safely by software."]
    pub type EVENTS_ENDEPOUT1 = events_endepout1::Register;
    #[doc = "Description collection: The whole EPOUT[n] buffer has been consumed. The buffer can be accessed safely by software."]
    pub mod events_endepout1 {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0134) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bit 0) The whole EPOUT[n] buffer has been consumed. The buffer can be accessed safely by software."]
            pub fn EVENTS_ENDEPOUT(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u8 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "EVENTS_ENDEPOUT1 {{ EVENTS_ENDEPOUT: {0} }}@4164545772303027173"]
                #[link_section = ".binfmt.EVENTS_ENDEPOUT1 {{ EVENTS_ENDEPOUT: {0} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 0) The whole EPOUT[n] buffer has been consumed. The buffer can be accessed safely by software."]
            #[allow(non_snake_case)]
            pub fn EVENTS_ENDEPOUT(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Description collection: The whole EPOUT[n] buffer has been consumed. The buffer can be accessed safely by software."]
    pub type EVENTS_ENDEPOUT2 = events_endepout2::Register;
    #[doc = "Description collection: The whole EPOUT[n] buffer has been consumed. The buffer can be accessed safely by software."]
    pub mod events_endepout2 {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0138) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bit 0) The whole EPOUT[n] buffer has been consumed. The buffer can be accessed safely by software."]
            pub fn EVENTS_ENDEPOUT(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u8 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "EVENTS_ENDEPOUT2 {{ EVENTS_ENDEPOUT: {0} }}@449639328297892315"]
                #[link_section = ".binfmt.EVENTS_ENDEPOUT2 {{ EVENTS_ENDEPOUT: {0} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 0) The whole EPOUT[n] buffer has been consumed. The buffer can be accessed safely by software."]
            #[allow(non_snake_case)]
            pub fn EVENTS_ENDEPOUT(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Description collection: The whole EPOUT[n] buffer has been consumed. The buffer can be accessed safely by software."]
    pub type EVENTS_ENDEPOUT3 = events_endepout3::Register;
    #[doc = "Description collection: The whole EPOUT[n] buffer has been consumed. The buffer can be accessed safely by software."]
    pub mod events_endepout3 {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x013c) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bit 0) The whole EPOUT[n] buffer has been consumed. The buffer can be accessed safely by software."]
            pub fn EVENTS_ENDEPOUT(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u8 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "EVENTS_ENDEPOUT3 {{ EVENTS_ENDEPOUT: {0} }}@347696261676725911"]
                #[link_section = ".binfmt.EVENTS_ENDEPOUT3 {{ EVENTS_ENDEPOUT: {0} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 0) The whole EPOUT[n] buffer has been consumed. The buffer can be accessed safely by software."]
            #[allow(non_snake_case)]
            pub fn EVENTS_ENDEPOUT(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Description collection: The whole EPOUT[n] buffer has been consumed. The buffer can be accessed safely by software."]
    pub type EVENTS_ENDEPOUT4 = events_endepout4::Register;
    #[doc = "Description collection: The whole EPOUT[n] buffer has been consumed. The buffer can be accessed safely by software."]
    pub mod events_endepout4 {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0140) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bit 0) The whole EPOUT[n] buffer has been consumed. The buffer can be accessed safely by software."]
            pub fn EVENTS_ENDEPOUT(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u8 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "EVENTS_ENDEPOUT4 {{ EVENTS_ENDEPOUT: {0} }}@4368969517313151432"]
                #[link_section = ".binfmt.EVENTS_ENDEPOUT4 {{ EVENTS_ENDEPOUT: {0} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 0) The whole EPOUT[n] buffer has been consumed. The buffer can be accessed safely by software."]
            #[allow(non_snake_case)]
            pub fn EVENTS_ENDEPOUT(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Description collection: The whole EPOUT[n] buffer has been consumed. The buffer can be accessed safely by software."]
    pub type EVENTS_ENDEPOUT5 = events_endepout5::Register;
    #[doc = "Description collection: The whole EPOUT[n] buffer has been consumed. The buffer can be accessed safely by software."]
    pub mod events_endepout5 {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0144) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bit 0) The whole EPOUT[n] buffer has been consumed. The buffer can be accessed safely by software."]
            pub fn EVENTS_ENDEPOUT(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u8 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "EVENTS_ENDEPOUT5 {{ EVENTS_ENDEPOUT: {0} }}@224735433417603053"]
                #[link_section = ".binfmt.EVENTS_ENDEPOUT5 {{ EVENTS_ENDEPOUT: {0} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 0) The whole EPOUT[n] buffer has been consumed. The buffer can be accessed safely by software."]
            #[allow(non_snake_case)]
            pub fn EVENTS_ENDEPOUT(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Description collection: The whole EPOUT[n] buffer has been consumed. The buffer can be accessed safely by software."]
    pub type EVENTS_ENDEPOUT6 = events_endepout6::Register;
    #[doc = "Description collection: The whole EPOUT[n] buffer has been consumed. The buffer can be accessed safely by software."]
    pub mod events_endepout6 {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0148) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bit 0) The whole EPOUT[n] buffer has been consumed. The buffer can be accessed safely by software."]
            pub fn EVENTS_ENDEPOUT(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u8 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "EVENTS_ENDEPOUT6 {{ EVENTS_ENDEPOUT: {0} }}@5557169280553484693"]
                #[link_section = ".binfmt.EVENTS_ENDEPOUT6 {{ EVENTS_ENDEPOUT: {0} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 0) The whole EPOUT[n] buffer has been consumed. The buffer can be accessed safely by software."]
            #[allow(non_snake_case)]
            pub fn EVENTS_ENDEPOUT(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Description collection: The whole EPOUT[n] buffer has been consumed. The buffer can be accessed safely by software."]
    pub type EVENTS_ENDEPOUT7 = events_endepout7::Register;
    #[doc = "Description collection: The whole EPOUT[n] buffer has been consumed. The buffer can be accessed safely by software."]
    pub mod events_endepout7 {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x014c) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bit 0) The whole EPOUT[n] buffer has been consumed. The buffer can be accessed safely by software."]
            pub fn EVENTS_ENDEPOUT(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u8 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "EVENTS_ENDEPOUT7 {{ EVENTS_ENDEPOUT: {0} }}@5019098557510331797"]
                #[link_section = ".binfmt.EVENTS_ENDEPOUT7 {{ EVENTS_ENDEPOUT: {0} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 0) The whole EPOUT[n] buffer has been consumed. The buffer can be accessed safely by software."]
            #[allow(non_snake_case)]
            pub fn EVENTS_ENDEPOUT(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "The whole ISOOUT buffer has been consumed. The buffer can be accessed safely by software."]
    pub type EVENTS_ENDISOOUT = events_endisoout::Register;
    #[doc = "The whole ISOOUT buffer has been consumed. The buffer can be accessed safely by software."]
    pub mod events_endisoout {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0150) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bit 0) The whole ISOOUT buffer has been consumed. The buffer can be accessed safely by software."]
            pub fn EVENTS_ENDISOOUT(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u8 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "EVENTS_ENDISOOUT {{ EVENTS_ENDISOOUT: {0} }}@6409526123823717507"]
                #[link_section = ".binfmt.EVENTS_ENDISOOUT {{ EVENTS_ENDISOOUT: {0} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 0) The whole ISOOUT buffer has been consumed. The buffer can be accessed safely by software."]
            #[allow(non_snake_case)]
            pub fn EVENTS_ENDISOOUT(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Signals that a SOF (start of frame) condition has been detected on USB lines"]
    pub type EVENTS_SOF = events_sof::Register;
    #[doc = "Signals that a SOF (start of frame) condition has been detected on USB lines"]
    pub mod events_sof {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0154) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bit 0) Signals that a SOF (start of frame) condition has been detected on USB lines"]
            pub fn EVENTS_SOF(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u8 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "EVENTS_SOF {{ EVENTS_SOF: {0} }}@3610199328181698562"]
                #[link_section = ".binfmt.EVENTS_SOF {{ EVENTS_SOF: {0} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 0) Signals that a SOF (start of frame) condition has been detected on USB lines"]
            #[allow(non_snake_case)]
            pub fn EVENTS_SOF(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "An event or an error not covered by specific events has occurred. Check EVENTCAUSE register to find the cause."]
    pub type EVENTS_USBEVENT = events_usbevent::Register;
    #[doc = "An event or an error not covered by specific events has occurred. Check EVENTCAUSE register to find the cause."]
    pub mod events_usbevent {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0158) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bit 0) An event or an error not covered by specific events has occurred. Check EVENTCAUSE register to find the cause."]
            pub fn EVENTS_USBEVENT(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u8 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "EVENTS_USBEVENT {{ EVENTS_USBEVENT: {0} }}@15294973441636089517"]
                #[link_section = ".binfmt.EVENTS_USBEVENT {{ EVENTS_USBEVENT: {0} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 0) An event or an error not covered by specific events has occurred. Check EVENTCAUSE register to find the cause."]
            #[allow(non_snake_case)]
            pub fn EVENTS_USBEVENT(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "A valid SETUP token has been received (and acknowledged) on the control endpoint"]
    pub type EVENTS_EP0SETUP = events_ep0setup::Register;
    #[doc = "A valid SETUP token has been received (and acknowledged) on the control endpoint"]
    pub mod events_ep0setup {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x015c) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bit 0) A valid SETUP token has been received (and acknowledged) on the control endpoint"]
            pub fn EVENTS_EP0SETUP(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u8 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "EVENTS_EP0SETUP {{ EVENTS_EP0SETUP: {0} }}@9556263168296090645"]
                #[link_section = ".binfmt.EVENTS_EP0SETUP {{ EVENTS_EP0SETUP: {0} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 0) A valid SETUP token has been received (and acknowledged) on the control endpoint"]
            #[allow(non_snake_case)]
            pub fn EVENTS_EP0SETUP(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "A data transfer has occurred on a data endpoint, indicated by the EPDATASTATUS register"]
    pub type EVENTS_EPDATA = events_epdata::Register;
    #[doc = "A data transfer has occurred on a data endpoint, indicated by the EPDATASTATUS register"]
    pub mod events_epdata {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0160) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bit 0) A data transfer has occurred on a data endpoint, indicated by the EPDATASTATUS register"]
            pub fn EVENTS_EPDATA(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u8 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "EVENTS_EPDATA {{ EVENTS_EPDATA: {0} }}@6157144554013940048"]
                #[link_section = ".binfmt.EVENTS_EPDATA {{ EVENTS_EPDATA: {0} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 0) A data transfer has occurred on a data endpoint, indicated by the EPDATASTATUS register"]
            #[allow(non_snake_case)]
            pub fn EVENTS_EPDATA(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Shortcuts between local events and tasks"]
    pub type SHORTS = shorts::Register;
    #[doc = "Shortcuts between local events and tasks"]
    pub mod shorts {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0200) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bit 0) Shortcut between event EP0DATADONE and task STARTEPIN[0]"]
            pub fn EP0DATADONE_STARTEPIN0(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 1) Shortcut between event EP0DATADONE and task STARTEPOUT[0]"]
            pub fn EP0DATADONE_STARTEPOUT0(self) -> u8 {
                const OFFSET: u8 = 1;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 2) Shortcut between event EP0DATADONE and task EP0STATUS"]
            pub fn EP0DATADONE_EP0STATUS(self) -> u8 {
                const OFFSET: u8 = 2;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 3) Shortcut between event ENDEPOUT[0] and task EP0STATUS"]
            pub fn ENDEPOUT0_EP0STATUS(self) -> u8 {
                const OFFSET: u8 = 3;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 4) Shortcut between event ENDEPOUT[0] and task EP0RCVOUT"]
            pub fn ENDEPOUT0_EP0RCVOUT(self) -> u8 {
                const OFFSET: u8 = 4;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u8 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "SHORTS {{ ENDEPOUT0_EP0RCVOUT: {4}, ENDEPOUT0_EP0STATUS: {3}, EP0DATADONE_EP0STATUS: {2}, EP0DATADONE_STARTEPOUT0: {1}, EP0DATADONE_STARTEPIN0: {0} }}@4422231335798850486"]
                #[link_section = ".binfmt.SHORTS {{ ENDEPOUT0_EP0RCVOUT: {4}, ENDEPOUT0_EP0STATUS: {3}, EP0DATADONE_EP0STATUS: {2}, EP0DATADONE_STARTEPOUT0: {1}, EP0DATADONE_STARTEPIN0: {0} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 0) Shortcut between event EP0DATADONE and task STARTEPIN[0]"]
            #[allow(non_snake_case)]
            pub fn EP0DATADONE_STARTEPIN0(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 1) Shortcut between event EP0DATADONE and task STARTEPOUT[0]"]
            #[allow(non_snake_case)]
            pub fn EP0DATADONE_STARTEPOUT0(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 1;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 2) Shortcut between event EP0DATADONE and task EP0STATUS"]
            #[allow(non_snake_case)]
            pub fn EP0DATADONE_EP0STATUS(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 2;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 3) Shortcut between event ENDEPOUT[0] and task EP0STATUS"]
            #[allow(non_snake_case)]
            pub fn ENDEPOUT0_EP0STATUS(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 3;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 4) Shortcut between event ENDEPOUT[0] and task EP0RCVOUT"]
            #[allow(non_snake_case)]
            pub fn ENDEPOUT0_EP0RCVOUT(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 4;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Enable or disable interrupt"]
    pub type INTEN = inten::Register;
    #[doc = "Enable or disable interrupt"]
    pub mod inten {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0300) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub unsafe fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub unsafe fn zero(&self) {
                {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub unsafe fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bit 0) Enable or disable interrupt for event USBRESET"]
            pub fn USBRESET(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 1) Enable or disable interrupt for event STARTED"]
            pub fn STARTED(self) -> u8 {
                const OFFSET: u8 = 1;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 2) Enable or disable interrupt for event ENDEPIN[0]"]
            pub fn ENDEPIN0(self) -> u8 {
                const OFFSET: u8 = 2;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 3) Enable or disable interrupt for event ENDEPIN[1]"]
            pub fn ENDEPIN1(self) -> u8 {
                const OFFSET: u8 = 3;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 4) Enable or disable interrupt for event ENDEPIN[2]"]
            pub fn ENDEPIN2(self) -> u8 {
                const OFFSET: u8 = 4;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 5) Enable or disable interrupt for event ENDEPIN[3]"]
            pub fn ENDEPIN3(self) -> u8 {
                const OFFSET: u8 = 5;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 6) Enable or disable interrupt for event ENDEPIN[4]"]
            pub fn ENDEPIN4(self) -> u8 {
                const OFFSET: u8 = 6;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 7) Enable or disable interrupt for event ENDEPIN[5]"]
            pub fn ENDEPIN5(self) -> u8 {
                const OFFSET: u8 = 7;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 8) Enable or disable interrupt for event ENDEPIN[6]"]
            pub fn ENDEPIN6(self) -> u8 {
                const OFFSET: u8 = 8;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 9) Enable or disable interrupt for event ENDEPIN[7]"]
            pub fn ENDEPIN7(self) -> u8 {
                const OFFSET: u8 = 9;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 10) Enable or disable interrupt for event EP0DATADONE"]
            pub fn EP0DATADONE(self) -> u8 {
                const OFFSET: u8 = 10;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 11) Enable or disable interrupt for event ENDISOIN"]
            pub fn ENDISOIN(self) -> u8 {
                const OFFSET: u8 = 11;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 12) Enable or disable interrupt for event ENDEPOUT[0]"]
            pub fn ENDEPOUT0(self) -> u8 {
                const OFFSET: u8 = 12;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 13) Enable or disable interrupt for event ENDEPOUT[1]"]
            pub fn ENDEPOUT1(self) -> u8 {
                const OFFSET: u8 = 13;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 14) Enable or disable interrupt for event ENDEPOUT[2]"]
            pub fn ENDEPOUT2(self) -> u8 {
                const OFFSET: u8 = 14;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 15) Enable or disable interrupt for event ENDEPOUT[3]"]
            pub fn ENDEPOUT3(self) -> u8 {
                const OFFSET: u8 = 15;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 16) Enable or disable interrupt for event ENDEPOUT[4]"]
            pub fn ENDEPOUT4(self) -> u8 {
                const OFFSET: u8 = 16;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 17) Enable or disable interrupt for event ENDEPOUT[5]"]
            pub fn ENDEPOUT5(self) -> u8 {
                const OFFSET: u8 = 17;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 18) Enable or disable interrupt for event ENDEPOUT[6]"]
            pub fn ENDEPOUT6(self) -> u8 {
                const OFFSET: u8 = 18;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 19) Enable or disable interrupt for event ENDEPOUT[7]"]
            pub fn ENDEPOUT7(self) -> u8 {
                const OFFSET: u8 = 19;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 20) Enable or disable interrupt for event ENDISOOUT"]
            pub fn ENDISOOUT(self) -> u8 {
                const OFFSET: u8 = 20;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 21) Enable or disable interrupt for event SOF"]
            pub fn SOF(self) -> u8 {
                const OFFSET: u8 = 21;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 22) Enable or disable interrupt for event USBEVENT"]
            pub fn USBEVENT(self) -> u8 {
                const OFFSET: u8 = 22;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 23) Enable or disable interrupt for event EP0SETUP"]
            pub fn EP0SETUP(self) -> u8 {
                const OFFSET: u8 = 23;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 24) Enable or disable interrupt for event EPDATA"]
            pub fn EPDATA(self) -> u8 {
                const OFFSET: u8 = 24;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u32 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "INTEN {{ EPDATA: {24}, EP0SETUP: {23}, USBEVENT: {22}, SOF: {21}, ENDISOOUT: {20}, ENDEPOUT7: {19}, ENDEPOUT6: {18}, ENDEPOUT5: {17}, ENDEPOUT4: {16}, ENDEPOUT3: {15}, ENDEPOUT2: {14}, ENDEPOUT1: {13}, ENDEPOUT0: {12}, ENDISOIN: {11}, EP0DATADONE: {10}, ENDEPIN7: {9}, ENDEPIN6: {8}, ENDEPIN5: {7}, ENDEPIN4: {6}, ENDEPIN3: {5}, ENDEPIN2: {4}, ENDEPIN1: {3}, ENDEPIN0: {2}, STARTED: {1}, USBRESET: {0} }}@12844530799376155866"]
                #[link_section = ".binfmt.INTEN {{ EPDATA: {24}, EP0SETUP: {23}, USBEVENT: {22}, SOF: {21}, ENDISOOUT: {20}, ENDEPOUT7: {19}, ENDEPOUT6: {18}, ENDEPOUT5: {17}, ENDEPOUT4: {16}, ENDEPOUT3: {15}, ENDEPOUT2: {14}, ENDEPOUT1: {13}, ENDEPOUT0: {12}, ENDISOIN: {11}, EP0DATADONE: {10}, ENDEPIN7: {9}, ENDEPIN6: {8}, ENDEPIN5: {7}, ENDEPIN4: {6}, ENDEPIN3: {5}, ENDEPIN2: {4}, ENDEPIN1: {3}, ENDEPIN0: {2}, STARTED: {1}, USBRESET: {0} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 0) Enable or disable interrupt for event USBRESET"]
            #[allow(non_snake_case)]
            pub fn USBRESET(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 1) Enable or disable interrupt for event STARTED"]
            #[allow(non_snake_case)]
            pub fn STARTED(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 1;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 2) Enable or disable interrupt for event ENDEPIN[0]"]
            #[allow(non_snake_case)]
            pub fn ENDEPIN0(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 2;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 3) Enable or disable interrupt for event ENDEPIN[1]"]
            #[allow(non_snake_case)]
            pub fn ENDEPIN1(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 3;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 4) Enable or disable interrupt for event ENDEPIN[2]"]
            #[allow(non_snake_case)]
            pub fn ENDEPIN2(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 4;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 5) Enable or disable interrupt for event ENDEPIN[3]"]
            #[allow(non_snake_case)]
            pub fn ENDEPIN3(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 5;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 6) Enable or disable interrupt for event ENDEPIN[4]"]
            #[allow(non_snake_case)]
            pub fn ENDEPIN4(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 6;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 7) Enable or disable interrupt for event ENDEPIN[5]"]
            #[allow(non_snake_case)]
            pub fn ENDEPIN5(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 7;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 8) Enable or disable interrupt for event ENDEPIN[6]"]
            #[allow(non_snake_case)]
            pub fn ENDEPIN6(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 8;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 9) Enable or disable interrupt for event ENDEPIN[7]"]
            #[allow(non_snake_case)]
            pub fn ENDEPIN7(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 9;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 10) Enable or disable interrupt for event EP0DATADONE"]
            #[allow(non_snake_case)]
            pub fn EP0DATADONE(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 10;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 11) Enable or disable interrupt for event ENDISOIN"]
            #[allow(non_snake_case)]
            pub fn ENDISOIN(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 11;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 12) Enable or disable interrupt for event ENDEPOUT[0]"]
            #[allow(non_snake_case)]
            pub fn ENDEPOUT0(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 12;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 13) Enable or disable interrupt for event ENDEPOUT[1]"]
            #[allow(non_snake_case)]
            pub fn ENDEPOUT1(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 13;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 14) Enable or disable interrupt for event ENDEPOUT[2]"]
            #[allow(non_snake_case)]
            pub fn ENDEPOUT2(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 14;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 15) Enable or disable interrupt for event ENDEPOUT[3]"]
            #[allow(non_snake_case)]
            pub fn ENDEPOUT3(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 15;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 16) Enable or disable interrupt for event ENDEPOUT[4]"]
            #[allow(non_snake_case)]
            pub fn ENDEPOUT4(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 16;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 17) Enable or disable interrupt for event ENDEPOUT[5]"]
            #[allow(non_snake_case)]
            pub fn ENDEPOUT5(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 17;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 18) Enable or disable interrupt for event ENDEPOUT[6]"]
            #[allow(non_snake_case)]
            pub fn ENDEPOUT6(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 18;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 19) Enable or disable interrupt for event ENDEPOUT[7]"]
            #[allow(non_snake_case)]
            pub fn ENDEPOUT7(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 19;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 20) Enable or disable interrupt for event ENDISOOUT"]
            #[allow(non_snake_case)]
            pub fn ENDISOOUT(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 20;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 21) Enable or disable interrupt for event SOF"]
            #[allow(non_snake_case)]
            pub fn SOF(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 21;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 22) Enable or disable interrupt for event USBEVENT"]
            #[allow(non_snake_case)]
            pub fn USBEVENT(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 22;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 23) Enable or disable interrupt for event EP0SETUP"]
            #[allow(non_snake_case)]
            pub fn EP0SETUP(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 23;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 24) Enable or disable interrupt for event EPDATA"]
            #[allow(non_snake_case)]
            pub fn EPDATA(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 24;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Enable interrupt"]
    pub type INTENSET = intenset::Register;
    #[doc = "Enable interrupt"]
    pub mod intenset {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0304) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub unsafe fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub unsafe fn zero(&self) {
                {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub unsafe fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bit 0) Write '1' to enable interrupt for event USBRESET"]
            pub fn USBRESET(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 1) Write '1' to enable interrupt for event STARTED"]
            pub fn STARTED(self) -> u8 {
                const OFFSET: u8 = 1;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 2) Write '1' to enable interrupt for event ENDEPIN[0]"]
            pub fn ENDEPIN0(self) -> u8 {
                const OFFSET: u8 = 2;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 3) Write '1' to enable interrupt for event ENDEPIN[1]"]
            pub fn ENDEPIN1(self) -> u8 {
                const OFFSET: u8 = 3;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 4) Write '1' to enable interrupt for event ENDEPIN[2]"]
            pub fn ENDEPIN2(self) -> u8 {
                const OFFSET: u8 = 4;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 5) Write '1' to enable interrupt for event ENDEPIN[3]"]
            pub fn ENDEPIN3(self) -> u8 {
                const OFFSET: u8 = 5;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 6) Write '1' to enable interrupt for event ENDEPIN[4]"]
            pub fn ENDEPIN4(self) -> u8 {
                const OFFSET: u8 = 6;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 7) Write '1' to enable interrupt for event ENDEPIN[5]"]
            pub fn ENDEPIN5(self) -> u8 {
                const OFFSET: u8 = 7;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 8) Write '1' to enable interrupt for event ENDEPIN[6]"]
            pub fn ENDEPIN6(self) -> u8 {
                const OFFSET: u8 = 8;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 9) Write '1' to enable interrupt for event ENDEPIN[7]"]
            pub fn ENDEPIN7(self) -> u8 {
                const OFFSET: u8 = 9;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 10) Write '1' to enable interrupt for event EP0DATADONE"]
            pub fn EP0DATADONE(self) -> u8 {
                const OFFSET: u8 = 10;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 11) Write '1' to enable interrupt for event ENDISOIN"]
            pub fn ENDISOIN(self) -> u8 {
                const OFFSET: u8 = 11;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 12) Write '1' to enable interrupt for event ENDEPOUT[0]"]
            pub fn ENDEPOUT0(self) -> u8 {
                const OFFSET: u8 = 12;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 13) Write '1' to enable interrupt for event ENDEPOUT[1]"]
            pub fn ENDEPOUT1(self) -> u8 {
                const OFFSET: u8 = 13;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 14) Write '1' to enable interrupt for event ENDEPOUT[2]"]
            pub fn ENDEPOUT2(self) -> u8 {
                const OFFSET: u8 = 14;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 15) Write '1' to enable interrupt for event ENDEPOUT[3]"]
            pub fn ENDEPOUT3(self) -> u8 {
                const OFFSET: u8 = 15;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 16) Write '1' to enable interrupt for event ENDEPOUT[4]"]
            pub fn ENDEPOUT4(self) -> u8 {
                const OFFSET: u8 = 16;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 17) Write '1' to enable interrupt for event ENDEPOUT[5]"]
            pub fn ENDEPOUT5(self) -> u8 {
                const OFFSET: u8 = 17;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 18) Write '1' to enable interrupt for event ENDEPOUT[6]"]
            pub fn ENDEPOUT6(self) -> u8 {
                const OFFSET: u8 = 18;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 19) Write '1' to enable interrupt for event ENDEPOUT[7]"]
            pub fn ENDEPOUT7(self) -> u8 {
                const OFFSET: u8 = 19;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 20) Write '1' to enable interrupt for event ENDISOOUT"]
            pub fn ENDISOOUT(self) -> u8 {
                const OFFSET: u8 = 20;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 21) Write '1' to enable interrupt for event SOF"]
            pub fn SOF(self) -> u8 {
                const OFFSET: u8 = 21;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 22) Write '1' to enable interrupt for event USBEVENT"]
            pub fn USBEVENT(self) -> u8 {
                const OFFSET: u8 = 22;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 23) Write '1' to enable interrupt for event EP0SETUP"]
            pub fn EP0SETUP(self) -> u8 {
                const OFFSET: u8 = 23;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 24) Write '1' to enable interrupt for event EPDATA"]
            pub fn EPDATA(self) -> u8 {
                const OFFSET: u8 = 24;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u32 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "INTENSET {{ EPDATA: {24}, EP0SETUP: {23}, USBEVENT: {22}, SOF: {21}, ENDISOOUT: {20}, ENDEPOUT7: {19}, ENDEPOUT6: {18}, ENDEPOUT5: {17}, ENDEPOUT4: {16}, ENDEPOUT3: {15}, ENDEPOUT2: {14}, ENDEPOUT1: {13}, ENDEPOUT0: {12}, ENDISOIN: {11}, EP0DATADONE: {10}, ENDEPIN7: {9}, ENDEPIN6: {8}, ENDEPIN5: {7}, ENDEPIN4: {6}, ENDEPIN3: {5}, ENDEPIN2: {4}, ENDEPIN1: {3}, ENDEPIN0: {2}, STARTED: {1}, USBRESET: {0} }}@1593392399044308152"]
                #[link_section = ".binfmt.INTENSET {{ EPDATA: {24}, EP0SETUP: {23}, USBEVENT: {22}, SOF: {21}, ENDISOOUT: {20}, ENDEPOUT7: {19}, ENDEPOUT6: {18}, ENDEPOUT5: {17}, ENDEPOUT4: {16}, ENDEPOUT3: {15}, ENDEPOUT2: {14}, ENDEPOUT1: {13}, ENDEPOUT0: {12}, ENDISOIN: {11}, EP0DATADONE: {10}, ENDEPIN7: {9}, ENDEPIN6: {8}, ENDEPIN5: {7}, ENDEPIN4: {6}, ENDEPIN3: {5}, ENDEPIN2: {4}, ENDEPIN1: {3}, ENDEPIN0: {2}, STARTED: {1}, USBRESET: {0} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 0) Write '1' to enable interrupt for event USBRESET"]
            #[allow(non_snake_case)]
            pub fn USBRESET(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 1) Write '1' to enable interrupt for event STARTED"]
            #[allow(non_snake_case)]
            pub fn STARTED(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 1;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 2) Write '1' to enable interrupt for event ENDEPIN[0]"]
            #[allow(non_snake_case)]
            pub fn ENDEPIN0(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 2;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 3) Write '1' to enable interrupt for event ENDEPIN[1]"]
            #[allow(non_snake_case)]
            pub fn ENDEPIN1(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 3;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 4) Write '1' to enable interrupt for event ENDEPIN[2]"]
            #[allow(non_snake_case)]
            pub fn ENDEPIN2(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 4;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 5) Write '1' to enable interrupt for event ENDEPIN[3]"]
            #[allow(non_snake_case)]
            pub fn ENDEPIN3(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 5;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 6) Write '1' to enable interrupt for event ENDEPIN[4]"]
            #[allow(non_snake_case)]
            pub fn ENDEPIN4(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 6;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 7) Write '1' to enable interrupt for event ENDEPIN[5]"]
            #[allow(non_snake_case)]
            pub fn ENDEPIN5(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 7;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 8) Write '1' to enable interrupt for event ENDEPIN[6]"]
            #[allow(non_snake_case)]
            pub fn ENDEPIN6(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 8;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 9) Write '1' to enable interrupt for event ENDEPIN[7]"]
            #[allow(non_snake_case)]
            pub fn ENDEPIN7(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 9;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 10) Write '1' to enable interrupt for event EP0DATADONE"]
            #[allow(non_snake_case)]
            pub fn EP0DATADONE(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 10;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 11) Write '1' to enable interrupt for event ENDISOIN"]
            #[allow(non_snake_case)]
            pub fn ENDISOIN(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 11;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 12) Write '1' to enable interrupt for event ENDEPOUT[0]"]
            #[allow(non_snake_case)]
            pub fn ENDEPOUT0(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 12;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 13) Write '1' to enable interrupt for event ENDEPOUT[1]"]
            #[allow(non_snake_case)]
            pub fn ENDEPOUT1(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 13;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 14) Write '1' to enable interrupt for event ENDEPOUT[2]"]
            #[allow(non_snake_case)]
            pub fn ENDEPOUT2(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 14;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 15) Write '1' to enable interrupt for event ENDEPOUT[3]"]
            #[allow(non_snake_case)]
            pub fn ENDEPOUT3(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 15;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 16) Write '1' to enable interrupt for event ENDEPOUT[4]"]
            #[allow(non_snake_case)]
            pub fn ENDEPOUT4(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 16;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 17) Write '1' to enable interrupt for event ENDEPOUT[5]"]
            #[allow(non_snake_case)]
            pub fn ENDEPOUT5(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 17;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 18) Write '1' to enable interrupt for event ENDEPOUT[6]"]
            #[allow(non_snake_case)]
            pub fn ENDEPOUT6(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 18;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 19) Write '1' to enable interrupt for event ENDEPOUT[7]"]
            #[allow(non_snake_case)]
            pub fn ENDEPOUT7(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 19;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 20) Write '1' to enable interrupt for event ENDISOOUT"]
            #[allow(non_snake_case)]
            pub fn ENDISOOUT(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 20;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 21) Write '1' to enable interrupt for event SOF"]
            #[allow(non_snake_case)]
            pub fn SOF(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 21;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 22) Write '1' to enable interrupt for event USBEVENT"]
            #[allow(non_snake_case)]
            pub fn USBEVENT(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 22;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 23) Write '1' to enable interrupt for event EP0SETUP"]
            #[allow(non_snake_case)]
            pub fn EP0SETUP(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 23;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 24) Write '1' to enable interrupt for event EPDATA"]
            #[allow(non_snake_case)]
            pub fn EPDATA(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 24;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Disable interrupt"]
    pub type INTENCLR = intenclr::Register;
    #[doc = "Disable interrupt"]
    pub mod intenclr {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0308) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bit 0) Write '1' to disable interrupt for event USBRESET"]
            pub fn USBRESET(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 1) Write '1' to disable interrupt for event STARTED"]
            pub fn STARTED(self) -> u8 {
                const OFFSET: u8 = 1;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 2) Write '1' to disable interrupt for event ENDEPIN[0]"]
            pub fn ENDEPIN0(self) -> u8 {
                const OFFSET: u8 = 2;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 3) Write '1' to disable interrupt for event ENDEPIN[1]"]
            pub fn ENDEPIN1(self) -> u8 {
                const OFFSET: u8 = 3;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 4) Write '1' to disable interrupt for event ENDEPIN[2]"]
            pub fn ENDEPIN2(self) -> u8 {
                const OFFSET: u8 = 4;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 5) Write '1' to disable interrupt for event ENDEPIN[3]"]
            pub fn ENDEPIN3(self) -> u8 {
                const OFFSET: u8 = 5;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 6) Write '1' to disable interrupt for event ENDEPIN[4]"]
            pub fn ENDEPIN4(self) -> u8 {
                const OFFSET: u8 = 6;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 7) Write '1' to disable interrupt for event ENDEPIN[5]"]
            pub fn ENDEPIN5(self) -> u8 {
                const OFFSET: u8 = 7;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 8) Write '1' to disable interrupt for event ENDEPIN[6]"]
            pub fn ENDEPIN6(self) -> u8 {
                const OFFSET: u8 = 8;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 9) Write '1' to disable interrupt for event ENDEPIN[7]"]
            pub fn ENDEPIN7(self) -> u8 {
                const OFFSET: u8 = 9;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 10) Write '1' to disable interrupt for event EP0DATADONE"]
            pub fn EP0DATADONE(self) -> u8 {
                const OFFSET: u8 = 10;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 11) Write '1' to disable interrupt for event ENDISOIN"]
            pub fn ENDISOIN(self) -> u8 {
                const OFFSET: u8 = 11;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 12) Write '1' to disable interrupt for event ENDEPOUT[0]"]
            pub fn ENDEPOUT0(self) -> u8 {
                const OFFSET: u8 = 12;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 13) Write '1' to disable interrupt for event ENDEPOUT[1]"]
            pub fn ENDEPOUT1(self) -> u8 {
                const OFFSET: u8 = 13;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 14) Write '1' to disable interrupt for event ENDEPOUT[2]"]
            pub fn ENDEPOUT2(self) -> u8 {
                const OFFSET: u8 = 14;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 15) Write '1' to disable interrupt for event ENDEPOUT[3]"]
            pub fn ENDEPOUT3(self) -> u8 {
                const OFFSET: u8 = 15;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 16) Write '1' to disable interrupt for event ENDEPOUT[4]"]
            pub fn ENDEPOUT4(self) -> u8 {
                const OFFSET: u8 = 16;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 17) Write '1' to disable interrupt for event ENDEPOUT[5]"]
            pub fn ENDEPOUT5(self) -> u8 {
                const OFFSET: u8 = 17;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 18) Write '1' to disable interrupt for event ENDEPOUT[6]"]
            pub fn ENDEPOUT6(self) -> u8 {
                const OFFSET: u8 = 18;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 19) Write '1' to disable interrupt for event ENDEPOUT[7]"]
            pub fn ENDEPOUT7(self) -> u8 {
                const OFFSET: u8 = 19;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 20) Write '1' to disable interrupt for event ENDISOOUT"]
            pub fn ENDISOOUT(self) -> u8 {
                const OFFSET: u8 = 20;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 21) Write '1' to disable interrupt for event SOF"]
            pub fn SOF(self) -> u8 {
                const OFFSET: u8 = 21;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 22) Write '1' to disable interrupt for event USBEVENT"]
            pub fn USBEVENT(self) -> u8 {
                const OFFSET: u8 = 22;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 23) Write '1' to disable interrupt for event EP0SETUP"]
            pub fn EP0SETUP(self) -> u8 {
                const OFFSET: u8 = 23;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 24) Write '1' to disable interrupt for event EPDATA"]
            pub fn EPDATA(self) -> u8 {
                const OFFSET: u8 = 24;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u32 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "INTENCLR {{ EPDATA: {24}, EP0SETUP: {23}, USBEVENT: {22}, SOF: {21}, ENDISOOUT: {20}, ENDEPOUT7: {19}, ENDEPOUT6: {18}, ENDEPOUT5: {17}, ENDEPOUT4: {16}, ENDEPOUT3: {15}, ENDEPOUT2: {14}, ENDEPOUT1: {13}, ENDEPOUT0: {12}, ENDISOIN: {11}, EP0DATADONE: {10}, ENDEPIN7: {9}, ENDEPIN6: {8}, ENDEPIN5: {7}, ENDEPIN4: {6}, ENDEPIN3: {5}, ENDEPIN2: {4}, ENDEPIN1: {3}, ENDEPIN0: {2}, STARTED: {1}, USBRESET: {0} }}@15731808476548172924"]
                #[link_section = ".binfmt.INTENCLR {{ EPDATA: {24}, EP0SETUP: {23}, USBEVENT: {22}, SOF: {21}, ENDISOOUT: {20}, ENDEPOUT7: {19}, ENDEPOUT6: {18}, ENDEPOUT5: {17}, ENDEPOUT4: {16}, ENDEPOUT3: {15}, ENDEPOUT2: {14}, ENDEPOUT1: {13}, ENDEPOUT0: {12}, ENDISOIN: {11}, EP0DATADONE: {10}, ENDEPIN7: {9}, ENDEPIN6: {8}, ENDEPIN5: {7}, ENDEPIN4: {6}, ENDEPIN3: {5}, ENDEPIN2: {4}, ENDEPIN1: {3}, ENDEPIN0: {2}, STARTED: {1}, USBRESET: {0} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 0) Write '1' to disable interrupt for event USBRESET"]
            #[allow(non_snake_case)]
            pub fn USBRESET(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 1) Write '1' to disable interrupt for event STARTED"]
            #[allow(non_snake_case)]
            pub fn STARTED(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 1;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 2) Write '1' to disable interrupt for event ENDEPIN[0]"]
            #[allow(non_snake_case)]
            pub fn ENDEPIN0(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 2;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 3) Write '1' to disable interrupt for event ENDEPIN[1]"]
            #[allow(non_snake_case)]
            pub fn ENDEPIN1(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 3;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 4) Write '1' to disable interrupt for event ENDEPIN[2]"]
            #[allow(non_snake_case)]
            pub fn ENDEPIN2(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 4;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 5) Write '1' to disable interrupt for event ENDEPIN[3]"]
            #[allow(non_snake_case)]
            pub fn ENDEPIN3(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 5;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 6) Write '1' to disable interrupt for event ENDEPIN[4]"]
            #[allow(non_snake_case)]
            pub fn ENDEPIN4(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 6;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 7) Write '1' to disable interrupt for event ENDEPIN[5]"]
            #[allow(non_snake_case)]
            pub fn ENDEPIN5(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 7;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 8) Write '1' to disable interrupt for event ENDEPIN[6]"]
            #[allow(non_snake_case)]
            pub fn ENDEPIN6(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 8;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 9) Write '1' to disable interrupt for event ENDEPIN[7]"]
            #[allow(non_snake_case)]
            pub fn ENDEPIN7(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 9;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 10) Write '1' to disable interrupt for event EP0DATADONE"]
            #[allow(non_snake_case)]
            pub fn EP0DATADONE(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 10;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 11) Write '1' to disable interrupt for event ENDISOIN"]
            #[allow(non_snake_case)]
            pub fn ENDISOIN(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 11;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 12) Write '1' to disable interrupt for event ENDEPOUT[0]"]
            #[allow(non_snake_case)]
            pub fn ENDEPOUT0(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 12;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 13) Write '1' to disable interrupt for event ENDEPOUT[1]"]
            #[allow(non_snake_case)]
            pub fn ENDEPOUT1(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 13;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 14) Write '1' to disable interrupt for event ENDEPOUT[2]"]
            #[allow(non_snake_case)]
            pub fn ENDEPOUT2(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 14;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 15) Write '1' to disable interrupt for event ENDEPOUT[3]"]
            #[allow(non_snake_case)]
            pub fn ENDEPOUT3(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 15;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 16) Write '1' to disable interrupt for event ENDEPOUT[4]"]
            #[allow(non_snake_case)]
            pub fn ENDEPOUT4(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 16;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 17) Write '1' to disable interrupt for event ENDEPOUT[5]"]
            #[allow(non_snake_case)]
            pub fn ENDEPOUT5(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 17;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 18) Write '1' to disable interrupt for event ENDEPOUT[6]"]
            #[allow(non_snake_case)]
            pub fn ENDEPOUT6(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 18;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 19) Write '1' to disable interrupt for event ENDEPOUT[7]"]
            #[allow(non_snake_case)]
            pub fn ENDEPOUT7(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 19;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 20) Write '1' to disable interrupt for event ENDISOOUT"]
            #[allow(non_snake_case)]
            pub fn ENDISOOUT(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 20;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 21) Write '1' to disable interrupt for event SOF"]
            #[allow(non_snake_case)]
            pub fn SOF(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 21;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 22) Write '1' to disable interrupt for event USBEVENT"]
            #[allow(non_snake_case)]
            pub fn USBEVENT(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 22;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 23) Write '1' to disable interrupt for event EP0SETUP"]
            #[allow(non_snake_case)]
            pub fn EP0SETUP(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 23;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 24) Write '1' to disable interrupt for event EPDATA"]
            #[allow(non_snake_case)]
            pub fn EPDATA(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 24;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Details on what caused the USBEVENT event"]
    pub type EVENTCAUSE = eventcause::Register;
    #[doc = "Details on what caused the USBEVENT event"]
    pub mod eventcause {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0400) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bit 0) CRC error was detected on isochronous OUT endpoint 8. Write '1' to clear."]
            pub fn ISOOUTCRC(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 8) Signals that USB lines have been idle long enough for the device to enter suspend. Write '1' to clear."]
            pub fn SUSPEND(self) -> u8 {
                const OFFSET: u8 = 8;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 9) Signals that a RESUME condition (K state or activity restart) has been detected on USB lines. Write '1' to clear."]
            pub fn RESUME(self) -> u8 {
                const OFFSET: u8 = 9;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 10) USB MAC has been woken up and operational. Write '1' to clear."]
            pub fn USBWUALLOWED(self) -> u8 {
                const OFFSET: u8 = 10;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 11) USB device is ready for normal operation. Write '1' to clear."]
            pub fn READY(self) -> u8 {
                const OFFSET: u8 = 11;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u16 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "EVENTCAUSE {{ READY: {11}, USBWUALLOWED: {10}, RESUME: {9}, SUSPEND: {8}, ISOOUTCRC: {0} }}@5296418153436486059"]
                #[link_section = ".binfmt.EVENTCAUSE {{ READY: {11}, USBWUALLOWED: {10}, RESUME: {9}, SUSPEND: {8}, ISOOUTCRC: {0} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 0) CRC error was detected on isochronous OUT endpoint 8. Write '1' to clear."]
            #[allow(non_snake_case)]
            pub fn ISOOUTCRC(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 8) Signals that USB lines have been idle long enough for the device to enter suspend. Write '1' to clear."]
            #[allow(non_snake_case)]
            pub fn SUSPEND(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 8;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 9) Signals that a RESUME condition (K state or activity restart) has been detected on USB lines. Write '1' to clear."]
            #[allow(non_snake_case)]
            pub fn RESUME(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 9;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 10) USB MAC has been woken up and operational. Write '1' to clear."]
            #[allow(non_snake_case)]
            pub fn USBWUALLOWED(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 10;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 11) USB device is ready for normal operation. Write '1' to clear."]
            #[allow(non_snake_case)]
            pub fn READY(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 11;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Description collection: IN endpoint halted status. Can be used as is as response to a GetStatus() request to endpoint."]
    pub type HALTED_EPIN0 = halted_epin0::Register;
    #[doc = "Description collection: IN endpoint halted status. Can be used as is as response to a GetStatus() request to endpoint."]
    pub mod halted_epin0 {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *const u32 {
                (super::BASE_ADDRESS + 0x0420) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bits 0..=16) IN endpoint halted status. Can be used as is as response to a GetStatus() request to endpoint."]
            pub fn GETSTATUS(self) -> u16 {
                const OFFSET: u8 = 0;
                const MASK: u16 = 0xffff;
                ((self.inner >> OFFSET) as u16) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u16 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "HALTED_EPIN0 {{ GETSTATUS: {0:16} }}@8665364427773447327"]
                #[link_section = ".binfmt.HALTED_EPIN0 {{ GETSTATUS: {0:16} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Description collection: IN endpoint halted status. Can be used as is as response to a GetStatus() request to endpoint."]
    pub type HALTED_EPIN1 = halted_epin1::Register;
    #[doc = "Description collection: IN endpoint halted status. Can be used as is as response to a GetStatus() request to endpoint."]
    pub mod halted_epin1 {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *const u32 {
                (super::BASE_ADDRESS + 0x0424) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bits 0..=16) IN endpoint halted status. Can be used as is as response to a GetStatus() request to endpoint."]
            pub fn GETSTATUS(self) -> u16 {
                const OFFSET: u8 = 0;
                const MASK: u16 = 0xffff;
                ((self.inner >> OFFSET) as u16) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u16 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "HALTED_EPIN1 {{ GETSTATUS: {0:16} }}@10746439397255581675"]
                #[link_section = ".binfmt.HALTED_EPIN1 {{ GETSTATUS: {0:16} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Description collection: IN endpoint halted status. Can be used as is as response to a GetStatus() request to endpoint."]
    pub type HALTED_EPIN2 = halted_epin2::Register;
    #[doc = "Description collection: IN endpoint halted status. Can be used as is as response to a GetStatus() request to endpoint."]
    pub mod halted_epin2 {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *const u32 {
                (super::BASE_ADDRESS + 0x0428) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bits 0..=16) IN endpoint halted status. Can be used as is as response to a GetStatus() request to endpoint."]
            pub fn GETSTATUS(self) -> u16 {
                const OFFSET: u8 = 0;
                const MASK: u16 = 0xffff;
                ((self.inner >> OFFSET) as u16) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u16 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "HALTED_EPIN2 {{ GETSTATUS: {0:16} }}@2842560639522519422"]
                #[link_section = ".binfmt.HALTED_EPIN2 {{ GETSTATUS: {0:16} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Description collection: IN endpoint halted status. Can be used as is as response to a GetStatus() request to endpoint."]
    pub type HALTED_EPIN3 = halted_epin3::Register;
    #[doc = "Description collection: IN endpoint halted status. Can be used as is as response to a GetStatus() request to endpoint."]
    pub mod halted_epin3 {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *const u32 {
                (super::BASE_ADDRESS + 0x042c) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bits 0..=16) IN endpoint halted status. Can be used as is as response to a GetStatus() request to endpoint."]
            pub fn GETSTATUS(self) -> u16 {
                const OFFSET: u8 = 0;
                const MASK: u16 = 0xffff;
                ((self.inner >> OFFSET) as u16) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u16 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "HALTED_EPIN3 {{ GETSTATUS: {0:16} }}@544193902275383045"]
                #[link_section = ".binfmt.HALTED_EPIN3 {{ GETSTATUS: {0:16} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Description collection: IN endpoint halted status. Can be used as is as response to a GetStatus() request to endpoint."]
    pub type HALTED_EPIN4 = halted_epin4::Register;
    #[doc = "Description collection: IN endpoint halted status. Can be used as is as response to a GetStatus() request to endpoint."]
    pub mod halted_epin4 {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *const u32 {
                (super::BASE_ADDRESS + 0x0430) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bits 0..=16) IN endpoint halted status. Can be used as is as response to a GetStatus() request to endpoint."]
            pub fn GETSTATUS(self) -> u16 {
                const OFFSET: u8 = 0;
                const MASK: u16 = 0xffff;
                ((self.inner >> OFFSET) as u16) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u16 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "HALTED_EPIN4 {{ GETSTATUS: {0:16} }}@2053109432578170942"]
                #[link_section = ".binfmt.HALTED_EPIN4 {{ GETSTATUS: {0:16} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Description collection: IN endpoint halted status. Can be used as is as response to a GetStatus() request to endpoint."]
    pub type HALTED_EPIN5 = halted_epin5::Register;
    #[doc = "Description collection: IN endpoint halted status. Can be used as is as response to a GetStatus() request to endpoint."]
    pub mod halted_epin5 {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *const u32 {
                (super::BASE_ADDRESS + 0x0434) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bits 0..=16) IN endpoint halted status. Can be used as is as response to a GetStatus() request to endpoint."]
            pub fn GETSTATUS(self) -> u16 {
                const OFFSET: u8 = 0;
                const MASK: u16 = 0xffff;
                ((self.inner >> OFFSET) as u16) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u16 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "HALTED_EPIN5 {{ GETSTATUS: {0:16} }}@10232013086818340427"]
                #[link_section = ".binfmt.HALTED_EPIN5 {{ GETSTATUS: {0:16} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Description collection: IN endpoint halted status. Can be used as is as response to a GetStatus() request to endpoint."]
    pub type HALTED_EPIN6 = halted_epin6::Register;
    #[doc = "Description collection: IN endpoint halted status. Can be used as is as response to a GetStatus() request to endpoint."]
    pub mod halted_epin6 {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *const u32 {
                (super::BASE_ADDRESS + 0x0438) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bits 0..=16) IN endpoint halted status. Can be used as is as response to a GetStatus() request to endpoint."]
            pub fn GETSTATUS(self) -> u16 {
                const OFFSET: u8 = 0;
                const MASK: u16 = 0xffff;
                ((self.inner >> OFFSET) as u16) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u16 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "HALTED_EPIN6 {{ GETSTATUS: {0:16} }}@6298458663847410337"]
                #[link_section = ".binfmt.HALTED_EPIN6 {{ GETSTATUS: {0:16} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Description collection: IN endpoint halted status. Can be used as is as response to a GetStatus() request to endpoint."]
    pub type HALTED_EPIN7 = halted_epin7::Register;
    #[doc = "Description collection: IN endpoint halted status. Can be used as is as response to a GetStatus() request to endpoint."]
    pub mod halted_epin7 {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *const u32 {
                (super::BASE_ADDRESS + 0x043c) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bits 0..=16) IN endpoint halted status. Can be used as is as response to a GetStatus() request to endpoint."]
            pub fn GETSTATUS(self) -> u16 {
                const OFFSET: u8 = 0;
                const MASK: u16 = 0xffff;
                ((self.inner >> OFFSET) as u16) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u16 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "HALTED_EPIN7 {{ GETSTATUS: {0:16} }}@7308952504579572920"]
                #[link_section = ".binfmt.HALTED_EPIN7 {{ GETSTATUS: {0:16} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Description collection: OUT endpoint halted status. Can be used as is as response to a GetStatus() request to endpoint."]
    pub type HALTED_EPOUT0 = halted_epout0::Register;
    #[doc = "Description collection: OUT endpoint halted status. Can be used as is as response to a GetStatus() request to endpoint."]
    pub mod halted_epout0 {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *const u32 {
                (super::BASE_ADDRESS + 0x0444) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bits 0..=16) OUT endpoint halted status. Can be used as is as response to a GetStatus() request to endpoint."]
            pub fn GETSTATUS(self) -> u16 {
                const OFFSET: u8 = 0;
                const MASK: u16 = 0xffff;
                ((self.inner >> OFFSET) as u16) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u16 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "HALTED_EPOUT0 {{ GETSTATUS: {0:16} }}@1463438174129909162"]
                #[link_section = ".binfmt.HALTED_EPOUT0 {{ GETSTATUS: {0:16} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Description collection: OUT endpoint halted status. Can be used as is as response to a GetStatus() request to endpoint."]
    pub type HALTED_EPOUT1 = halted_epout1::Register;
    #[doc = "Description collection: OUT endpoint halted status. Can be used as is as response to a GetStatus() request to endpoint."]
    pub mod halted_epout1 {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *const u32 {
                (super::BASE_ADDRESS + 0x0448) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bits 0..=16) OUT endpoint halted status. Can be used as is as response to a GetStatus() request to endpoint."]
            pub fn GETSTATUS(self) -> u16 {
                const OFFSET: u8 = 0;
                const MASK: u16 = 0xffff;
                ((self.inner >> OFFSET) as u16) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u16 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "HALTED_EPOUT1 {{ GETSTATUS: {0:16} }}@4617898157412820081"]
                #[link_section = ".binfmt.HALTED_EPOUT1 {{ GETSTATUS: {0:16} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Description collection: OUT endpoint halted status. Can be used as is as response to a GetStatus() request to endpoint."]
    pub type HALTED_EPOUT2 = halted_epout2::Register;
    #[doc = "Description collection: OUT endpoint halted status. Can be used as is as response to a GetStatus() request to endpoint."]
    pub mod halted_epout2 {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *const u32 {
                (super::BASE_ADDRESS + 0x044c) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bits 0..=16) OUT endpoint halted status. Can be used as is as response to a GetStatus() request to endpoint."]
            pub fn GETSTATUS(self) -> u16 {
                const OFFSET: u8 = 0;
                const MASK: u16 = 0xffff;
                ((self.inner >> OFFSET) as u16) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u16 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "HALTED_EPOUT2 {{ GETSTATUS: {0:16} }}@4171927140204120957"]
                #[link_section = ".binfmt.HALTED_EPOUT2 {{ GETSTATUS: {0:16} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Description collection: OUT endpoint halted status. Can be used as is as response to a GetStatus() request to endpoint."]
    pub type HALTED_EPOUT3 = halted_epout3::Register;
    #[doc = "Description collection: OUT endpoint halted status. Can be used as is as response to a GetStatus() request to endpoint."]
    pub mod halted_epout3 {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *const u32 {
                (super::BASE_ADDRESS + 0x0450) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bits 0..=16) OUT endpoint halted status. Can be used as is as response to a GetStatus() request to endpoint."]
            pub fn GETSTATUS(self) -> u16 {
                const OFFSET: u8 = 0;
                const MASK: u16 = 0xffff;
                ((self.inner >> OFFSET) as u16) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u16 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "HALTED_EPOUT3 {{ GETSTATUS: {0:16} }}@13066883012157711552"]
                #[link_section = ".binfmt.HALTED_EPOUT3 {{ GETSTATUS: {0:16} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Description collection: OUT endpoint halted status. Can be used as is as response to a GetStatus() request to endpoint."]
    pub type HALTED_EPOUT4 = halted_epout4::Register;
    #[doc = "Description collection: OUT endpoint halted status. Can be used as is as response to a GetStatus() request to endpoint."]
    pub mod halted_epout4 {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *const u32 {
                (super::BASE_ADDRESS + 0x0454) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bits 0..=16) OUT endpoint halted status. Can be used as is as response to a GetStatus() request to endpoint."]
            pub fn GETSTATUS(self) -> u16 {
                const OFFSET: u8 = 0;
                const MASK: u16 = 0xffff;
                ((self.inner >> OFFSET) as u16) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u16 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "HALTED_EPOUT4 {{ GETSTATUS: {0:16} }}@11035085559324764010"]
                #[link_section = ".binfmt.HALTED_EPOUT4 {{ GETSTATUS: {0:16} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Description collection: OUT endpoint halted status. Can be used as is as response to a GetStatus() request to endpoint."]
    pub type HALTED_EPOUT5 = halted_epout5::Register;
    #[doc = "Description collection: OUT endpoint halted status. Can be used as is as response to a GetStatus() request to endpoint."]
    pub mod halted_epout5 {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *const u32 {
                (super::BASE_ADDRESS + 0x0458) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bits 0..=16) OUT endpoint halted status. Can be used as is as response to a GetStatus() request to endpoint."]
            pub fn GETSTATUS(self) -> u16 {
                const OFFSET: u8 = 0;
                const MASK: u16 = 0xffff;
                ((self.inner >> OFFSET) as u16) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u16 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "HALTED_EPOUT5 {{ GETSTATUS: {0:16} }}@2878698888720634137"]
                #[link_section = ".binfmt.HALTED_EPOUT5 {{ GETSTATUS: {0:16} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Description collection: OUT endpoint halted status. Can be used as is as response to a GetStatus() request to endpoint."]
    pub type HALTED_EPOUT6 = halted_epout6::Register;
    #[doc = "Description collection: OUT endpoint halted status. Can be used as is as response to a GetStatus() request to endpoint."]
    pub mod halted_epout6 {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *const u32 {
                (super::BASE_ADDRESS + 0x045c) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bits 0..=16) OUT endpoint halted status. Can be used as is as response to a GetStatus() request to endpoint."]
            pub fn GETSTATUS(self) -> u16 {
                const OFFSET: u8 = 0;
                const MASK: u16 = 0xffff;
                ((self.inner >> OFFSET) as u16) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u16 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "HALTED_EPOUT6 {{ GETSTATUS: {0:16} }}@15239831002166501824"]
                #[link_section = ".binfmt.HALTED_EPOUT6 {{ GETSTATUS: {0:16} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Description collection: OUT endpoint halted status. Can be used as is as response to a GetStatus() request to endpoint."]
    pub type HALTED_EPOUT7 = halted_epout7::Register;
    #[doc = "Description collection: OUT endpoint halted status. Can be used as is as response to a GetStatus() request to endpoint."]
    pub mod halted_epout7 {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *const u32 {
                (super::BASE_ADDRESS + 0x0460) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bits 0..=16) OUT endpoint halted status. Can be used as is as response to a GetStatus() request to endpoint."]
            pub fn GETSTATUS(self) -> u16 {
                const OFFSET: u8 = 0;
                const MASK: u16 = 0xffff;
                ((self.inner >> OFFSET) as u16) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u16 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "HALTED_EPOUT7 {{ GETSTATUS: {0:16} }}@4800280454694980450"]
                #[link_section = ".binfmt.HALTED_EPOUT7 {{ GETSTATUS: {0:16} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Provides information on which endpoint's EasyDMA registers have been captured"]
    pub type EPSTATUS = epstatus::Register;
    #[doc = "Provides information on which endpoint's EasyDMA registers have been captured"]
    pub mod epstatus {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0468) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bit 0) Captured state of endpoint's EasyDMA registers. Write '1' to clear."]
            pub fn EPIN0(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 1) Captured state of endpoint's EasyDMA registers. Write '1' to clear."]
            pub fn EPIN1(self) -> u8 {
                const OFFSET: u8 = 1;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 2) Captured state of endpoint's EasyDMA registers. Write '1' to clear."]
            pub fn EPIN2(self) -> u8 {
                const OFFSET: u8 = 2;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 3) Captured state of endpoint's EasyDMA registers. Write '1' to clear."]
            pub fn EPIN3(self) -> u8 {
                const OFFSET: u8 = 3;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 4) Captured state of endpoint's EasyDMA registers. Write '1' to clear."]
            pub fn EPIN4(self) -> u8 {
                const OFFSET: u8 = 4;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 5) Captured state of endpoint's EasyDMA registers. Write '1' to clear."]
            pub fn EPIN5(self) -> u8 {
                const OFFSET: u8 = 5;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 6) Captured state of endpoint's EasyDMA registers. Write '1' to clear."]
            pub fn EPIN6(self) -> u8 {
                const OFFSET: u8 = 6;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 7) Captured state of endpoint's EasyDMA registers. Write '1' to clear."]
            pub fn EPIN7(self) -> u8 {
                const OFFSET: u8 = 7;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 8) Captured state of endpoint's EasyDMA registers. Write '1' to clear."]
            pub fn EPIN8(self) -> u8 {
                const OFFSET: u8 = 8;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 16) Captured state of endpoint's EasyDMA registers. Write '1' to clear."]
            pub fn EPOUT0(self) -> u8 {
                const OFFSET: u8 = 16;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 17) Captured state of endpoint's EasyDMA registers. Write '1' to clear."]
            pub fn EPOUT1(self) -> u8 {
                const OFFSET: u8 = 17;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 18) Captured state of endpoint's EasyDMA registers. Write '1' to clear."]
            pub fn EPOUT2(self) -> u8 {
                const OFFSET: u8 = 18;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 19) Captured state of endpoint's EasyDMA registers. Write '1' to clear."]
            pub fn EPOUT3(self) -> u8 {
                const OFFSET: u8 = 19;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 20) Captured state of endpoint's EasyDMA registers. Write '1' to clear."]
            pub fn EPOUT4(self) -> u8 {
                const OFFSET: u8 = 20;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 21) Captured state of endpoint's EasyDMA registers. Write '1' to clear."]
            pub fn EPOUT5(self) -> u8 {
                const OFFSET: u8 = 21;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 22) Captured state of endpoint's EasyDMA registers. Write '1' to clear."]
            pub fn EPOUT6(self) -> u8 {
                const OFFSET: u8 = 22;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 23) Captured state of endpoint's EasyDMA registers. Write '1' to clear."]
            pub fn EPOUT7(self) -> u8 {
                const OFFSET: u8 = 23;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 24) Captured state of endpoint's EasyDMA registers. Write '1' to clear."]
            pub fn EPOUT8(self) -> u8 {
                const OFFSET: u8 = 24;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u32 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "EPSTATUS {{ EPOUT8: {24}, EPOUT7: {23}, EPOUT6: {22}, EPOUT5: {21}, EPOUT4: {20}, EPOUT3: {19}, EPOUT2: {18}, EPOUT1: {17}, EPOUT0: {16}, EPIN8: {8}, EPIN7: {7}, EPIN6: {6}, EPIN5: {5}, EPIN4: {4}, EPIN3: {3}, EPIN2: {2}, EPIN1: {1}, EPIN0: {0} }}@18106014731181669521"]
                #[link_section = ".binfmt.EPSTATUS {{ EPOUT8: {24}, EPOUT7: {23}, EPOUT6: {22}, EPOUT5: {21}, EPOUT4: {20}, EPOUT3: {19}, EPOUT2: {18}, EPOUT1: {17}, EPOUT0: {16}, EPIN8: {8}, EPIN7: {7}, EPIN6: {6}, EPIN5: {5}, EPIN4: {4}, EPIN3: {3}, EPIN2: {2}, EPIN1: {1}, EPIN0: {0} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 0) Captured state of endpoint's EasyDMA registers. Write '1' to clear."]
            #[allow(non_snake_case)]
            pub fn EPIN0(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 1) Captured state of endpoint's EasyDMA registers. Write '1' to clear."]
            #[allow(non_snake_case)]
            pub fn EPIN1(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 1;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 2) Captured state of endpoint's EasyDMA registers. Write '1' to clear."]
            #[allow(non_snake_case)]
            pub fn EPIN2(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 2;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 3) Captured state of endpoint's EasyDMA registers. Write '1' to clear."]
            #[allow(non_snake_case)]
            pub fn EPIN3(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 3;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 4) Captured state of endpoint's EasyDMA registers. Write '1' to clear."]
            #[allow(non_snake_case)]
            pub fn EPIN4(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 4;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 5) Captured state of endpoint's EasyDMA registers. Write '1' to clear."]
            #[allow(non_snake_case)]
            pub fn EPIN5(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 5;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 6) Captured state of endpoint's EasyDMA registers. Write '1' to clear."]
            #[allow(non_snake_case)]
            pub fn EPIN6(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 6;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 7) Captured state of endpoint's EasyDMA registers. Write '1' to clear."]
            #[allow(non_snake_case)]
            pub fn EPIN7(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 7;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 8) Captured state of endpoint's EasyDMA registers. Write '1' to clear."]
            #[allow(non_snake_case)]
            pub fn EPIN8(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 8;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 16) Captured state of endpoint's EasyDMA registers. Write '1' to clear."]
            #[allow(non_snake_case)]
            pub fn EPOUT0(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 16;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 17) Captured state of endpoint's EasyDMA registers. Write '1' to clear."]
            #[allow(non_snake_case)]
            pub fn EPOUT1(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 17;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 18) Captured state of endpoint's EasyDMA registers. Write '1' to clear."]
            #[allow(non_snake_case)]
            pub fn EPOUT2(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 18;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 19) Captured state of endpoint's EasyDMA registers. Write '1' to clear."]
            #[allow(non_snake_case)]
            pub fn EPOUT3(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 19;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 20) Captured state of endpoint's EasyDMA registers. Write '1' to clear."]
            #[allow(non_snake_case)]
            pub fn EPOUT4(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 20;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 21) Captured state of endpoint's EasyDMA registers. Write '1' to clear."]
            #[allow(non_snake_case)]
            pub fn EPOUT5(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 21;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 22) Captured state of endpoint's EasyDMA registers. Write '1' to clear."]
            #[allow(non_snake_case)]
            pub fn EPOUT6(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 22;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 23) Captured state of endpoint's EasyDMA registers. Write '1' to clear."]
            #[allow(non_snake_case)]
            pub fn EPOUT7(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 23;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 24) Captured state of endpoint's EasyDMA registers. Write '1' to clear."]
            #[allow(non_snake_case)]
            pub fn EPOUT8(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 24;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Provides information on which endpoint(s) an acknowledged data transfer has occurred (EPDATA event)"]
    pub type EPDATASTATUS = epdatastatus::Register;
    #[doc = "Provides information on which endpoint(s) an acknowledged data transfer has occurred (EPDATA event)"]
    pub mod epdatastatus {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x046c) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bit 1) Acknowledged data transfer on this IN endpoint. Write '1' to clear."]
            pub fn EPIN1(self) -> u8 {
                const OFFSET: u8 = 1;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 2) Acknowledged data transfer on this IN endpoint. Write '1' to clear."]
            pub fn EPIN2(self) -> u8 {
                const OFFSET: u8 = 2;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 3) Acknowledged data transfer on this IN endpoint. Write '1' to clear."]
            pub fn EPIN3(self) -> u8 {
                const OFFSET: u8 = 3;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 4) Acknowledged data transfer on this IN endpoint. Write '1' to clear."]
            pub fn EPIN4(self) -> u8 {
                const OFFSET: u8 = 4;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 5) Acknowledged data transfer on this IN endpoint. Write '1' to clear."]
            pub fn EPIN5(self) -> u8 {
                const OFFSET: u8 = 5;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 6) Acknowledged data transfer on this IN endpoint. Write '1' to clear."]
            pub fn EPIN6(self) -> u8 {
                const OFFSET: u8 = 6;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 7) Acknowledged data transfer on this IN endpoint. Write '1' to clear."]
            pub fn EPIN7(self) -> u8 {
                const OFFSET: u8 = 7;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 17) Acknowledged data transfer on this OUT endpoint. Write '1' to clear."]
            pub fn EPOUT1(self) -> u8 {
                const OFFSET: u8 = 17;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 18) Acknowledged data transfer on this OUT endpoint. Write '1' to clear."]
            pub fn EPOUT2(self) -> u8 {
                const OFFSET: u8 = 18;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 19) Acknowledged data transfer on this OUT endpoint. Write '1' to clear."]
            pub fn EPOUT3(self) -> u8 {
                const OFFSET: u8 = 19;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 20) Acknowledged data transfer on this OUT endpoint. Write '1' to clear."]
            pub fn EPOUT4(self) -> u8 {
                const OFFSET: u8 = 20;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 21) Acknowledged data transfer on this OUT endpoint. Write '1' to clear."]
            pub fn EPOUT5(self) -> u8 {
                const OFFSET: u8 = 21;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 22) Acknowledged data transfer on this OUT endpoint. Write '1' to clear."]
            pub fn EPOUT6(self) -> u8 {
                const OFFSET: u8 = 22;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 23) Acknowledged data transfer on this OUT endpoint. Write '1' to clear."]
            pub fn EPOUT7(self) -> u8 {
                const OFFSET: u8 = 23;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u32 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "EPDATASTATUS {{ EPOUT7: {23}, EPOUT6: {22}, EPOUT5: {21}, EPOUT4: {20}, EPOUT3: {19}, EPOUT2: {18}, EPOUT1: {17}, EPIN7: {7}, EPIN6: {6}, EPIN5: {5}, EPIN4: {4}, EPIN3: {3}, EPIN2: {2}, EPIN1: {1} }}@8609067433371122470"]
                #[link_section = ".binfmt.EPDATASTATUS {{ EPOUT7: {23}, EPOUT6: {22}, EPOUT5: {21}, EPOUT4: {20}, EPOUT3: {19}, EPOUT2: {18}, EPOUT1: {17}, EPIN7: {7}, EPIN6: {6}, EPIN5: {5}, EPIN4: {4}, EPIN3: {3}, EPIN2: {2}, EPIN1: {1} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 1) Acknowledged data transfer on this IN endpoint. Write '1' to clear."]
            #[allow(non_snake_case)]
            pub fn EPIN1(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 1;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 2) Acknowledged data transfer on this IN endpoint. Write '1' to clear."]
            #[allow(non_snake_case)]
            pub fn EPIN2(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 2;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 3) Acknowledged data transfer on this IN endpoint. Write '1' to clear."]
            #[allow(non_snake_case)]
            pub fn EPIN3(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 3;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 4) Acknowledged data transfer on this IN endpoint. Write '1' to clear."]
            #[allow(non_snake_case)]
            pub fn EPIN4(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 4;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 5) Acknowledged data transfer on this IN endpoint. Write '1' to clear."]
            #[allow(non_snake_case)]
            pub fn EPIN5(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 5;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 6) Acknowledged data transfer on this IN endpoint. Write '1' to clear."]
            #[allow(non_snake_case)]
            pub fn EPIN6(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 6;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 7) Acknowledged data transfer on this IN endpoint. Write '1' to clear."]
            #[allow(non_snake_case)]
            pub fn EPIN7(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 7;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 17) Acknowledged data transfer on this OUT endpoint. Write '1' to clear."]
            #[allow(non_snake_case)]
            pub fn EPOUT1(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 17;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 18) Acknowledged data transfer on this OUT endpoint. Write '1' to clear."]
            #[allow(non_snake_case)]
            pub fn EPOUT2(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 18;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 19) Acknowledged data transfer on this OUT endpoint. Write '1' to clear."]
            #[allow(non_snake_case)]
            pub fn EPOUT3(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 19;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 20) Acknowledged data transfer on this OUT endpoint. Write '1' to clear."]
            #[allow(non_snake_case)]
            pub fn EPOUT4(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 20;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 21) Acknowledged data transfer on this OUT endpoint. Write '1' to clear."]
            #[allow(non_snake_case)]
            pub fn EPOUT5(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 21;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 22) Acknowledged data transfer on this OUT endpoint. Write '1' to clear."]
            #[allow(non_snake_case)]
            pub fn EPOUT6(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 22;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 23) Acknowledged data transfer on this OUT endpoint. Write '1' to clear."]
            #[allow(non_snake_case)]
            pub fn EPOUT7(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 23;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Device USB address"]
    pub type USBADDR = usbaddr::Register;
    #[doc = "Device USB address"]
    pub mod usbaddr {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *const u32 {
                (super::BASE_ADDRESS + 0x0470) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bits 0..=7) Device USB address"]
            pub fn ADDR(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x7f;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u8 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "USBADDR {{ ADDR: {0:7} }}@17055734691610771837"]
                #[link_section = ".binfmt.USBADDR {{ ADDR: {0:7} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "SETUP data, byte 0, bmRequestType"]
    pub type BMREQUESTTYPE = bmrequesttype::Register;
    #[doc = "SETUP data, byte 0, bmRequestType"]
    pub mod bmrequesttype {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *const u32 {
                (super::BASE_ADDRESS + 0x0480) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bits 0..=5) Data transfer type"]
            pub fn RECIPIENT(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x1f;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bits 5..=7) Data transfer type"]
            pub fn TYPE(self) -> u8 {
                const OFFSET: u8 = 5;
                const MASK: u8 = 0x03;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 7) Data transfer direction"]
            pub fn DIRECTION(self) -> u8 {
                const OFFSET: u8 = 7;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u8 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "BMREQUESTTYPE {{ DIRECTION: {7}, TYPE: {5:7}, RECIPIENT: {0:5} }}@6033886639059080173"]
                #[link_section = ".binfmt.BMREQUESTTYPE {{ DIRECTION: {7}, TYPE: {5:7}, RECIPIENT: {0:5} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "SETUP data, byte 1, bRequest"]
    pub type BREQUEST = brequest::Register;
    #[doc = "SETUP data, byte 1, bRequest"]
    pub mod brequest {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *const u32 {
                (super::BASE_ADDRESS + 0x0484) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bits 0..=8) SETUP data, byte 1, bRequest. Values provided for standard requests only, user must implement class and vendor values."]
            pub fn BREQUEST(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0xff;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u8 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "BREQUEST {{ BREQUEST: {0:8} }}@3495015555221276494"]
                #[link_section = ".binfmt.BREQUEST {{ BREQUEST: {0:8} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "SETUP data, byte 2, LSB of wValue"]
    pub type WVALUEL = wvaluel::Register;
    #[doc = "SETUP data, byte 2, LSB of wValue"]
    pub mod wvaluel {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *const u32 {
                (super::BASE_ADDRESS + 0x0488) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bits 0..=8) SETUP data, byte 2, LSB of wValue"]
            pub fn WVALUEL(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0xff;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u8 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "WVALUEL {{ WVALUEL: {0:8} }}@15134790210994093863"]
                #[link_section = ".binfmt.WVALUEL {{ WVALUEL: {0:8} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "SETUP data, byte 3, MSB of wValue"]
    pub type WVALUEH = wvalueh::Register;
    #[doc = "SETUP data, byte 3, MSB of wValue"]
    pub mod wvalueh {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *const u32 {
                (super::BASE_ADDRESS + 0x048c) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bits 0..=8) SETUP data, byte 3, MSB of wValue"]
            pub fn WVALUEH(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0xff;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u8 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "WVALUEH {{ WVALUEH: {0:8} }}@14382919371737360698"]
                #[link_section = ".binfmt.WVALUEH {{ WVALUEH: {0:8} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "SETUP data, byte 4, LSB of wIndex"]
    pub type WINDEXL = windexl::Register;
    #[doc = "SETUP data, byte 4, LSB of wIndex"]
    pub mod windexl {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *const u32 {
                (super::BASE_ADDRESS + 0x0490) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bits 0..=8) SETUP data, byte 4, LSB of wIndex"]
            pub fn WINDEXL(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0xff;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u8 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "WINDEXL {{ WINDEXL: {0:8} }}@15615458146829360805"]
                #[link_section = ".binfmt.WINDEXL {{ WINDEXL: {0:8} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "SETUP data, byte 5, MSB of wIndex"]
    pub type WINDEXH = windexh::Register;
    #[doc = "SETUP data, byte 5, MSB of wIndex"]
    pub mod windexh {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *const u32 {
                (super::BASE_ADDRESS + 0x0494) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bits 0..=8) SETUP data, byte 5, MSB of wIndex"]
            pub fn WINDEXH(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0xff;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u8 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "WINDEXH {{ WINDEXH: {0:8} }}@15434583143199004390"]
                #[link_section = ".binfmt.WINDEXH {{ WINDEXH: {0:8} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "SETUP data, byte 6, LSB of wLength"]
    pub type WLENGTHL = wlengthl::Register;
    #[doc = "SETUP data, byte 6, LSB of wLength"]
    pub mod wlengthl {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *const u32 {
                (super::BASE_ADDRESS + 0x0498) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bits 0..=8) SETUP data, byte 6, LSB of wLength"]
            pub fn WLENGTHL(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0xff;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u8 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "WLENGTHL {{ WLENGTHL: {0:8} }}@1155703751719092354"]
                #[link_section = ".binfmt.WLENGTHL {{ WLENGTHL: {0:8} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "SETUP data, byte 7, MSB of wLength"]
    pub type WLENGTHH = wlengthh::Register;
    #[doc = "SETUP data, byte 7, MSB of wLength"]
    pub mod wlengthh {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *const u32 {
                (super::BASE_ADDRESS + 0x049c) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bits 0..=8) SETUP data, byte 7, MSB of wLength"]
            pub fn WLENGTHH(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0xff;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u8 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "WLENGTHH {{ WLENGTHH: {0:8} }}@5725265339340106353"]
                #[link_section = ".binfmt.WLENGTHH {{ WLENGTHH: {0:8} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Description collection: Number of bytes received last in the data stage of this OUT endpoint"]
    pub type SIZE_EPOUT0 = size_epout0::Register;
    #[doc = "Description collection: Number of bytes received last in the data stage of this OUT endpoint"]
    pub mod size_epout0 {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x04a0) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bits 0..=7) Number of bytes received last in the data stage of this OUT endpoint"]
            pub fn SIZE(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x7f;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u8 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "SIZE_EPOUT0 {{ SIZE: {0:7} }}@2230999966777830018"]
                #[link_section = ".binfmt.SIZE_EPOUT0 {{ SIZE: {0:7} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bits 0..=7) Number of bytes received last in the data stage of this OUT endpoint"]
            #[allow(non_snake_case)]
            pub fn SIZE(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x7f;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Description collection: Number of bytes received last in the data stage of this OUT endpoint"]
    pub type SIZE_EPOUT1 = size_epout1::Register;
    #[doc = "Description collection: Number of bytes received last in the data stage of this OUT endpoint"]
    pub mod size_epout1 {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x04a4) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bits 0..=7) Number of bytes received last in the data stage of this OUT endpoint"]
            pub fn SIZE(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x7f;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u8 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "SIZE_EPOUT1 {{ SIZE: {0:7} }}@3823740203975692715"]
                #[link_section = ".binfmt.SIZE_EPOUT1 {{ SIZE: {0:7} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bits 0..=7) Number of bytes received last in the data stage of this OUT endpoint"]
            #[allow(non_snake_case)]
            pub fn SIZE(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x7f;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Description collection: Number of bytes received last in the data stage of this OUT endpoint"]
    pub type SIZE_EPOUT2 = size_epout2::Register;
    #[doc = "Description collection: Number of bytes received last in the data stage of this OUT endpoint"]
    pub mod size_epout2 {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x04a8) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bits 0..=7) Number of bytes received last in the data stage of this OUT endpoint"]
            pub fn SIZE(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x7f;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u8 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "SIZE_EPOUT2 {{ SIZE: {0:7} }}@4728823898159529006"]
                #[link_section = ".binfmt.SIZE_EPOUT2 {{ SIZE: {0:7} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bits 0..=7) Number of bytes received last in the data stage of this OUT endpoint"]
            #[allow(non_snake_case)]
            pub fn SIZE(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x7f;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Description collection: Number of bytes received last in the data stage of this OUT endpoint"]
    pub type SIZE_EPOUT3 = size_epout3::Register;
    #[doc = "Description collection: Number of bytes received last in the data stage of this OUT endpoint"]
    pub mod size_epout3 {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x04ac) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bits 0..=7) Number of bytes received last in the data stage of this OUT endpoint"]
            pub fn SIZE(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x7f;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u8 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "SIZE_EPOUT3 {{ SIZE: {0:7} }}@16499600989123345745"]
                #[link_section = ".binfmt.SIZE_EPOUT3 {{ SIZE: {0:7} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bits 0..=7) Number of bytes received last in the data stage of this OUT endpoint"]
            #[allow(non_snake_case)]
            pub fn SIZE(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x7f;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Description collection: Number of bytes received last in the data stage of this OUT endpoint"]
    pub type SIZE_EPOUT4 = size_epout4::Register;
    #[doc = "Description collection: Number of bytes received last in the data stage of this OUT endpoint"]
    pub mod size_epout4 {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x04b0) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bits 0..=7) Number of bytes received last in the data stage of this OUT endpoint"]
            pub fn SIZE(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x7f;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u8 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "SIZE_EPOUT4 {{ SIZE: {0:7} }}@2455087772876195667"]
                #[link_section = ".binfmt.SIZE_EPOUT4 {{ SIZE: {0:7} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bits 0..=7) Number of bytes received last in the data stage of this OUT endpoint"]
            #[allow(non_snake_case)]
            pub fn SIZE(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x7f;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Description collection: Number of bytes received last in the data stage of this OUT endpoint"]
    pub type SIZE_EPOUT5 = size_epout5::Register;
    #[doc = "Description collection: Number of bytes received last in the data stage of this OUT endpoint"]
    pub mod size_epout5 {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x04b4) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bits 0..=7) Number of bytes received last in the data stage of this OUT endpoint"]
            pub fn SIZE(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x7f;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u8 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "SIZE_EPOUT5 {{ SIZE: {0:7} }}@5464907632102228916"]
                #[link_section = ".binfmt.SIZE_EPOUT5 {{ SIZE: {0:7} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bits 0..=7) Number of bytes received last in the data stage of this OUT endpoint"]
            #[allow(non_snake_case)]
            pub fn SIZE(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x7f;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Description collection: Number of bytes received last in the data stage of this OUT endpoint"]
    pub type SIZE_EPOUT6 = size_epout6::Register;
    #[doc = "Description collection: Number of bytes received last in the data stage of this OUT endpoint"]
    pub mod size_epout6 {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x04b8) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bits 0..=7) Number of bytes received last in the data stage of this OUT endpoint"]
            pub fn SIZE(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x7f;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u8 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "SIZE_EPOUT6 {{ SIZE: {0:7} }}@2076996103680138495"]
                #[link_section = ".binfmt.SIZE_EPOUT6 {{ SIZE: {0:7} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bits 0..=7) Number of bytes received last in the data stage of this OUT endpoint"]
            #[allow(non_snake_case)]
            pub fn SIZE(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x7f;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Description collection: Number of bytes received last in the data stage of this OUT endpoint"]
    pub type SIZE_EPOUT7 = size_epout7::Register;
    #[doc = "Description collection: Number of bytes received last in the data stage of this OUT endpoint"]
    pub mod size_epout7 {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x04bc) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bits 0..=7) Number of bytes received last in the data stage of this OUT endpoint"]
            pub fn SIZE(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x7f;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u8 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "SIZE_EPOUT7 {{ SIZE: {0:7} }}@11701498447839806270"]
                #[link_section = ".binfmt.SIZE_EPOUT7 {{ SIZE: {0:7} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bits 0..=7) Number of bytes received last in the data stage of this OUT endpoint"]
            #[allow(non_snake_case)]
            pub fn SIZE(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x7f;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Number of bytes received last on this ISO OUT data endpoint"]
    pub type SIZE_ISOOUT = size_isoout::Register;
    #[doc = "Number of bytes received last on this ISO OUT data endpoint"]
    pub mod size_isoout {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *const u32 {
                (super::BASE_ADDRESS + 0x04c0) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bits 0..=10) Number of bytes received last on this ISO OUT data endpoint"]
            pub fn SIZE(self) -> u16 {
                const OFFSET: u8 = 0;
                const MASK: u16 = 0x03ff;
                ((self.inner >> OFFSET) as u16) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 16) Zero-length data packet received"]
            pub fn ZERO(self) -> u8 {
                const OFFSET: u8 = 16;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u32 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "SIZE_ISOOUT {{ ZERO: {16}, SIZE: {0:10} }}@5388365333131770880"]
                #[link_section = ".binfmt.SIZE_ISOOUT {{ ZERO: {16}, SIZE: {0:10} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Enable USB"]
    pub type ENABLE = enable::Register;
    #[doc = "Enable USB"]
    pub mod enable {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0500) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bit 0) Enable USB"]
            pub fn ENABLE(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u8 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "ENABLE {{ ENABLE: {0} }}@12505767666545145069"]
                #[link_section = ".binfmt.ENABLE {{ ENABLE: {0} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 0) Enable USB"]
            #[allow(non_snake_case)]
            pub fn ENABLE(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Control of the USB pull-up"]
    pub type USBPULLUP = usbpullup::Register;
    #[doc = "Control of the USB pull-up"]
    pub mod usbpullup {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0504) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bit 0) Control of the USB pull-up on the D+ line"]
            pub fn CONNECT(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u8 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "USBPULLUP {{ CONNECT: {0} }}@15350016220195518946"]
                #[link_section = ".binfmt.USBPULLUP {{ CONNECT: {0} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 0) Control of the USB pull-up on the D+ line"]
            #[allow(non_snake_case)]
            pub fn CONNECT(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "State D+ and D- lines will be forced into by the DPDMDRIVE task. The DPDMNODRIVE task reverts the control of the lines to MAC IP (no forcing)."]
    pub type DPDMVALUE = dpdmvalue::Register;
    #[doc = "State D+ and D- lines will be forced into by the DPDMDRIVE task. The DPDMNODRIVE task reverts the control of the lines to MAC IP (no forcing)."]
    pub mod dpdmvalue {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0508) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bits 0..=5) State D+ and D- lines will be forced into by the DPDMDRIVE task"]
            pub fn STATE(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x1f;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u8 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "DPDMVALUE {{ STATE: {0:5} }}@15391895533322381949"]
                #[link_section = ".binfmt.DPDMVALUE {{ STATE: {0:5} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bits 0..=5) State D+ and D- lines will be forced into by the DPDMDRIVE task"]
            #[allow(non_snake_case)]
            pub fn STATE(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x1f;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Data toggle control and status"]
    pub type DTOGGLE = dtoggle::Register;
    #[doc = "Data toggle control and status"]
    pub mod dtoggle {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x050c) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bits 0..=3) Select bulk endpoint number"]
            pub fn EP(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x07;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 7) Selects IN or OUT endpoint"]
            pub fn IO(self) -> u8 {
                const OFFSET: u8 = 7;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bits 8..=10) Data toggle value"]
            pub fn VALUE(self) -> u8 {
                const OFFSET: u8 = 8;
                const MASK: u8 = 0x03;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u16 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "DTOGGLE {{ VALUE: {8:10}, IO: {7}, EP: {0:3} }}@8320978756003692488"]
                #[link_section = ".binfmt.DTOGGLE {{ VALUE: {8:10}, IO: {7}, EP: {0:3} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bits 0..=3) Select bulk endpoint number"]
            #[allow(non_snake_case)]
            pub fn EP(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x07;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 7) Selects IN or OUT endpoint"]
            #[allow(non_snake_case)]
            pub fn IO(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 7;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bits 8..=10) Data toggle value"]
            #[allow(non_snake_case)]
            pub fn VALUE(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 8;
                const MASK: u8 = 0x03;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Endpoint IN enable"]
    pub type EPINEN = epinen::Register;
    #[doc = "Endpoint IN enable"]
    pub mod epinen {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0510) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bit 0) Enable IN endpoint 0"]
            pub fn IN0(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 1) Enable IN endpoint 1"]
            pub fn IN1(self) -> u8 {
                const OFFSET: u8 = 1;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 2) Enable IN endpoint 2"]
            pub fn IN2(self) -> u8 {
                const OFFSET: u8 = 2;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 3) Enable IN endpoint 3"]
            pub fn IN3(self) -> u8 {
                const OFFSET: u8 = 3;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 4) Enable IN endpoint 4"]
            pub fn IN4(self) -> u8 {
                const OFFSET: u8 = 4;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 5) Enable IN endpoint 5"]
            pub fn IN5(self) -> u8 {
                const OFFSET: u8 = 5;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 6) Enable IN endpoint 6"]
            pub fn IN6(self) -> u8 {
                const OFFSET: u8 = 6;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 7) Enable IN endpoint 7"]
            pub fn IN7(self) -> u8 {
                const OFFSET: u8 = 7;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 8) Enable ISO IN endpoint"]
            pub fn ISOIN(self) -> u8 {
                const OFFSET: u8 = 8;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u16 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "EPINEN {{ ISOIN: {8}, IN7: {7}, IN6: {6}, IN5: {5}, IN4: {4}, IN3: {3}, IN2: {2}, IN1: {1}, IN0: {0} }}@12903380171724229575"]
                #[link_section = ".binfmt.EPINEN {{ ISOIN: {8}, IN7: {7}, IN6: {6}, IN5: {5}, IN4: {4}, IN3: {3}, IN2: {2}, IN1: {1}, IN0: {0} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 0) Enable IN endpoint 0"]
            #[allow(non_snake_case)]
            pub fn IN0(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 1) Enable IN endpoint 1"]
            #[allow(non_snake_case)]
            pub fn IN1(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 1;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 2) Enable IN endpoint 2"]
            #[allow(non_snake_case)]
            pub fn IN2(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 2;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 3) Enable IN endpoint 3"]
            #[allow(non_snake_case)]
            pub fn IN3(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 3;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 4) Enable IN endpoint 4"]
            #[allow(non_snake_case)]
            pub fn IN4(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 4;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 5) Enable IN endpoint 5"]
            #[allow(non_snake_case)]
            pub fn IN5(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 5;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 6) Enable IN endpoint 6"]
            #[allow(non_snake_case)]
            pub fn IN6(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 6;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 7) Enable IN endpoint 7"]
            #[allow(non_snake_case)]
            pub fn IN7(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 7;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 8) Enable ISO IN endpoint"]
            #[allow(non_snake_case)]
            pub fn ISOIN(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 8;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Endpoint OUT enable"]
    pub type EPOUTEN = epouten::Register;
    #[doc = "Endpoint OUT enable"]
    pub mod epouten {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0514) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bit 0) Enable OUT endpoint 0"]
            pub fn OUT0(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 1) Enable OUT endpoint 1"]
            pub fn OUT1(self) -> u8 {
                const OFFSET: u8 = 1;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 2) Enable OUT endpoint 2"]
            pub fn OUT2(self) -> u8 {
                const OFFSET: u8 = 2;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 3) Enable OUT endpoint 3"]
            pub fn OUT3(self) -> u8 {
                const OFFSET: u8 = 3;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 4) Enable OUT endpoint 4"]
            pub fn OUT4(self) -> u8 {
                const OFFSET: u8 = 4;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 5) Enable OUT endpoint 5"]
            pub fn OUT5(self) -> u8 {
                const OFFSET: u8 = 5;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 6) Enable OUT endpoint 6"]
            pub fn OUT6(self) -> u8 {
                const OFFSET: u8 = 6;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 7) Enable OUT endpoint 7"]
            pub fn OUT7(self) -> u8 {
                const OFFSET: u8 = 7;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[allow(non_snake_case)]
            #[doc = "(Bit 8) Enable ISO OUT endpoint 8"]
            pub fn ISOOUT(self) -> u8 {
                const OFFSET: u8 = 8;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u16 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "EPOUTEN {{ ISOOUT: {8}, OUT7: {7}, OUT6: {6}, OUT5: {5}, OUT4: {4}, OUT3: {3}, OUT2: {2}, OUT1: {1}, OUT0: {0} }}@15611389679806414835"]
                #[link_section = ".binfmt.EPOUTEN {{ ISOOUT: {8}, OUT7: {7}, OUT6: {6}, OUT5: {5}, OUT4: {4}, OUT3: {3}, OUT2: {2}, OUT1: {1}, OUT0: {0} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 0) Enable OUT endpoint 0"]
            #[allow(non_snake_case)]
            pub fn OUT0(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 1) Enable OUT endpoint 1"]
            #[allow(non_snake_case)]
            pub fn OUT1(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 1;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 2) Enable OUT endpoint 2"]
            #[allow(non_snake_case)]
            pub fn OUT2(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 2;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 3) Enable OUT endpoint 3"]
            #[allow(non_snake_case)]
            pub fn OUT3(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 3;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 4) Enable OUT endpoint 4"]
            #[allow(non_snake_case)]
            pub fn OUT4(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 4;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 5) Enable OUT endpoint 5"]
            #[allow(non_snake_case)]
            pub fn OUT5(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 5;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 6) Enable OUT endpoint 6"]
            #[allow(non_snake_case)]
            pub fn OUT6(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 6;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 7) Enable OUT endpoint 7"]
            #[allow(non_snake_case)]
            pub fn OUT7(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 7;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 8) Enable ISO OUT endpoint 8"]
            #[allow(non_snake_case)]
            pub fn ISOOUT(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 8;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "STALL endpoints"]
    pub type EPSTALL = epstall::Register;
    #[doc = "STALL endpoints"]
    pub mod epstall {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0518) as *mut _
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bits 0..=3) Select endpoint number"]
            #[allow(non_snake_case)]
            pub fn EP(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x07;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 7) Selects IN or OUT endpoint"]
            #[allow(non_snake_case)]
            pub fn IO(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 7;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
            #[doc = "(Bit 8) Stall selected endpoint"]
            #[allow(non_snake_case)]
            pub fn STALL(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 8;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Controls the split of ISO buffers"]
    pub type ISOSPLIT = isosplit::Register;
    #[doc = "Controls the split of ISO buffers"]
    pub mod isosplit {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x051c) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bits 0..=16) Controls the split of ISO buffers"]
            pub fn SPLIT(self) -> u16 {
                const OFFSET: u8 = 0;
                const MASK: u16 = 0xffff;
                ((self.inner >> OFFSET) as u16) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u16 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "ISOSPLIT {{ SPLIT: {0:16} }}@14023902685832465363"]
                #[link_section = ".binfmt.ISOSPLIT {{ SPLIT: {0:16} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bits 0..=16) Controls the split of ISO buffers"]
            #[allow(non_snake_case)]
            pub fn SPLIT(&mut self, val: u16) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u16 = 0xffff;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Returns the current value of the start of frame counter"]
    pub type FRAMECNTR = framecntr::Register;
    #[doc = "Returns the current value of the start of frame counter"]
    pub mod framecntr {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *const u32 {
                (super::BASE_ADDRESS + 0x0520) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bits 0..=11) Returns the current value of the start of frame counter"]
            pub fn FRAMECNTR(self) -> u16 {
                const OFFSET: u8 = 0;
                const MASK: u16 = 0x07ff;
                ((self.inner >> OFFSET) as u16) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u16 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "FRAMECNTR {{ FRAMECNTR: {0:11} }}@3190639110476719735"]
                #[link_section = ".binfmt.FRAMECNTR {{ FRAMECNTR: {0:11} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Controls USBD peripheral low power mode during USB suspend"]
    pub type LOWPOWER = lowpower::Register;
    #[doc = "Controls USBD peripheral low power mode during USB suspend"]
    pub mod lowpower {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x052c) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bit 0) Controls USBD peripheral low-power mode during USB suspend"]
            pub fn LOWPOWER(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u8 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "LOWPOWER {{ LOWPOWER: {0} }}@9091750003676730709"]
                #[link_section = ".binfmt.LOWPOWER {{ LOWPOWER: {0} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 0) Controls USBD peripheral low-power mode during USB suspend"]
            #[allow(non_snake_case)]
            pub fn LOWPOWER(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Controls the response of the ISO IN endpoint to an IN token when no data is ready to be sent"]
    pub type ISOINCONFIG = isoinconfig::Register;
    #[doc = "Controls the response of the ISO IN endpoint to an IN token when no data is ready to be sent"]
    pub mod isoinconfig {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0530) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bit 0) Controls the response of the ISO IN endpoint to an IN token when no data is ready to be sent"]
            pub fn RESPONSE(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u8 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "ISOINCONFIG {{ RESPONSE: {0} }}@15924410771753430681"]
                #[link_section = ".binfmt.ISOINCONFIG {{ RESPONSE: {0} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bit 0) Controls the response of the ISO IN endpoint to an IN token when no data is ready to be sent"]
            #[allow(non_snake_case)]
            pub fn RESPONSE(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x01;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Description cluster: Data pointer"]
    pub type EPIN0_PTR = epin0_ptr::Register;
    #[doc = "Description cluster: Data pointer"]
    pub mod epin0_ptr {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0600) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bits 0..=32) Data pointer"]
            pub fn PTR(self) -> u32 {
                const OFFSET: u8 = 0;
                const MASK: u32 = 0xffff_ffff;
                ((self.inner >> OFFSET) as u32) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u32 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "EPIN0_PTR {{ PTR: {0:32} }}@18196007069325712782"]
                #[link_section = ".binfmt.EPIN0_PTR {{ PTR: {0:32} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bits 0..=32) Data pointer"]
            #[allow(non_snake_case)]
            pub fn PTR(&mut self, val: u32) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u32 = 0xffff_ffff;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Description cluster: Maximum number of bytes to transfer"]
    pub type EPIN0_MAXCNT = epin0_maxcnt::Register;
    #[doc = "Description cluster: Maximum number of bytes to transfer"]
    pub mod epin0_maxcnt {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0604) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bits 0..=7) Maximum number of bytes to transfer"]
            pub fn MAXCNT(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x7f;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u8 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "EPIN0_MAXCNT {{ MAXCNT: {0:7} }}@4535176635302624682"]
                #[link_section = ".binfmt.EPIN0_MAXCNT {{ MAXCNT: {0:7} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bits 0..=7) Maximum number of bytes to transfer"]
            #[allow(non_snake_case)]
            pub fn MAXCNT(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x7f;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Description cluster: Number of bytes transferred in the last transaction"]
    pub type EPIN0_AMOUNT = epin0_amount::Register;
    #[doc = "Description cluster: Number of bytes transferred in the last transaction"]
    pub mod epin0_amount {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *const u32 {
                (super::BASE_ADDRESS + 0x0608) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bits 0..=7) Number of bytes transferred in the last transaction"]
            pub fn AMOUNT(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x7f;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u8 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "EPIN0_AMOUNT {{ AMOUNT: {0:7} }}@3788912498957405922"]
                #[link_section = ".binfmt.EPIN0_AMOUNT {{ AMOUNT: {0:7} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Description cluster: Data pointer"]
    pub type EPIN1_PTR = epin1_ptr::Register;
    #[doc = "Description cluster: Data pointer"]
    pub mod epin1_ptr {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0614) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bits 0..=32) Data pointer"]
            pub fn PTR(self) -> u32 {
                const OFFSET: u8 = 0;
                const MASK: u32 = 0xffff_ffff;
                ((self.inner >> OFFSET) as u32) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u32 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "EPIN1_PTR {{ PTR: {0:32} }}@8534029243764027522"]
                #[link_section = ".binfmt.EPIN1_PTR {{ PTR: {0:32} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bits 0..=32) Data pointer"]
            #[allow(non_snake_case)]
            pub fn PTR(&mut self, val: u32) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u32 = 0xffff_ffff;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Description cluster: Maximum number of bytes to transfer"]
    pub type EPIN1_MAXCNT = epin1_maxcnt::Register;
    #[doc = "Description cluster: Maximum number of bytes to transfer"]
    pub mod epin1_maxcnt {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0618) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bits 0..=7) Maximum number of bytes to transfer"]
            pub fn MAXCNT(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x7f;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u8 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "EPIN1_MAXCNT {{ MAXCNT: {0:7} }}@2514057679471261072"]
                #[link_section = ".binfmt.EPIN1_MAXCNT {{ MAXCNT: {0:7} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bits 0..=7) Maximum number of bytes to transfer"]
            #[allow(non_snake_case)]
            pub fn MAXCNT(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x7f;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Description cluster: Number of bytes transferred in the last transaction"]
    pub type EPIN1_AMOUNT = epin1_amount::Register;
    #[doc = "Description cluster: Number of bytes transferred in the last transaction"]
    pub mod epin1_amount {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *const u32 {
                (super::BASE_ADDRESS + 0x061c) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bits 0..=7) Number of bytes transferred in the last transaction"]
            pub fn AMOUNT(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x7f;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u8 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "EPIN1_AMOUNT {{ AMOUNT: {0:7} }}@2875236122889995101"]
                #[link_section = ".binfmt.EPIN1_AMOUNT {{ AMOUNT: {0:7} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Description cluster: Data pointer"]
    pub type EPIN2_PTR = epin2_ptr::Register;
    #[doc = "Description cluster: Data pointer"]
    pub mod epin2_ptr {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0628) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bits 0..=32) Data pointer"]
            pub fn PTR(self) -> u32 {
                const OFFSET: u8 = 0;
                const MASK: u32 = 0xffff_ffff;
                ((self.inner >> OFFSET) as u32) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u32 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "EPIN2_PTR {{ PTR: {0:32} }}@8691344401761321948"]
                #[link_section = ".binfmt.EPIN2_PTR {{ PTR: {0:32} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bits 0..=32) Data pointer"]
            #[allow(non_snake_case)]
            pub fn PTR(&mut self, val: u32) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u32 = 0xffff_ffff;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Description cluster: Maximum number of bytes to transfer"]
    pub type EPIN2_MAXCNT = epin2_maxcnt::Register;
    #[doc = "Description cluster: Maximum number of bytes to transfer"]
    pub mod epin2_maxcnt {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x062c) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bits 0..=7) Maximum number of bytes to transfer"]
            pub fn MAXCNT(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x7f;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u8 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "EPIN2_MAXCNT {{ MAXCNT: {0:7} }}@10996598464670719946"]
                #[link_section = ".binfmt.EPIN2_MAXCNT {{ MAXCNT: {0:7} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bits 0..=7) Maximum number of bytes to transfer"]
            #[allow(non_snake_case)]
            pub fn MAXCNT(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x7f;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Description cluster: Number of bytes transferred in the last transaction"]
    pub type EPIN2_AMOUNT = epin2_amount::Register;
    #[doc = "Description cluster: Number of bytes transferred in the last transaction"]
    pub mod epin2_amount {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *const u32 {
                (super::BASE_ADDRESS + 0x0630) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bits 0..=7) Number of bytes transferred in the last transaction"]
            pub fn AMOUNT(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x7f;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u8 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "EPIN2_AMOUNT {{ AMOUNT: {0:7} }}@14629401125696109158"]
                #[link_section = ".binfmt.EPIN2_AMOUNT {{ AMOUNT: {0:7} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Description cluster: Data pointer"]
    pub type EPIN3_PTR = epin3_ptr::Register;
    #[doc = "Description cluster: Data pointer"]
    pub mod epin3_ptr {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x063c) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bits 0..=32) Data pointer"]
            pub fn PTR(self) -> u32 {
                const OFFSET: u8 = 0;
                const MASK: u32 = 0xffff_ffff;
                ((self.inner >> OFFSET) as u32) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u32 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "EPIN3_PTR {{ PTR: {0:32} }}@7759171923532265461"]
                #[link_section = ".binfmt.EPIN3_PTR {{ PTR: {0:32} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bits 0..=32) Data pointer"]
            #[allow(non_snake_case)]
            pub fn PTR(&mut self, val: u32) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u32 = 0xffff_ffff;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Description cluster: Maximum number of bytes to transfer"]
    pub type EPIN3_MAXCNT = epin3_maxcnt::Register;
    #[doc = "Description cluster: Maximum number of bytes to transfer"]
    pub mod epin3_maxcnt {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0640) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bits 0..=7) Maximum number of bytes to transfer"]
            pub fn MAXCNT(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x7f;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u8 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "EPIN3_MAXCNT {{ MAXCNT: {0:7} }}@5340369159231887640"]
                #[link_section = ".binfmt.EPIN3_MAXCNT {{ MAXCNT: {0:7} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bits 0..=7) Maximum number of bytes to transfer"]
            #[allow(non_snake_case)]
            pub fn MAXCNT(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x7f;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Description cluster: Number of bytes transferred in the last transaction"]
    pub type EPIN3_AMOUNT = epin3_amount::Register;
    #[doc = "Description cluster: Number of bytes transferred in the last transaction"]
    pub mod epin3_amount {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *const u32 {
                (super::BASE_ADDRESS + 0x0644) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bits 0..=7) Number of bytes transferred in the last transaction"]
            pub fn AMOUNT(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x7f;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u8 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "EPIN3_AMOUNT {{ AMOUNT: {0:7} }}@16510193218844145501"]
                #[link_section = ".binfmt.EPIN3_AMOUNT {{ AMOUNT: {0:7} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Description cluster: Data pointer"]
    pub type EPIN4_PTR = epin4_ptr::Register;
    #[doc = "Description cluster: Data pointer"]
    pub mod epin4_ptr {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0650) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bits 0..=32) Data pointer"]
            pub fn PTR(self) -> u32 {
                const OFFSET: u8 = 0;
                const MASK: u32 = 0xffff_ffff;
                ((self.inner >> OFFSET) as u32) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u32 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "EPIN4_PTR {{ PTR: {0:32} }}@5076753804254201827"]
                #[link_section = ".binfmt.EPIN4_PTR {{ PTR: {0:32} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bits 0..=32) Data pointer"]
            #[allow(non_snake_case)]
            pub fn PTR(&mut self, val: u32) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u32 = 0xffff_ffff;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Description cluster: Maximum number of bytes to transfer"]
    pub type EPIN4_MAXCNT = epin4_maxcnt::Register;
    #[doc = "Description cluster: Maximum number of bytes to transfer"]
    pub mod epin4_maxcnt {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0654) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bits 0..=7) Maximum number of bytes to transfer"]
            pub fn MAXCNT(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x7f;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u8 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "EPIN4_MAXCNT {{ MAXCNT: {0:7} }}@9781530858112543075"]
                #[link_section = ".binfmt.EPIN4_MAXCNT {{ MAXCNT: {0:7} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bits 0..=7) Maximum number of bytes to transfer"]
            #[allow(non_snake_case)]
            pub fn MAXCNT(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x7f;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Description cluster: Number of bytes transferred in the last transaction"]
    pub type EPIN4_AMOUNT = epin4_amount::Register;
    #[doc = "Description cluster: Number of bytes transferred in the last transaction"]
    pub mod epin4_amount {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *const u32 {
                (super::BASE_ADDRESS + 0x0658) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bits 0..=7) Number of bytes transferred in the last transaction"]
            pub fn AMOUNT(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x7f;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u8 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "EPIN4_AMOUNT {{ AMOUNT: {0:7} }}@17522220091259626806"]
                #[link_section = ".binfmt.EPIN4_AMOUNT {{ AMOUNT: {0:7} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Description cluster: Data pointer"]
    pub type EPIN5_PTR = epin5_ptr::Register;
    #[doc = "Description cluster: Data pointer"]
    pub mod epin5_ptr {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0664) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bits 0..=32) Data pointer"]
            pub fn PTR(self) -> u32 {
                const OFFSET: u8 = 0;
                const MASK: u32 = 0xffff_ffff;
                ((self.inner >> OFFSET) as u32) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u32 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "EPIN5_PTR {{ PTR: {0:32} }}@10466076271738854305"]
                #[link_section = ".binfmt.EPIN5_PTR {{ PTR: {0:32} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bits 0..=32) Data pointer"]
            #[allow(non_snake_case)]
            pub fn PTR(&mut self, val: u32) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u32 = 0xffff_ffff;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Description cluster: Maximum number of bytes to transfer"]
    pub type EPIN5_MAXCNT = epin5_maxcnt::Register;
    #[doc = "Description cluster: Maximum number of bytes to transfer"]
    pub mod epin5_maxcnt {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0668) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bits 0..=7) Maximum number of bytes to transfer"]
            pub fn MAXCNT(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x7f;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u8 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "EPIN5_MAXCNT {{ MAXCNT: {0:7} }}@16122430435087083630"]
                #[link_section = ".binfmt.EPIN5_MAXCNT {{ MAXCNT: {0:7} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bits 0..=7) Maximum number of bytes to transfer"]
            #[allow(non_snake_case)]
            pub fn MAXCNT(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x7f;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Description cluster: Number of bytes transferred in the last transaction"]
    pub type EPIN5_AMOUNT = epin5_amount::Register;
    #[doc = "Description cluster: Number of bytes transferred in the last transaction"]
    pub mod epin5_amount {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *const u32 {
                (super::BASE_ADDRESS + 0x066c) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bits 0..=7) Number of bytes transferred in the last transaction"]
            pub fn AMOUNT(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x7f;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u8 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "EPIN5_AMOUNT {{ AMOUNT: {0:7} }}@4909560069915219914"]
                #[link_section = ".binfmt.EPIN5_AMOUNT {{ AMOUNT: {0:7} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Description cluster: Data pointer"]
    pub type EPIN6_PTR = epin6_ptr::Register;
    #[doc = "Description cluster: Data pointer"]
    pub mod epin6_ptr {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0678) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bits 0..=32) Data pointer"]
            pub fn PTR(self) -> u32 {
                const OFFSET: u8 = 0;
                const MASK: u32 = 0xffff_ffff;
                ((self.inner >> OFFSET) as u32) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u32 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "EPIN6_PTR {{ PTR: {0:32} }}@6970578536518573741"]
                #[link_section = ".binfmt.EPIN6_PTR {{ PTR: {0:32} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bits 0..=32) Data pointer"]
            #[allow(non_snake_case)]
            pub fn PTR(&mut self, val: u32) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u32 = 0xffff_ffff;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Description cluster: Maximum number of bytes to transfer"]
    pub type EPIN6_MAXCNT = epin6_maxcnt::Register;
    #[doc = "Description cluster: Maximum number of bytes to transfer"]
    pub mod epin6_maxcnt {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x067c) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bits 0..=7) Maximum number of bytes to transfer"]
            pub fn MAXCNT(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x7f;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u8 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "EPIN6_MAXCNT {{ MAXCNT: {0:7} }}@18165176251255697573"]
                #[link_section = ".binfmt.EPIN6_MAXCNT {{ MAXCNT: {0:7} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bits 0..=7) Maximum number of bytes to transfer"]
            #[allow(non_snake_case)]
            pub fn MAXCNT(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x7f;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Description cluster: Number of bytes transferred in the last transaction"]
    pub type EPIN6_AMOUNT = epin6_amount::Register;
    #[doc = "Description cluster: Number of bytes transferred in the last transaction"]
    pub mod epin6_amount {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *const u32 {
                (super::BASE_ADDRESS + 0x0680) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bits 0..=7) Number of bytes transferred in the last transaction"]
            pub fn AMOUNT(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x7f;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u8 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "EPIN6_AMOUNT {{ AMOUNT: {0:7} }}@378368887118287127"]
                #[link_section = ".binfmt.EPIN6_AMOUNT {{ AMOUNT: {0:7} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Description cluster: Data pointer"]
    pub type EPIN7_PTR = epin7_ptr::Register;
    #[doc = "Description cluster: Data pointer"]
    pub mod epin7_ptr {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x068c) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bits 0..=32) Data pointer"]
            pub fn PTR(self) -> u32 {
                const OFFSET: u8 = 0;
                const MASK: u32 = 0xffff_ffff;
                ((self.inner >> OFFSET) as u32) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u32 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "EPIN7_PTR {{ PTR: {0:32} }}@5168237815014872170"]
                #[link_section = ".binfmt.EPIN7_PTR {{ PTR: {0:32} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bits 0..=32) Data pointer"]
            #[allow(non_snake_case)]
            pub fn PTR(&mut self, val: u32) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u32 = 0xffff_ffff;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Description cluster: Maximum number of bytes to transfer"]
    pub type EPIN7_MAXCNT = epin7_maxcnt::Register;
    #[doc = "Description cluster: Maximum number of bytes to transfer"]
    pub mod epin7_maxcnt {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0690) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bits 0..=7) Maximum number of bytes to transfer"]
            pub fn MAXCNT(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x7f;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u8 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "EPIN7_MAXCNT {{ MAXCNT: {0:7} }}@3699832593768715104"]
                #[link_section = ".binfmt.EPIN7_MAXCNT {{ MAXCNT: {0:7} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bits 0..=7) Maximum number of bytes to transfer"]
            #[allow(non_snake_case)]
            pub fn MAXCNT(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x7f;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Description cluster: Number of bytes transferred in the last transaction"]
    pub type EPIN7_AMOUNT = epin7_amount::Register;
    #[doc = "Description cluster: Number of bytes transferred in the last transaction"]
    pub mod epin7_amount {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *const u32 {
                (super::BASE_ADDRESS + 0x0694) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bits 0..=7) Number of bytes transferred in the last transaction"]
            pub fn AMOUNT(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x7f;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u8 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "EPIN7_AMOUNT {{ AMOUNT: {0:7} }}@2793189712768065697"]
                #[link_section = ".binfmt.EPIN7_AMOUNT {{ AMOUNT: {0:7} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Data pointer"]
    pub type ISOIN_PTR = isoin_ptr::Register;
    #[doc = "Data pointer"]
    pub mod isoin_ptr {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x06a0) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bits 0..=32) Data pointer"]
            pub fn PTR(self) -> u32 {
                const OFFSET: u8 = 0;
                const MASK: u32 = 0xffff_ffff;
                ((self.inner >> OFFSET) as u32) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u32 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "ISOIN_PTR {{ PTR: {0:32} }}@1824400741438592149"]
                #[link_section = ".binfmt.ISOIN_PTR {{ PTR: {0:32} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bits 0..=32) Data pointer"]
            #[allow(non_snake_case)]
            pub fn PTR(&mut self, val: u32) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u32 = 0xffff_ffff;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Maximum number of bytes to transfer"]
    pub type ISOIN_MAXCNT = isoin_maxcnt::Register;
    #[doc = "Maximum number of bytes to transfer"]
    pub mod isoin_maxcnt {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x06a4) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bits 0..=10) Maximum number of bytes to transfer"]
            pub fn MAXCNT(self) -> u16 {
                const OFFSET: u8 = 0;
                const MASK: u16 = 0x03ff;
                ((self.inner >> OFFSET) as u16) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u16 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "ISOIN_MAXCNT {{ MAXCNT: {0:10} }}@607924038641691821"]
                #[link_section = ".binfmt.ISOIN_MAXCNT {{ MAXCNT: {0:10} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bits 0..=10) Maximum number of bytes to transfer"]
            #[allow(non_snake_case)]
            pub fn MAXCNT(&mut self, val: u16) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u16 = 0x03ff;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Number of bytes transferred in the last transaction"]
    pub type ISOIN_AMOUNT = isoin_amount::Register;
    #[doc = "Number of bytes transferred in the last transaction"]
    pub mod isoin_amount {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *const u32 {
                (super::BASE_ADDRESS + 0x06a8) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bits 0..=10) Number of bytes transferred in the last transaction"]
            pub fn AMOUNT(self) -> u16 {
                const OFFSET: u8 = 0;
                const MASK: u16 = 0x03ff;
                ((self.inner >> OFFSET) as u16) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u16 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "ISOIN_AMOUNT {{ AMOUNT: {0:10} }}@3771913777529403029"]
                #[link_section = ".binfmt.ISOIN_AMOUNT {{ AMOUNT: {0:10} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Description cluster: Data pointer"]
    pub type EPOUT0_PTR = epout0_ptr::Register;
    #[doc = "Description cluster: Data pointer"]
    pub mod epout0_ptr {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0700) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bits 0..=32) Data pointer"]
            pub fn PTR(self) -> u32 {
                const OFFSET: u8 = 0;
                const MASK: u32 = 0xffff_ffff;
                ((self.inner >> OFFSET) as u32) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u32 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "EPOUT0_PTR {{ PTR: {0:32} }}@3657377099962222714"]
                #[link_section = ".binfmt.EPOUT0_PTR {{ PTR: {0:32} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bits 0..=32) Data pointer"]
            #[allow(non_snake_case)]
            pub fn PTR(&mut self, val: u32) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u32 = 0xffff_ffff;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Description cluster: Maximum number of bytes to transfer"]
    pub type EPOUT0_MAXCNT = epout0_maxcnt::Register;
    #[doc = "Description cluster: Maximum number of bytes to transfer"]
    pub mod epout0_maxcnt {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0704) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bits 0..=7) Maximum number of bytes to transfer"]
            pub fn MAXCNT(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x7f;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u8 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "EPOUT0_MAXCNT {{ MAXCNT: {0:7} }}@3899836651765709771"]
                #[link_section = ".binfmt.EPOUT0_MAXCNT {{ MAXCNT: {0:7} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bits 0..=7) Maximum number of bytes to transfer"]
            #[allow(non_snake_case)]
            pub fn MAXCNT(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x7f;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Description cluster: Number of bytes transferred in the last transaction"]
    pub type EPOUT0_AMOUNT = epout0_amount::Register;
    #[doc = "Description cluster: Number of bytes transferred in the last transaction"]
    pub mod epout0_amount {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *const u32 {
                (super::BASE_ADDRESS + 0x0708) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bits 0..=7) Number of bytes transferred in the last transaction"]
            pub fn AMOUNT(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x7f;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u8 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "EPOUT0_AMOUNT {{ AMOUNT: {0:7} }}@6973410311849244708"]
                #[link_section = ".binfmt.EPOUT0_AMOUNT {{ AMOUNT: {0:7} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Description cluster: Data pointer"]
    pub type EPOUT1_PTR = epout1_ptr::Register;
    #[doc = "Description cluster: Data pointer"]
    pub mod epout1_ptr {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0714) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bits 0..=32) Data pointer"]
            pub fn PTR(self) -> u32 {
                const OFFSET: u8 = 0;
                const MASK: u32 = 0xffff_ffff;
                ((self.inner >> OFFSET) as u32) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u32 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "EPOUT1_PTR {{ PTR: {0:32} }}@3592626790311181579"]
                #[link_section = ".binfmt.EPOUT1_PTR {{ PTR: {0:32} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bits 0..=32) Data pointer"]
            #[allow(non_snake_case)]
            pub fn PTR(&mut self, val: u32) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u32 = 0xffff_ffff;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Description cluster: Maximum number of bytes to transfer"]
    pub type EPOUT1_MAXCNT = epout1_maxcnt::Register;
    #[doc = "Description cluster: Maximum number of bytes to transfer"]
    pub mod epout1_maxcnt {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0718) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bits 0..=7) Maximum number of bytes to transfer"]
            pub fn MAXCNT(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x7f;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u8 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "EPOUT1_MAXCNT {{ MAXCNT: {0:7} }}@13021565857037966784"]
                #[link_section = ".binfmt.EPOUT1_MAXCNT {{ MAXCNT: {0:7} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bits 0..=7) Maximum number of bytes to transfer"]
            #[allow(non_snake_case)]
            pub fn MAXCNT(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x7f;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Description cluster: Number of bytes transferred in the last transaction"]
    pub type EPOUT1_AMOUNT = epout1_amount::Register;
    #[doc = "Description cluster: Number of bytes transferred in the last transaction"]
    pub mod epout1_amount {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *const u32 {
                (super::BASE_ADDRESS + 0x071c) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bits 0..=7) Number of bytes transferred in the last transaction"]
            pub fn AMOUNT(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x7f;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u8 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "EPOUT1_AMOUNT {{ AMOUNT: {0:7} }}@14079694076077929055"]
                #[link_section = ".binfmt.EPOUT1_AMOUNT {{ AMOUNT: {0:7} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Description cluster: Data pointer"]
    pub type EPOUT2_PTR = epout2_ptr::Register;
    #[doc = "Description cluster: Data pointer"]
    pub mod epout2_ptr {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0728) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bits 0..=32) Data pointer"]
            pub fn PTR(self) -> u32 {
                const OFFSET: u8 = 0;
                const MASK: u32 = 0xffff_ffff;
                ((self.inner >> OFFSET) as u32) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u32 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "EPOUT2_PTR {{ PTR: {0:32} }}@16871875180587364059"]
                #[link_section = ".binfmt.EPOUT2_PTR {{ PTR: {0:32} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bits 0..=32) Data pointer"]
            #[allow(non_snake_case)]
            pub fn PTR(&mut self, val: u32) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u32 = 0xffff_ffff;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Description cluster: Maximum number of bytes to transfer"]
    pub type EPOUT2_MAXCNT = epout2_maxcnt::Register;
    #[doc = "Description cluster: Maximum number of bytes to transfer"]
    pub mod epout2_maxcnt {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x072c) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bits 0..=7) Maximum number of bytes to transfer"]
            pub fn MAXCNT(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x7f;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u8 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "EPOUT2_MAXCNT {{ MAXCNT: {0:7} }}@8105211594961370884"]
                #[link_section = ".binfmt.EPOUT2_MAXCNT {{ MAXCNT: {0:7} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bits 0..=7) Maximum number of bytes to transfer"]
            #[allow(non_snake_case)]
            pub fn MAXCNT(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x7f;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Description cluster: Number of bytes transferred in the last transaction"]
    pub type EPOUT2_AMOUNT = epout2_amount::Register;
    #[doc = "Description cluster: Number of bytes transferred in the last transaction"]
    pub mod epout2_amount {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *const u32 {
                (super::BASE_ADDRESS + 0x0730) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bits 0..=7) Number of bytes transferred in the last transaction"]
            pub fn AMOUNT(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x7f;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u8 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "EPOUT2_AMOUNT {{ AMOUNT: {0:7} }}@5846574356569969314"]
                #[link_section = ".binfmt.EPOUT2_AMOUNT {{ AMOUNT: {0:7} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Description cluster: Data pointer"]
    pub type EPOUT3_PTR = epout3_ptr::Register;
    #[doc = "Description cluster: Data pointer"]
    pub mod epout3_ptr {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x073c) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bits 0..=32) Data pointer"]
            pub fn PTR(self) -> u32 {
                const OFFSET: u8 = 0;
                const MASK: u32 = 0xffff_ffff;
                ((self.inner >> OFFSET) as u32) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u32 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "EPOUT3_PTR {{ PTR: {0:32} }}@288718850015974873"]
                #[link_section = ".binfmt.EPOUT3_PTR {{ PTR: {0:32} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bits 0..=32) Data pointer"]
            #[allow(non_snake_case)]
            pub fn PTR(&mut self, val: u32) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u32 = 0xffff_ffff;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Description cluster: Maximum number of bytes to transfer"]
    pub type EPOUT3_MAXCNT = epout3_maxcnt::Register;
    #[doc = "Description cluster: Maximum number of bytes to transfer"]
    pub mod epout3_maxcnt {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0740) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bits 0..=7) Maximum number of bytes to transfer"]
            pub fn MAXCNT(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x7f;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u8 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "EPOUT3_MAXCNT {{ MAXCNT: {0:7} }}@14309127932098685347"]
                #[link_section = ".binfmt.EPOUT3_MAXCNT {{ MAXCNT: {0:7} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bits 0..=7) Maximum number of bytes to transfer"]
            #[allow(non_snake_case)]
            pub fn MAXCNT(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x7f;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Description cluster: Number of bytes transferred in the last transaction"]
    pub type EPOUT3_AMOUNT = epout3_amount::Register;
    #[doc = "Description cluster: Number of bytes transferred in the last transaction"]
    pub mod epout3_amount {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *const u32 {
                (super::BASE_ADDRESS + 0x0744) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bits 0..=7) Number of bytes transferred in the last transaction"]
            pub fn AMOUNT(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x7f;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u8 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "EPOUT3_AMOUNT {{ AMOUNT: {0:7} }}@3034437709972520604"]
                #[link_section = ".binfmt.EPOUT3_AMOUNT {{ AMOUNT: {0:7} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Description cluster: Data pointer"]
    pub type EPOUT4_PTR = epout4_ptr::Register;
    #[doc = "Description cluster: Data pointer"]
    pub mod epout4_ptr {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0750) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bits 0..=32) Data pointer"]
            pub fn PTR(self) -> u32 {
                const OFFSET: u8 = 0;
                const MASK: u32 = 0xffff_ffff;
                ((self.inner >> OFFSET) as u32) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u32 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "EPOUT4_PTR {{ PTR: {0:32} }}@2771341177988241492"]
                #[link_section = ".binfmt.EPOUT4_PTR {{ PTR: {0:32} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bits 0..=32) Data pointer"]
            #[allow(non_snake_case)]
            pub fn PTR(&mut self, val: u32) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u32 = 0xffff_ffff;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Description cluster: Maximum number of bytes to transfer"]
    pub type EPOUT4_MAXCNT = epout4_maxcnt::Register;
    #[doc = "Description cluster: Maximum number of bytes to transfer"]
    pub mod epout4_maxcnt {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0754) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bits 0..=7) Maximum number of bytes to transfer"]
            pub fn MAXCNT(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x7f;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u8 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "EPOUT4_MAXCNT {{ MAXCNT: {0:7} }}@9068181874914168978"]
                #[link_section = ".binfmt.EPOUT4_MAXCNT {{ MAXCNT: {0:7} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bits 0..=7) Maximum number of bytes to transfer"]
            #[allow(non_snake_case)]
            pub fn MAXCNT(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x7f;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Description cluster: Number of bytes transferred in the last transaction"]
    pub type EPOUT4_AMOUNT = epout4_amount::Register;
    #[doc = "Description cluster: Number of bytes transferred in the last transaction"]
    pub mod epout4_amount {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *const u32 {
                (super::BASE_ADDRESS + 0x0758) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bits 0..=7) Number of bytes transferred in the last transaction"]
            pub fn AMOUNT(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x7f;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u8 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "EPOUT4_AMOUNT {{ AMOUNT: {0:7} }}@9418848359580136649"]
                #[link_section = ".binfmt.EPOUT4_AMOUNT {{ AMOUNT: {0:7} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Description cluster: Data pointer"]
    pub type EPOUT5_PTR = epout5_ptr::Register;
    #[doc = "Description cluster: Data pointer"]
    pub mod epout5_ptr {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0764) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bits 0..=32) Data pointer"]
            pub fn PTR(self) -> u32 {
                const OFFSET: u8 = 0;
                const MASK: u32 = 0xffff_ffff;
                ((self.inner >> OFFSET) as u32) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u32 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "EPOUT5_PTR {{ PTR: {0:32} }}@11966415135029561834"]
                #[link_section = ".binfmt.EPOUT5_PTR {{ PTR: {0:32} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bits 0..=32) Data pointer"]
            #[allow(non_snake_case)]
            pub fn PTR(&mut self, val: u32) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u32 = 0xffff_ffff;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Description cluster: Maximum number of bytes to transfer"]
    pub type EPOUT5_MAXCNT = epout5_maxcnt::Register;
    #[doc = "Description cluster: Maximum number of bytes to transfer"]
    pub mod epout5_maxcnt {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0768) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bits 0..=7) Maximum number of bytes to transfer"]
            pub fn MAXCNT(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x7f;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u8 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "EPOUT5_MAXCNT {{ MAXCNT: {0:7} }}@14316907236334352925"]
                #[link_section = ".binfmt.EPOUT5_MAXCNT {{ MAXCNT: {0:7} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bits 0..=7) Maximum number of bytes to transfer"]
            #[allow(non_snake_case)]
            pub fn MAXCNT(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x7f;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Description cluster: Number of bytes transferred in the last transaction"]
    pub type EPOUT5_AMOUNT = epout5_amount::Register;
    #[doc = "Description cluster: Number of bytes transferred in the last transaction"]
    pub mod epout5_amount {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *const u32 {
                (super::BASE_ADDRESS + 0x076c) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bits 0..=7) Number of bytes transferred in the last transaction"]
            pub fn AMOUNT(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x7f;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u8 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "EPOUT5_AMOUNT {{ AMOUNT: {0:7} }}@12334951978179828384"]
                #[link_section = ".binfmt.EPOUT5_AMOUNT {{ AMOUNT: {0:7} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Description cluster: Data pointer"]
    pub type EPOUT6_PTR = epout6_ptr::Register;
    #[doc = "Description cluster: Data pointer"]
    pub mod epout6_ptr {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0778) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bits 0..=32) Data pointer"]
            pub fn PTR(self) -> u32 {
                const OFFSET: u8 = 0;
                const MASK: u32 = 0xffff_ffff;
                ((self.inner >> OFFSET) as u32) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u32 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "EPOUT6_PTR {{ PTR: {0:32} }}@9900121212653795154"]
                #[link_section = ".binfmt.EPOUT6_PTR {{ PTR: {0:32} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bits 0..=32) Data pointer"]
            #[allow(non_snake_case)]
            pub fn PTR(&mut self, val: u32) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u32 = 0xffff_ffff;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Description cluster: Maximum number of bytes to transfer"]
    pub type EPOUT6_MAXCNT = epout6_maxcnt::Register;
    #[doc = "Description cluster: Maximum number of bytes to transfer"]
    pub mod epout6_maxcnt {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x077c) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bits 0..=7) Maximum number of bytes to transfer"]
            pub fn MAXCNT(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x7f;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u8 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "EPOUT6_MAXCNT {{ MAXCNT: {0:7} }}@11100947412721892444"]
                #[link_section = ".binfmt.EPOUT6_MAXCNT {{ MAXCNT: {0:7} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bits 0..=7) Maximum number of bytes to transfer"]
            #[allow(non_snake_case)]
            pub fn MAXCNT(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x7f;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Description cluster: Number of bytes transferred in the last transaction"]
    pub type EPOUT6_AMOUNT = epout6_amount::Register;
    #[doc = "Description cluster: Number of bytes transferred in the last transaction"]
    pub mod epout6_amount {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *const u32 {
                (super::BASE_ADDRESS + 0x0780) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bits 0..=7) Number of bytes transferred in the last transaction"]
            pub fn AMOUNT(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x7f;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u8 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "EPOUT6_AMOUNT {{ AMOUNT: {0:7} }}@5751667331566877615"]
                #[link_section = ".binfmt.EPOUT6_AMOUNT {{ AMOUNT: {0:7} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Description cluster: Data pointer"]
    pub type EPOUT7_PTR = epout7_ptr::Register;
    #[doc = "Description cluster: Data pointer"]
    pub mod epout7_ptr {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x078c) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bits 0..=32) Data pointer"]
            pub fn PTR(self) -> u32 {
                const OFFSET: u8 = 0;
                const MASK: u32 = 0xffff_ffff;
                ((self.inner >> OFFSET) as u32) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u32 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "EPOUT7_PTR {{ PTR: {0:32} }}@4630752218612688332"]
                #[link_section = ".binfmt.EPOUT7_PTR {{ PTR: {0:32} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bits 0..=32) Data pointer"]
            #[allow(non_snake_case)]
            pub fn PTR(&mut self, val: u32) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u32 = 0xffff_ffff;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Description cluster: Maximum number of bytes to transfer"]
    pub type EPOUT7_MAXCNT = epout7_maxcnt::Register;
    #[doc = "Description cluster: Maximum number of bytes to transfer"]
    pub mod epout7_maxcnt {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x0790) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bits 0..=7) Maximum number of bytes to transfer"]
            pub fn MAXCNT(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x7f;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u8 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "EPOUT7_MAXCNT {{ MAXCNT: {0:7} }}@7069012712027613567"]
                #[link_section = ".binfmt.EPOUT7_MAXCNT {{ MAXCNT: {0:7} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bits 0..=7) Maximum number of bytes to transfer"]
            #[allow(non_snake_case)]
            pub fn MAXCNT(&mut self, val: u8) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x7f;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Description cluster: Number of bytes transferred in the last transaction"]
    pub type EPOUT7_AMOUNT = epout7_amount::Register;
    #[doc = "Description cluster: Number of bytes transferred in the last transaction"]
    pub mod epout7_amount {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *const u32 {
                (super::BASE_ADDRESS + 0x0794) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bits 0..=7) Number of bytes transferred in the last transaction"]
            pub fn AMOUNT(self) -> u8 {
                const OFFSET: u8 = 0;
                const MASK: u8 = 0x7f;
                ((self.inner >> OFFSET) as u8) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u8 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "EPOUT7_AMOUNT {{ AMOUNT: {0:7} }}@9309522036475349137"]
                #[link_section = ".binfmt.EPOUT7_AMOUNT {{ AMOUNT: {0:7} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Data pointer"]
    pub type ISOOUT_PTR = isoout_ptr::Register;
    #[doc = "Data pointer"]
    pub mod isoout_ptr {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x07a0) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bits 0..=32) Data pointer"]
            pub fn PTR(self) -> u32 {
                const OFFSET: u8 = 0;
                const MASK: u32 = 0xffff_ffff;
                ((self.inner >> OFFSET) as u32) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u32 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "ISOOUT_PTR {{ PTR: {0:32} }}@10097772597084682815"]
                #[link_section = ".binfmt.ISOOUT_PTR {{ PTR: {0:32} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bits 0..=32) Data pointer"]
            #[allow(non_snake_case)]
            pub fn PTR(&mut self, val: u32) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u32 = 0xffff_ffff;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Maximum number of bytes to transfer"]
    pub type ISOOUT_MAXCNT = isoout_maxcnt::Register;
    #[doc = "Maximum number of bytes to transfer"]
    pub mod isoout_maxcnt {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *mut u32 {
                (super::BASE_ADDRESS + 0x07a4) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
            #[doc = r" Writes the bits set by `f` to the register in a single, volatile instruction"]
            #[inline(always)]
            pub fn write(&self, f: impl FnOnce(&mut W) -> &mut W) {
                let mut w = W::zero();
                f(&mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
            #[doc = r" Writes zeros to the register"]
            #[inline(always)]
            pub fn zero(&self) {
                unsafe {
                    Self::address().write_volatile(0);
                }
            }
            #[doc = r" Updates the contents of the register using the closure `f`"]
            #[doc = r""]
            #[doc = r" This performs a `read` operation followed by a `write` operation"]
            #[inline(always)]
            pub fn rmw(&self, f: impl FnOnce(R, &mut W) -> &mut W) {
                let r = self.read();
                let mut w = r.into();
                f(r, &mut w);
                unsafe {
                    Self::address().write_volatile(w.into());
                }
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bits 0..=10) Maximum number of bytes to transfer"]
            pub fn MAXCNT(self) -> u16 {
                const OFFSET: u8 = 0;
                const MASK: u16 = 0x03ff;
                ((self.inner >> OFFSET) as u16) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u16 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "ISOOUT_MAXCNT {{ MAXCNT: {0:10} }}@545142680082228216"]
                #[link_section = ".binfmt.ISOOUT_MAXCNT {{ MAXCNT: {0:10} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
        #[doc = r" View into the writable bitfields"]
        #[derive(Clone, Copy)]
        pub struct W {
            inner: u32,
        }
        impl From<W> for u32 {
            fn from(w: W) -> Self {
                w.inner
            }
        }
        impl W {
            #[doc = r" Writable view with all bitfields set to zero"]
            pub fn zero() -> W {
                W { inner: 0 }
            }
            #[doc = "(Bits 0..=10) Maximum number of bytes to transfer"]
            #[allow(non_snake_case)]
            pub fn MAXCNT(&mut self, val: u16) -> &mut Self {
                const OFFSET: u8 = 0;
                const MASK: u16 = 0x03ff;
                self.inner &= !((MASK as u32) << OFFSET);
                self.inner |= ((val & MASK) as u32) << OFFSET;
                self
            }
        }
        impl From<R> for W {
            fn from(r: R) -> W {
                W { inner: r.inner }
            }
        }
        impl W {
            #[doc = r" Copies the contents of `R`"]
            pub fn copy(&mut self, r: R) -> &mut Self {
                *self = r.into();
                self
            }
        }
    }
    #[allow(non_camel_case_types)]
    #[doc = "Number of bytes transferred in the last transaction"]
    pub type ISOOUT_AMOUNT = isoout_amount::Register;
    #[doc = "Number of bytes transferred in the last transaction"]
    pub mod isoout_amount {
        use crate::NotSendOrSync;
        #[doc = r" Singleton handle to the register"]
        pub struct Register {
            _not_send_or_sync: NotSendOrSync,
        }
        impl Register {
            #[doc = r" # Safety"]
            #[doc = r" Singleton"]
            pub(crate) unsafe fn new() -> Self {
                Self {
                    _not_send_or_sync: NotSendOrSync::new(),
                }
            }
            #[doc = r" Returns the address of this register"]
            pub fn address() -> *const u32 {
                (super::BASE_ADDRESS + 0x07a8) as *mut _
            }
            #[doc = r" Reads the contents of the register in a single, volatile instruction"]
            pub fn read(&self) -> R {
                R::from(unsafe { Self::address().read_volatile() })
            }
        }
        #[doc = r" View into the readable bitfields"]
        #[derive(Clone, Copy)]
        pub struct R {
            inner: u32,
        }
        impl From<u32> for R {
            fn from(bits: u32) -> Self {
                R { inner: bits }
            }
        }
        impl From<R> for u32 {
            fn from(r: R) -> Self {
                r.inner
            }
        }
        impl R {
            #[allow(non_snake_case)]
            #[doc = "(Bits 0..=10) Number of bytes transferred in the last transaction"]
            pub fn AMOUNT(self) -> u16 {
                const OFFSET: u8 = 0;
                const MASK: u16 = 0x03ff;
                ((self.inner >> OFFSET) as u16) & MASK
            }
            #[doc = r" Returns the non-reserved part of the register"]
            pub fn bits(self) -> u16 {
                self.inner as _
            }
        }
        #[cfg(feature = "binfmt")]
        impl binfmt::binDebug for R {
            fn fmt(&self, f: &mut impl binfmt::binWrite) {
                #[export_name = "ISOOUT_AMOUNT {{ AMOUNT: {0:10} }}@11019826569067006126"]
                #[link_section = ".binfmt.ISOOUT_AMOUNT {{ AMOUNT: {0:10} }}"]
                static SYM: u8 = 0;
                f.write_byte(binfmt::Tag::Register as u8);
                f.write_sym(&SYM);
                f.write(&(*self).bits().to_le_bytes());
            }
        }
    }
    use core::sync::atomic::{AtomicBool, Ordering};
    const BASE_ADDRESS: usize = 0x4002_7000;
    #[allow(non_snake_case)]
    #[doc = "Singleton handle to the USBD registers"]
    pub struct Registers {
        #[doc = "Description collection: Captures the EPIN[n].PTR and EPIN[n].MAXCNT registers values, and enables endpoint IN n to respond to traffic from host"]
        pub TASKS_STARTEPIN0: TASKS_STARTEPIN0,
        #[doc = "Description collection: Captures the EPIN[n].PTR and EPIN[n].MAXCNT registers values, and enables endpoint IN n to respond to traffic from host"]
        pub TASKS_STARTEPIN1: TASKS_STARTEPIN1,
        #[doc = "Description collection: Captures the EPIN[n].PTR and EPIN[n].MAXCNT registers values, and enables endpoint IN n to respond to traffic from host"]
        pub TASKS_STARTEPIN2: TASKS_STARTEPIN2,
        #[doc = "Description collection: Captures the EPIN[n].PTR and EPIN[n].MAXCNT registers values, and enables endpoint IN n to respond to traffic from host"]
        pub TASKS_STARTEPIN3: TASKS_STARTEPIN3,
        #[doc = "Description collection: Captures the EPIN[n].PTR and EPIN[n].MAXCNT registers values, and enables endpoint IN n to respond to traffic from host"]
        pub TASKS_STARTEPIN4: TASKS_STARTEPIN4,
        #[doc = "Description collection: Captures the EPIN[n].PTR and EPIN[n].MAXCNT registers values, and enables endpoint IN n to respond to traffic from host"]
        pub TASKS_STARTEPIN5: TASKS_STARTEPIN5,
        #[doc = "Description collection: Captures the EPIN[n].PTR and EPIN[n].MAXCNT registers values, and enables endpoint IN n to respond to traffic from host"]
        pub TASKS_STARTEPIN6: TASKS_STARTEPIN6,
        #[doc = "Description collection: Captures the EPIN[n].PTR and EPIN[n].MAXCNT registers values, and enables endpoint IN n to respond to traffic from host"]
        pub TASKS_STARTEPIN7: TASKS_STARTEPIN7,
        #[doc = "Captures the ISOIN.PTR and ISOIN.MAXCNT registers values, and enables sending data on ISO endpoint"]
        pub TASKS_STARTISOIN: TASKS_STARTISOIN,
        #[doc = "Description collection: Captures the EPOUT[n].PTR and EPOUT[n].MAXCNT registers values, and enables endpoint n to respond to traffic from host"]
        pub TASKS_STARTEPOUT0: TASKS_STARTEPOUT0,
        #[doc = "Description collection: Captures the EPOUT[n].PTR and EPOUT[n].MAXCNT registers values, and enables endpoint n to respond to traffic from host"]
        pub TASKS_STARTEPOUT1: TASKS_STARTEPOUT1,
        #[doc = "Description collection: Captures the EPOUT[n].PTR and EPOUT[n].MAXCNT registers values, and enables endpoint n to respond to traffic from host"]
        pub TASKS_STARTEPOUT2: TASKS_STARTEPOUT2,
        #[doc = "Description collection: Captures the EPOUT[n].PTR and EPOUT[n].MAXCNT registers values, and enables endpoint n to respond to traffic from host"]
        pub TASKS_STARTEPOUT3: TASKS_STARTEPOUT3,
        #[doc = "Description collection: Captures the EPOUT[n].PTR and EPOUT[n].MAXCNT registers values, and enables endpoint n to respond to traffic from host"]
        pub TASKS_STARTEPOUT4: TASKS_STARTEPOUT4,
        #[doc = "Description collection: Captures the EPOUT[n].PTR and EPOUT[n].MAXCNT registers values, and enables endpoint n to respond to traffic from host"]
        pub TASKS_STARTEPOUT5: TASKS_STARTEPOUT5,
        #[doc = "Description collection: Captures the EPOUT[n].PTR and EPOUT[n].MAXCNT registers values, and enables endpoint n to respond to traffic from host"]
        pub TASKS_STARTEPOUT6: TASKS_STARTEPOUT6,
        #[doc = "Description collection: Captures the EPOUT[n].PTR and EPOUT[n].MAXCNT registers values, and enables endpoint n to respond to traffic from host"]
        pub TASKS_STARTEPOUT7: TASKS_STARTEPOUT7,
        #[doc = "Captures the ISOOUT.PTR and ISOOUT.MAXCNT registers values, and enables receiving of data on ISO endpoint"]
        pub TASKS_STARTISOOUT: TASKS_STARTISOOUT,
        #[doc = "Allows OUT data stage on control endpoint 0"]
        pub TASKS_EP0RCVOUT: TASKS_EP0RCVOUT,
        #[doc = "Allows status stage on control endpoint 0"]
        pub TASKS_EP0STATUS: TASKS_EP0STATUS,
        #[doc = "Stalls data and status stage on control endpoint 0"]
        pub TASKS_EP0STALL: TASKS_EP0STALL,
        #[doc = "Forces D+ and D- lines into the state defined in the DPDMVALUE register"]
        pub TASKS_DPDMDRIVE: TASKS_DPDMDRIVE,
        #[doc = "Stops forcing D+ and D- lines into any state (USB engine takes control)"]
        pub TASKS_DPDMNODRIVE: TASKS_DPDMNODRIVE,
        #[doc = "Signals that a USB reset condition has been detected on USB lines"]
        pub EVENTS_USBRESET: EVENTS_USBRESET,
        #[doc = "Confirms that the EPIN[n].PTR and EPIN[n].MAXCNT, or EPOUT[n].PTR and EPOUT[n].MAXCNT registers have been captured on all endpoints reported in the EPSTATUS register"]
        pub EVENTS_STARTED: EVENTS_STARTED,
        #[doc = "Description collection: The whole EPIN[n] buffer has been consumed. The buffer can be accessed safely by software."]
        pub EVENTS_ENDEPIN0: EVENTS_ENDEPIN0,
        #[doc = "Description collection: The whole EPIN[n] buffer has been consumed. The buffer can be accessed safely by software."]
        pub EVENTS_ENDEPIN1: EVENTS_ENDEPIN1,
        #[doc = "Description collection: The whole EPIN[n] buffer has been consumed. The buffer can be accessed safely by software."]
        pub EVENTS_ENDEPIN2: EVENTS_ENDEPIN2,
        #[doc = "Description collection: The whole EPIN[n] buffer has been consumed. The buffer can be accessed safely by software."]
        pub EVENTS_ENDEPIN3: EVENTS_ENDEPIN3,
        #[doc = "Description collection: The whole EPIN[n] buffer has been consumed. The buffer can be accessed safely by software."]
        pub EVENTS_ENDEPIN4: EVENTS_ENDEPIN4,
        #[doc = "Description collection: The whole EPIN[n] buffer has been consumed. The buffer can be accessed safely by software."]
        pub EVENTS_ENDEPIN5: EVENTS_ENDEPIN5,
        #[doc = "Description collection: The whole EPIN[n] buffer has been consumed. The buffer can be accessed safely by software."]
        pub EVENTS_ENDEPIN6: EVENTS_ENDEPIN6,
        #[doc = "Description collection: The whole EPIN[n] buffer has been consumed. The buffer can be accessed safely by software."]
        pub EVENTS_ENDEPIN7: EVENTS_ENDEPIN7,
        #[doc = "An acknowledged data transfer has taken place on the control endpoint"]
        pub EVENTS_EP0DATADONE: EVENTS_EP0DATADONE,
        #[doc = "The whole ISOIN buffer has been consumed. The buffer can be accessed safely by software."]
        pub EVENTS_ENDISOIN: EVENTS_ENDISOIN,
        #[doc = "Description collection: The whole EPOUT[n] buffer has been consumed. The buffer can be accessed safely by software."]
        pub EVENTS_ENDEPOUT0: EVENTS_ENDEPOUT0,
        #[doc = "Description collection: The whole EPOUT[n] buffer has been consumed. The buffer can be accessed safely by software."]
        pub EVENTS_ENDEPOUT1: EVENTS_ENDEPOUT1,
        #[doc = "Description collection: The whole EPOUT[n] buffer has been consumed. The buffer can be accessed safely by software."]
        pub EVENTS_ENDEPOUT2: EVENTS_ENDEPOUT2,
        #[doc = "Description collection: The whole EPOUT[n] buffer has been consumed. The buffer can be accessed safely by software."]
        pub EVENTS_ENDEPOUT3: EVENTS_ENDEPOUT3,
        #[doc = "Description collection: The whole EPOUT[n] buffer has been consumed. The buffer can be accessed safely by software."]
        pub EVENTS_ENDEPOUT4: EVENTS_ENDEPOUT4,
        #[doc = "Description collection: The whole EPOUT[n] buffer has been consumed. The buffer can be accessed safely by software."]
        pub EVENTS_ENDEPOUT5: EVENTS_ENDEPOUT5,
        #[doc = "Description collection: The whole EPOUT[n] buffer has been consumed. The buffer can be accessed safely by software."]
        pub EVENTS_ENDEPOUT6: EVENTS_ENDEPOUT6,
        #[doc = "Description collection: The whole EPOUT[n] buffer has been consumed. The buffer can be accessed safely by software."]
        pub EVENTS_ENDEPOUT7: EVENTS_ENDEPOUT7,
        #[doc = "The whole ISOOUT buffer has been consumed. The buffer can be accessed safely by software."]
        pub EVENTS_ENDISOOUT: EVENTS_ENDISOOUT,
        #[doc = "Signals that a SOF (start of frame) condition has been detected on USB lines"]
        pub EVENTS_SOF: EVENTS_SOF,
        #[doc = "An event or an error not covered by specific events has occurred. Check EVENTCAUSE register to find the cause."]
        pub EVENTS_USBEVENT: EVENTS_USBEVENT,
        #[doc = "A valid SETUP token has been received (and acknowledged) on the control endpoint"]
        pub EVENTS_EP0SETUP: EVENTS_EP0SETUP,
        #[doc = "A data transfer has occurred on a data endpoint, indicated by the EPDATASTATUS register"]
        pub EVENTS_EPDATA: EVENTS_EPDATA,
        #[doc = "Shortcuts between local events and tasks"]
        pub SHORTS: SHORTS,
        #[doc = "Enable or disable interrupt"]
        pub INTEN: INTEN,
        #[doc = "Enable interrupt"]
        pub INTENSET: INTENSET,
        #[doc = "Disable interrupt"]
        pub INTENCLR: INTENCLR,
        #[doc = "Details on what caused the USBEVENT event"]
        pub EVENTCAUSE: EVENTCAUSE,
        #[doc = "Description collection: IN endpoint halted status. Can be used as is as response to a GetStatus() request to endpoint."]
        pub HALTED_EPIN0: HALTED_EPIN0,
        #[doc = "Description collection: IN endpoint halted status. Can be used as is as response to a GetStatus() request to endpoint."]
        pub HALTED_EPIN1: HALTED_EPIN1,
        #[doc = "Description collection: IN endpoint halted status. Can be used as is as response to a GetStatus() request to endpoint."]
        pub HALTED_EPIN2: HALTED_EPIN2,
        #[doc = "Description collection: IN endpoint halted status. Can be used as is as response to a GetStatus() request to endpoint."]
        pub HALTED_EPIN3: HALTED_EPIN3,
        #[doc = "Description collection: IN endpoint halted status. Can be used as is as response to a GetStatus() request to endpoint."]
        pub HALTED_EPIN4: HALTED_EPIN4,
        #[doc = "Description collection: IN endpoint halted status. Can be used as is as response to a GetStatus() request to endpoint."]
        pub HALTED_EPIN5: HALTED_EPIN5,
        #[doc = "Description collection: IN endpoint halted status. Can be used as is as response to a GetStatus() request to endpoint."]
        pub HALTED_EPIN6: HALTED_EPIN6,
        #[doc = "Description collection: IN endpoint halted status. Can be used as is as response to a GetStatus() request to endpoint."]
        pub HALTED_EPIN7: HALTED_EPIN7,
        #[doc = "Description collection: OUT endpoint halted status. Can be used as is as response to a GetStatus() request to endpoint."]
        pub HALTED_EPOUT0: HALTED_EPOUT0,
        #[doc = "Description collection: OUT endpoint halted status. Can be used as is as response to a GetStatus() request to endpoint."]
        pub HALTED_EPOUT1: HALTED_EPOUT1,
        #[doc = "Description collection: OUT endpoint halted status. Can be used as is as response to a GetStatus() request to endpoint."]
        pub HALTED_EPOUT2: HALTED_EPOUT2,
        #[doc = "Description collection: OUT endpoint halted status. Can be used as is as response to a GetStatus() request to endpoint."]
        pub HALTED_EPOUT3: HALTED_EPOUT3,
        #[doc = "Description collection: OUT endpoint halted status. Can be used as is as response to a GetStatus() request to endpoint."]
        pub HALTED_EPOUT4: HALTED_EPOUT4,
        #[doc = "Description collection: OUT endpoint halted status. Can be used as is as response to a GetStatus() request to endpoint."]
        pub HALTED_EPOUT5: HALTED_EPOUT5,
        #[doc = "Description collection: OUT endpoint halted status. Can be used as is as response to a GetStatus() request to endpoint."]
        pub HALTED_EPOUT6: HALTED_EPOUT6,
        #[doc = "Description collection: OUT endpoint halted status. Can be used as is as response to a GetStatus() request to endpoint."]
        pub HALTED_EPOUT7: HALTED_EPOUT7,
        #[doc = "Provides information on which endpoint's EasyDMA registers have been captured"]
        pub EPSTATUS: EPSTATUS,
        #[doc = "Provides information on which endpoint(s) an acknowledged data transfer has occurred (EPDATA event)"]
        pub EPDATASTATUS: EPDATASTATUS,
        #[doc = "Device USB address"]
        pub USBADDR: USBADDR,
        #[doc = "SETUP data, byte 0, bmRequestType"]
        pub BMREQUESTTYPE: BMREQUESTTYPE,
        #[doc = "SETUP data, byte 1, bRequest"]
        pub BREQUEST: BREQUEST,
        #[doc = "SETUP data, byte 2, LSB of wValue"]
        pub WVALUEL: WVALUEL,
        #[doc = "SETUP data, byte 3, MSB of wValue"]
        pub WVALUEH: WVALUEH,
        #[doc = "SETUP data, byte 4, LSB of wIndex"]
        pub WINDEXL: WINDEXL,
        #[doc = "SETUP data, byte 5, MSB of wIndex"]
        pub WINDEXH: WINDEXH,
        #[doc = "SETUP data, byte 6, LSB of wLength"]
        pub WLENGTHL: WLENGTHL,
        #[doc = "SETUP data, byte 7, MSB of wLength"]
        pub WLENGTHH: WLENGTHH,
        #[doc = "Description collection: Number of bytes received last in the data stage of this OUT endpoint"]
        pub SIZE_EPOUT0: SIZE_EPOUT0,
        #[doc = "Description collection: Number of bytes received last in the data stage of this OUT endpoint"]
        pub SIZE_EPOUT1: SIZE_EPOUT1,
        #[doc = "Description collection: Number of bytes received last in the data stage of this OUT endpoint"]
        pub SIZE_EPOUT2: SIZE_EPOUT2,
        #[doc = "Description collection: Number of bytes received last in the data stage of this OUT endpoint"]
        pub SIZE_EPOUT3: SIZE_EPOUT3,
        #[doc = "Description collection: Number of bytes received last in the data stage of this OUT endpoint"]
        pub SIZE_EPOUT4: SIZE_EPOUT4,
        #[doc = "Description collection: Number of bytes received last in the data stage of this OUT endpoint"]
        pub SIZE_EPOUT5: SIZE_EPOUT5,
        #[doc = "Description collection: Number of bytes received last in the data stage of this OUT endpoint"]
        pub SIZE_EPOUT6: SIZE_EPOUT6,
        #[doc = "Description collection: Number of bytes received last in the data stage of this OUT endpoint"]
        pub SIZE_EPOUT7: SIZE_EPOUT7,
        #[doc = "Number of bytes received last on this ISO OUT data endpoint"]
        pub SIZE_ISOOUT: SIZE_ISOOUT,
        #[doc = "Enable USB"]
        pub ENABLE: ENABLE,
        #[doc = "Control of the USB pull-up"]
        pub USBPULLUP: USBPULLUP,
        #[doc = "State D+ and D- lines will be forced into by the DPDMDRIVE task. The DPDMNODRIVE task reverts the control of the lines to MAC IP (no forcing)."]
        pub DPDMVALUE: DPDMVALUE,
        #[doc = "Data toggle control and status"]
        pub DTOGGLE: DTOGGLE,
        #[doc = "Endpoint IN enable"]
        pub EPINEN: EPINEN,
        #[doc = "Endpoint OUT enable"]
        pub EPOUTEN: EPOUTEN,
        #[doc = "STALL endpoints"]
        pub EPSTALL: EPSTALL,
        #[doc = "Controls the split of ISO buffers"]
        pub ISOSPLIT: ISOSPLIT,
        #[doc = "Returns the current value of the start of frame counter"]
        pub FRAMECNTR: FRAMECNTR,
        #[doc = "Controls USBD peripheral low power mode during USB suspend"]
        pub LOWPOWER: LOWPOWER,
        #[doc = "Controls the response of the ISO IN endpoint to an IN token when no data is ready to be sent"]
        pub ISOINCONFIG: ISOINCONFIG,
        #[doc = "Description cluster: Data pointer"]
        pub EPIN0_PTR: EPIN0_PTR,
        #[doc = "Description cluster: Maximum number of bytes to transfer"]
        pub EPIN0_MAXCNT: EPIN0_MAXCNT,
        #[doc = "Description cluster: Number of bytes transferred in the last transaction"]
        pub EPIN0_AMOUNT: EPIN0_AMOUNT,
        #[doc = "Description cluster: Data pointer"]
        pub EPIN1_PTR: EPIN1_PTR,
        #[doc = "Description cluster: Maximum number of bytes to transfer"]
        pub EPIN1_MAXCNT: EPIN1_MAXCNT,
        #[doc = "Description cluster: Number of bytes transferred in the last transaction"]
        pub EPIN1_AMOUNT: EPIN1_AMOUNT,
        #[doc = "Description cluster: Data pointer"]
        pub EPIN2_PTR: EPIN2_PTR,
        #[doc = "Description cluster: Maximum number of bytes to transfer"]
        pub EPIN2_MAXCNT: EPIN2_MAXCNT,
        #[doc = "Description cluster: Number of bytes transferred in the last transaction"]
        pub EPIN2_AMOUNT: EPIN2_AMOUNT,
        #[doc = "Description cluster: Data pointer"]
        pub EPIN3_PTR: EPIN3_PTR,
        #[doc = "Description cluster: Maximum number of bytes to transfer"]
        pub EPIN3_MAXCNT: EPIN3_MAXCNT,
        #[doc = "Description cluster: Number of bytes transferred in the last transaction"]
        pub EPIN3_AMOUNT: EPIN3_AMOUNT,
        #[doc = "Description cluster: Data pointer"]
        pub EPIN4_PTR: EPIN4_PTR,
        #[doc = "Description cluster: Maximum number of bytes to transfer"]
        pub EPIN4_MAXCNT: EPIN4_MAXCNT,
        #[doc = "Description cluster: Number of bytes transferred in the last transaction"]
        pub EPIN4_AMOUNT: EPIN4_AMOUNT,
        #[doc = "Description cluster: Data pointer"]
        pub EPIN5_PTR: EPIN5_PTR,
        #[doc = "Description cluster: Maximum number of bytes to transfer"]
        pub EPIN5_MAXCNT: EPIN5_MAXCNT,
        #[doc = "Description cluster: Number of bytes transferred in the last transaction"]
        pub EPIN5_AMOUNT: EPIN5_AMOUNT,
        #[doc = "Description cluster: Data pointer"]
        pub EPIN6_PTR: EPIN6_PTR,
        #[doc = "Description cluster: Maximum number of bytes to transfer"]
        pub EPIN6_MAXCNT: EPIN6_MAXCNT,
        #[doc = "Description cluster: Number of bytes transferred in the last transaction"]
        pub EPIN6_AMOUNT: EPIN6_AMOUNT,
        #[doc = "Description cluster: Data pointer"]
        pub EPIN7_PTR: EPIN7_PTR,
        #[doc = "Description cluster: Maximum number of bytes to transfer"]
        pub EPIN7_MAXCNT: EPIN7_MAXCNT,
        #[doc = "Description cluster: Number of bytes transferred in the last transaction"]
        pub EPIN7_AMOUNT: EPIN7_AMOUNT,
        #[doc = "Data pointer"]
        pub ISOIN_PTR: ISOIN_PTR,
        #[doc = "Maximum number of bytes to transfer"]
        pub ISOIN_MAXCNT: ISOIN_MAXCNT,
        #[doc = "Number of bytes transferred in the last transaction"]
        pub ISOIN_AMOUNT: ISOIN_AMOUNT,
        #[doc = "Description cluster: Data pointer"]
        pub EPOUT0_PTR: EPOUT0_PTR,
        #[doc = "Description cluster: Maximum number of bytes to transfer"]
        pub EPOUT0_MAXCNT: EPOUT0_MAXCNT,
        #[doc = "Description cluster: Number of bytes transferred in the last transaction"]
        pub EPOUT0_AMOUNT: EPOUT0_AMOUNT,
        #[doc = "Description cluster: Data pointer"]
        pub EPOUT1_PTR: EPOUT1_PTR,
        #[doc = "Description cluster: Maximum number of bytes to transfer"]
        pub EPOUT1_MAXCNT: EPOUT1_MAXCNT,
        #[doc = "Description cluster: Number of bytes transferred in the last transaction"]
        pub EPOUT1_AMOUNT: EPOUT1_AMOUNT,
        #[doc = "Description cluster: Data pointer"]
        pub EPOUT2_PTR: EPOUT2_PTR,
        #[doc = "Description cluster: Maximum number of bytes to transfer"]
        pub EPOUT2_MAXCNT: EPOUT2_MAXCNT,
        #[doc = "Description cluster: Number of bytes transferred in the last transaction"]
        pub EPOUT2_AMOUNT: EPOUT2_AMOUNT,
        #[doc = "Description cluster: Data pointer"]
        pub EPOUT3_PTR: EPOUT3_PTR,
        #[doc = "Description cluster: Maximum number of bytes to transfer"]
        pub EPOUT3_MAXCNT: EPOUT3_MAXCNT,
        #[doc = "Description cluster: Number of bytes transferred in the last transaction"]
        pub EPOUT3_AMOUNT: EPOUT3_AMOUNT,
        #[doc = "Description cluster: Data pointer"]
        pub EPOUT4_PTR: EPOUT4_PTR,
        #[doc = "Description cluster: Maximum number of bytes to transfer"]
        pub EPOUT4_MAXCNT: EPOUT4_MAXCNT,
        #[doc = "Description cluster: Number of bytes transferred in the last transaction"]
        pub EPOUT4_AMOUNT: EPOUT4_AMOUNT,
        #[doc = "Description cluster: Data pointer"]
        pub EPOUT5_PTR: EPOUT5_PTR,
        #[doc = "Description cluster: Maximum number of bytes to transfer"]
        pub EPOUT5_MAXCNT: EPOUT5_MAXCNT,
        #[doc = "Description cluster: Number of bytes transferred in the last transaction"]
        pub EPOUT5_AMOUNT: EPOUT5_AMOUNT,
        #[doc = "Description cluster: Data pointer"]
        pub EPOUT6_PTR: EPOUT6_PTR,
        #[doc = "Description cluster: Maximum number of bytes to transfer"]
        pub EPOUT6_MAXCNT: EPOUT6_MAXCNT,
        #[doc = "Description cluster: Number of bytes transferred in the last transaction"]
        pub EPOUT6_AMOUNT: EPOUT6_AMOUNT,
        #[doc = "Description cluster: Data pointer"]
        pub EPOUT7_PTR: EPOUT7_PTR,
        #[doc = "Description cluster: Maximum number of bytes to transfer"]
        pub EPOUT7_MAXCNT: EPOUT7_MAXCNT,
        #[doc = "Description cluster: Number of bytes transferred in the last transaction"]
        pub EPOUT7_AMOUNT: EPOUT7_AMOUNT,
        #[doc = "Data pointer"]
        pub ISOOUT_PTR: ISOOUT_PTR,
        #[doc = "Maximum number of bytes to transfer"]
        pub ISOOUT_MAXCNT: ISOOUT_MAXCNT,
        #[doc = "Number of bytes transferred in the last transaction"]
        pub ISOOUT_AMOUNT: ISOOUT_AMOUNT,
    }
    unsafe impl Send for Registers {}
    impl Registers {
        #[doc = r" # Safety"]
        #[doc = r" Singleton"]
        unsafe fn new() -> Self {
            Self {
                TASKS_STARTEPIN0: TASKS_STARTEPIN0::new(),
                TASKS_STARTEPIN1: TASKS_STARTEPIN1::new(),
                TASKS_STARTEPIN2: TASKS_STARTEPIN2::new(),
                TASKS_STARTEPIN3: TASKS_STARTEPIN3::new(),
                TASKS_STARTEPIN4: TASKS_STARTEPIN4::new(),
                TASKS_STARTEPIN5: TASKS_STARTEPIN5::new(),
                TASKS_STARTEPIN6: TASKS_STARTEPIN6::new(),
                TASKS_STARTEPIN7: TASKS_STARTEPIN7::new(),
                TASKS_STARTISOIN: TASKS_STARTISOIN::new(),
                TASKS_STARTEPOUT0: TASKS_STARTEPOUT0::new(),
                TASKS_STARTEPOUT1: TASKS_STARTEPOUT1::new(),
                TASKS_STARTEPOUT2: TASKS_STARTEPOUT2::new(),
                TASKS_STARTEPOUT3: TASKS_STARTEPOUT3::new(),
                TASKS_STARTEPOUT4: TASKS_STARTEPOUT4::new(),
                TASKS_STARTEPOUT5: TASKS_STARTEPOUT5::new(),
                TASKS_STARTEPOUT6: TASKS_STARTEPOUT6::new(),
                TASKS_STARTEPOUT7: TASKS_STARTEPOUT7::new(),
                TASKS_STARTISOOUT: TASKS_STARTISOOUT::new(),
                TASKS_EP0RCVOUT: TASKS_EP0RCVOUT::new(),
                TASKS_EP0STATUS: TASKS_EP0STATUS::new(),
                TASKS_EP0STALL: TASKS_EP0STALL::new(),
                TASKS_DPDMDRIVE: TASKS_DPDMDRIVE::new(),
                TASKS_DPDMNODRIVE: TASKS_DPDMNODRIVE::new(),
                EVENTS_USBRESET: EVENTS_USBRESET::new(),
                EVENTS_STARTED: EVENTS_STARTED::new(),
                EVENTS_ENDEPIN0: EVENTS_ENDEPIN0::new(),
                EVENTS_ENDEPIN1: EVENTS_ENDEPIN1::new(),
                EVENTS_ENDEPIN2: EVENTS_ENDEPIN2::new(),
                EVENTS_ENDEPIN3: EVENTS_ENDEPIN3::new(),
                EVENTS_ENDEPIN4: EVENTS_ENDEPIN4::new(),
                EVENTS_ENDEPIN5: EVENTS_ENDEPIN5::new(),
                EVENTS_ENDEPIN6: EVENTS_ENDEPIN6::new(),
                EVENTS_ENDEPIN7: EVENTS_ENDEPIN7::new(),
                EVENTS_EP0DATADONE: EVENTS_EP0DATADONE::new(),
                EVENTS_ENDISOIN: EVENTS_ENDISOIN::new(),
                EVENTS_ENDEPOUT0: EVENTS_ENDEPOUT0::new(),
                EVENTS_ENDEPOUT1: EVENTS_ENDEPOUT1::new(),
                EVENTS_ENDEPOUT2: EVENTS_ENDEPOUT2::new(),
                EVENTS_ENDEPOUT3: EVENTS_ENDEPOUT3::new(),
                EVENTS_ENDEPOUT4: EVENTS_ENDEPOUT4::new(),
                EVENTS_ENDEPOUT5: EVENTS_ENDEPOUT5::new(),
                EVENTS_ENDEPOUT6: EVENTS_ENDEPOUT6::new(),
                EVENTS_ENDEPOUT7: EVENTS_ENDEPOUT7::new(),
                EVENTS_ENDISOOUT: EVENTS_ENDISOOUT::new(),
                EVENTS_SOF: EVENTS_SOF::new(),
                EVENTS_USBEVENT: EVENTS_USBEVENT::new(),
                EVENTS_EP0SETUP: EVENTS_EP0SETUP::new(),
                EVENTS_EPDATA: EVENTS_EPDATA::new(),
                SHORTS: SHORTS::new(),
                INTEN: INTEN::new(),
                INTENSET: INTENSET::new(),
                INTENCLR: INTENCLR::new(),
                EVENTCAUSE: EVENTCAUSE::new(),
                HALTED_EPIN0: HALTED_EPIN0::new(),
                HALTED_EPIN1: HALTED_EPIN1::new(),
                HALTED_EPIN2: HALTED_EPIN2::new(),
                HALTED_EPIN3: HALTED_EPIN3::new(),
                HALTED_EPIN4: HALTED_EPIN4::new(),
                HALTED_EPIN5: HALTED_EPIN5::new(),
                HALTED_EPIN6: HALTED_EPIN6::new(),
                HALTED_EPIN7: HALTED_EPIN7::new(),
                HALTED_EPOUT0: HALTED_EPOUT0::new(),
                HALTED_EPOUT1: HALTED_EPOUT1::new(),
                HALTED_EPOUT2: HALTED_EPOUT2::new(),
                HALTED_EPOUT3: HALTED_EPOUT3::new(),
                HALTED_EPOUT4: HALTED_EPOUT4::new(),
                HALTED_EPOUT5: HALTED_EPOUT5::new(),
                HALTED_EPOUT6: HALTED_EPOUT6::new(),
                HALTED_EPOUT7: HALTED_EPOUT7::new(),
                EPSTATUS: EPSTATUS::new(),
                EPDATASTATUS: EPDATASTATUS::new(),
                USBADDR: USBADDR::new(),
                BMREQUESTTYPE: BMREQUESTTYPE::new(),
                BREQUEST: BREQUEST::new(),
                WVALUEL: WVALUEL::new(),
                WVALUEH: WVALUEH::new(),
                WINDEXL: WINDEXL::new(),
                WINDEXH: WINDEXH::new(),
                WLENGTHL: WLENGTHL::new(),
                WLENGTHH: WLENGTHH::new(),
                SIZE_EPOUT0: SIZE_EPOUT0::new(),
                SIZE_EPOUT1: SIZE_EPOUT1::new(),
                SIZE_EPOUT2: SIZE_EPOUT2::new(),
                SIZE_EPOUT3: SIZE_EPOUT3::new(),
                SIZE_EPOUT4: SIZE_EPOUT4::new(),
                SIZE_EPOUT5: SIZE_EPOUT5::new(),
                SIZE_EPOUT6: SIZE_EPOUT6::new(),
                SIZE_EPOUT7: SIZE_EPOUT7::new(),
                SIZE_ISOOUT: SIZE_ISOOUT::new(),
                ENABLE: ENABLE::new(),
                USBPULLUP: USBPULLUP::new(),
                DPDMVALUE: DPDMVALUE::new(),
                DTOGGLE: DTOGGLE::new(),
                EPINEN: EPINEN::new(),
                EPOUTEN: EPOUTEN::new(),
                EPSTALL: EPSTALL::new(),
                ISOSPLIT: ISOSPLIT::new(),
                FRAMECNTR: FRAMECNTR::new(),
                LOWPOWER: LOWPOWER::new(),
                ISOINCONFIG: ISOINCONFIG::new(),
                EPIN0_PTR: EPIN0_PTR::new(),
                EPIN0_MAXCNT: EPIN0_MAXCNT::new(),
                EPIN0_AMOUNT: EPIN0_AMOUNT::new(),
                EPIN1_PTR: EPIN1_PTR::new(),
                EPIN1_MAXCNT: EPIN1_MAXCNT::new(),
                EPIN1_AMOUNT: EPIN1_AMOUNT::new(),
                EPIN2_PTR: EPIN2_PTR::new(),
                EPIN2_MAXCNT: EPIN2_MAXCNT::new(),
                EPIN2_AMOUNT: EPIN2_AMOUNT::new(),
                EPIN3_PTR: EPIN3_PTR::new(),
                EPIN3_MAXCNT: EPIN3_MAXCNT::new(),
                EPIN3_AMOUNT: EPIN3_AMOUNT::new(),
                EPIN4_PTR: EPIN4_PTR::new(),
                EPIN4_MAXCNT: EPIN4_MAXCNT::new(),
                EPIN4_AMOUNT: EPIN4_AMOUNT::new(),
                EPIN5_PTR: EPIN5_PTR::new(),
                EPIN5_MAXCNT: EPIN5_MAXCNT::new(),
                EPIN5_AMOUNT: EPIN5_AMOUNT::new(),
                EPIN6_PTR: EPIN6_PTR::new(),
                EPIN6_MAXCNT: EPIN6_MAXCNT::new(),
                EPIN6_AMOUNT: EPIN6_AMOUNT::new(),
                EPIN7_PTR: EPIN7_PTR::new(),
                EPIN7_MAXCNT: EPIN7_MAXCNT::new(),
                EPIN7_AMOUNT: EPIN7_AMOUNT::new(),
                ISOIN_PTR: ISOIN_PTR::new(),
                ISOIN_MAXCNT: ISOIN_MAXCNT::new(),
                ISOIN_AMOUNT: ISOIN_AMOUNT::new(),
                EPOUT0_PTR: EPOUT0_PTR::new(),
                EPOUT0_MAXCNT: EPOUT0_MAXCNT::new(),
                EPOUT0_AMOUNT: EPOUT0_AMOUNT::new(),
                EPOUT1_PTR: EPOUT1_PTR::new(),
                EPOUT1_MAXCNT: EPOUT1_MAXCNT::new(),
                EPOUT1_AMOUNT: EPOUT1_AMOUNT::new(),
                EPOUT2_PTR: EPOUT2_PTR::new(),
                EPOUT2_MAXCNT: EPOUT2_MAXCNT::new(),
                EPOUT2_AMOUNT: EPOUT2_AMOUNT::new(),
                EPOUT3_PTR: EPOUT3_PTR::new(),
                EPOUT3_MAXCNT: EPOUT3_MAXCNT::new(),
                EPOUT3_AMOUNT: EPOUT3_AMOUNT::new(),
                EPOUT4_PTR: EPOUT4_PTR::new(),
                EPOUT4_MAXCNT: EPOUT4_MAXCNT::new(),
                EPOUT4_AMOUNT: EPOUT4_AMOUNT::new(),
                EPOUT5_PTR: EPOUT5_PTR::new(),
                EPOUT5_MAXCNT: EPOUT5_MAXCNT::new(),
                EPOUT5_AMOUNT: EPOUT5_AMOUNT::new(),
                EPOUT6_PTR: EPOUT6_PTR::new(),
                EPOUT6_MAXCNT: EPOUT6_MAXCNT::new(),
                EPOUT6_AMOUNT: EPOUT6_AMOUNT::new(),
                EPOUT7_PTR: EPOUT7_PTR::new(),
                EPOUT7_MAXCNT: EPOUT7_MAXCNT::new(),
                EPOUT7_AMOUNT: EPOUT7_AMOUNT::new(),
                ISOOUT_PTR: ISOOUT_PTR::new(),
                ISOOUT_MAXCNT: ISOOUT_MAXCNT::new(),
                ISOOUT_AMOUNT: ISOOUT_AMOUNT::new(),
            }
        }
        fn taken() -> &'static AtomicBool {
            static TAKEN: AtomicBool = AtomicBool::new(false);
            &TAKEN
        }
        #[doc = r" Grants temporary access to the peripheral, without checking if it has already been"]
        #[doc = r" taken"]
        #[inline(always)]
        pub fn borrow_unchecked<T>(f: impl FnOnce(&Self) -> T) -> T {
            f(unsafe { &Self::new() })
        }
        #[doc = r" Seals the peripheral making it impossible to `take` it"]
        pub fn seal() {
            Self::taken().store(true, Ordering::Relaxed)
        }
        #[doc = r" Takes ownership of the peripheral"]
        #[doc = r""]
        #[doc = r" This constructor returns the `Some` variant only once"]
        pub fn take() -> Option<Self> {
            let taken = Self::taken();
            if taken
                .compare_exchange(false, true, Ordering::Relaxed, Ordering::Relaxed)
                .is_ok()
            {
                Some(unsafe { Self::new() })
            } else {
                None
            }
        }
    }
}
